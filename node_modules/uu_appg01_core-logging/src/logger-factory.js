"use strict";

const Logger = require("./logger.js");
const { BaseError, Config } = require("uu_appg01_core-utils");

if (typeof window == "undefined") {
  var path = require("path");
  var fs = require("fs");
}

const ROOT_FOLDER_NAMES = ["src", "app"];

/**
 * @class UuApp.Logging.LoggerFactory
 * @classdesc
 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
 */

/**
 * Returns an instance of the logger with given name. Settings of the logger are
 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
 *
 * Successive calls with the same logger name return the same logger instance.
 *
 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
 *   the component that uses the logger, e.g. "My.Namespace.Component".
 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
 *   in successive calls it's ignored.
 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
 * @method UuApp.Logging.LoggerFactory.get
 */
class LoggerFactory {

  constructor() {
    this._loggers = {};
    this._logger = this._get("UuApp.Logging.LoggerFactory");
  }

  get(name = null, hierarchical = true) {
    if (typeof name === "boolean") {
      hierarchical = name;
      name = null;
    }

    if (typeof window != "undefined" && typeof name != "string") {
      throw new BaseError("LoggerFactory.get() must be called with a string argument (logger name).");
    } else if (name == null) {
      name = this._getLoggerName();
    }

    return this._get(name, hierarchical);
  }

  _get(name, hierarchical = true) {
    const cname = name.toLowerCase();
    if (this._loggers[cname]) {
      return this._loggers[cname].logger;
    } else {
      let logger = new Logger(name);
      this.configure(logger, hierarchical);
      this._loggers[cname] = { logger: logger, hierarchical: hierarchical };
      return logger;
    }
  }

  configure(logger, hierarchical) {
    let cname = logger.getName().toString().toLowerCase();
    let logSeverityLabels = Config.get(cname + ".log_severity_labels", hierarchical !== false);
    let logMessageFormat = Config.get(cname + ".log_message_format", hierarchical !== false);
    let logErrorFormat = Config.get(cname + ".log_error_format", hierarchical !== false);
    let logCauseFormat = Config.get(cname + ".log_cause_format", hierarchical !== false);
    let logLevel = Config.get(cname + ".log_level", hierarchical !== false);
    logger.setSeverityLabels(logSeverityLabels);
    logger.setMessageFormat(logMessageFormat);
    logger.setErrorFormat(logErrorFormat);
    logger.setCauseFormat(logCauseFormat);
    logger.setLevel(logLevel);
  }

  configureAll() {
    Object.keys(this._loggers).map((name) => {
      let reg = this._loggers[name];
      this.configure(reg.logger, reg.hirearchical);
    });
  }

  /**
   * @private
   * Generates a unique name for the logger based on the invoking file.
   */
  _getLoggerName() {
    const origLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 3;
    Error.captureStackTrace(this);
    Error.stackTraceLimit = origLimit;
    const lines = this.stack.split("\n");
    const line = lines[3];
    const path = line.match(/\((.*):\d+:\d+\)/);
    if (!path) {
      this._logger.error("Unable to determine logger name. Stack trace is not available.", new Error());
      return "unknown";
    }
    return this._getModuleName(path[1]);
  }

  /**
   * Creates a logger name from a path.
   * Extracts package name from the nearest upstream package.json file and appends the rest of the path.
   * Then formats it as a fully-qualified name (e.g. "My.Namespace.Component").
   * @param {string} modulePath
   */
  _getModuleName(modulePath) {
    const realPath = fs.realpathSync(modulePath);
    const moduleName = path.basename(realPath, path.extname(realPath));
    const packageJsonPath = this._resolvePackageJson(path.dirname(realPath));
    let nameParts = [];
    // path from package.json to the module
    let relPath = "";
    if (packageJsonPath) {
      // if package.json was found, use its namespace or name
      let packageJson;
      try {
        packageJson = require(packageJsonPath);
      } catch (e) {
        this._logger.debug(`Unable to read package.json from ${packageJsonPath}.`, e);
      }

      if (packageJson?.namespace && typeof packageJson.namespace === "string") {
        nameParts.push(packageJson.namespace);
      } else if (packageJson?.name && typeof packageJson.name === "string") {
        // only split by the first "-" and then by "_" to support names like "uu_appg01_core-logging_util"
        // so that "uu_appg01_core" becomes Uu.Appg01.Core and "uu_appg01_core-logging_util" becomes Uu.Appg01.Core.LoggingUtil
        const packageNameParts = /^([^-]+)(?:-(.*))?$/.exec(packageJson.name);
        nameParts.push(...packageNameParts[1].split("_"));
        if (packageNameParts[2]) {
          nameParts.push(packageNameParts[2]);
        }
      } else {
        this._logger.debug(`No namespace or name found in package.json (at ${packageJsonPath}). Using the name of the parent folder instead.`);
        nameParts.push(path.basename(path.dirname(packageJsonPath)));
      }

      relPath = path.relative(path.dirname(packageJsonPath), realPath);
    } else {
      // if no package.json was found, use the filename from the closest src/app folder
      const matchIndexes = ROOT_FOLDER_NAMES.map((name) => realPath.lastIndexOf(name) + name.length + 1);
      const matchIndex = Math.max(...matchIndexes);
      if (matchIndex >= 0) {
        this._logger.debug(`Unable to determine package name for module ${moduleName} (at ${realPath}). No package.json found. The closest src/app folder will be used instead.`);
        relPath = realPath.substring(matchIndex);
      } else {
        // if no src/app folder was found, don't use any name parts
        this._logger.debug(`Unable to determine hierarchical logger name for module ${moduleName} (at ${realPath}). No parent package.json or src/app folder found.`);
      }
    }
    // append relative path without src or app folders
    const relPathParts = relPath.split(path.sep);
    // remove filename - module name is used instead
    relPathParts.pop();
    // filter out empty parts and root folder names in which files are usually located
    nameParts.push(...relPathParts.filter((part) => part && !ROOT_FOLDER_NAMES.includes(part)));
    nameParts.push(moduleName);
    return this._nameFromParts(nameParts);
  }

  _resolvePackageJson(modulePath) {
    const packageJsonPath = path.join(modulePath, "package.json");
    if (fs.existsSync(packageJsonPath)) {
      return packageJsonPath;
    }
    const parentPath = path.dirname(modulePath);
    if (parentPath !== modulePath) {
      return this._resolvePackageJson(parentPath);
    }
    return null;
  }

  /**
   * Returns a nice name for the logger based on the given namespace, path and module name.
   * @param {string[]} parts
   * @private
   * @returns {string}
   */
  _nameFromParts(parts) {
    return parts
      .map((part) => part.replace(/[^a-zA-Z0-9_-]/g, "-"))
      .map((part) => part.replace(/[_-]+([a-zA-Z0-9])?/g, (_, p1) => (p1 ? p1.toUpperCase() : "")))
      .map((part) => part.split(/[\.]/g))
      .flat()
      .filter((part) => part)
      .map((part) => part[0].toUpperCase() + part.slice(1))
      .join(".");
  }

}

module.exports = new LoggerFactory();
