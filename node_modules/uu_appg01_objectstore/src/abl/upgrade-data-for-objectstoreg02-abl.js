"use strict";
const { Validator } = require("uu_appg01_core-validation");
const { DaoFactory } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config } = require("uu_appg01_core-utils");
const { MongoClient } = require("mongodb");

const { DbConnection } = require("uu_appg01_datastore");
const map = Config.get("uuSubAppDataStoreMap");

const Errors = require("../api/errors/upgrade-error");
const CMD_POSTFIX = "upgrade-oid-and-system-attributes";

const Warnings = {
  DataUpgradeUnsupportedKeys: {
    CODE: `${Errors.DataUpgradeForObjectStoreg02.UC_CODE}unsupportedKeys`,
  },
  MonitorDataUpgradeUnsupportedKeys: {
    CODE: `${Errors.MonitorDataUpgradeForObjectStoreg02.UC_CODE}unsupportedKeys`,
  },
};

class DataUpgradeForObjectStoreg02Abl {
  constructor() {
    this.validator = Validator.load();
    this._logger = LoggerFactory.get(`uu.app.upgrade.${this.constructor.name}`);
  }

  /**
   * Migrates data to ObjectStoreg02.
   */
  async dataUpgradeOidAndSystemAttributes(uri, dtoIn, session) {
    let uuAppErrorMap = {};

    // hds 1
    const validationResult = this.validator.validate("dataUpgradeOidAndSystemAttributesDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      uuAppErrorMap,
      Warnings.DataUpgradeUnsupportedKeys.CODE,
      Errors.DataUpgradeForObjectStoreg02.InvalidDtoIn,
    );

    // hds 1
    const schemaList = Object.keys(dtoIn.schemaMap);


    // hds 2
    this._logger.info(
      `Data upgrade of oid and sys attributes of schemas ${JSON.stringify(schemaList, null, 2)} started.`,
    );
    if (DaoFactory.isDataStoreOn()) {
      const db = await DbConnection.get(map[dtoIn.dataStoreName]);
      const collections = (await db.listCollections().toArray()).map(col =>col.name);

      // Check for missing schemas
      const missingSchemas = schemaList.filter((schema) => !Object.values(collections).includes(schema));
      if (missingSchemas.length > 0) {
        throw new Errors.DataUpgradeForObjectStoreg02.SchemaListContainsNonExistingSchemas(
          { uuAppErrorMap },
          missingSchemas,
        );
      }
      // Missing await is because we want to run the query in the background.
      this._upgradeAttributes(dtoIn, db, schemaList, session);
    } else {
      this._logger.error(`Loading datastore failed, nothing upgraded.`);
    }
    return { message: "Data upgrade of oid and sys attributes is running in the background.", uuAppErrorMap };
  }

  async monitorDataUpgradeOidAndSystemAttributes(uri, dtoIn, session) {
    let uuAppErrorMap = {};

    // hds 1
    const validationResult = this.validator.validate("monitorDataUpgradeOidAndSystemAttributesDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      uuAppErrorMap,
      Warnings.MonitorDataUpgradeUnsupportedKeys.CODE,
      Errors.MonitorDataUpgradeForObjectStoreg02.InvalidDtoIn,
    );


    // hds 2
    const findQuery = { "sys.uuObjectType": { $exists: false } };
    let resultMap = {};
    let currentOp = {};
    let itemList = [];
    let mongoClientRplSet;

    try {
      // Initiate connection to the database
      const db = await DbConnection.get(map[dtoIn.dataStoreName]);
      currentOp = await db.admin().command({
        currentOp: 1,
        "$ownOps": 1,
        "command.comment": `${session.getIdentity().getUuAppKey()?.toString()}-${CMD_POSTFIX}`,
      });
      itemList = this._itemListDtoOut(currentOp);

      // Check if operation to kill is present
      await this._processKillOperation(dtoIn, itemList, db, uuAppErrorMap);

      if (dtoIn.countRemainingObjects){
        // Initiate connection to the secondary database
        mongoClientRplSet = await MongoClient.connect(map[dtoIn.dataStoreName], { readPreference: "secondaryPreferred" });
        const replSetDb = mongoClientRplSet.db();

        // Get remaining objects to upgrade
        resultMap = await this._getRemainingObjectsToUpgrade(dtoIn, replSetDb, findQuery);
      }
    } finally {
      if (mongoClientRplSet) {
        await mongoClientRplSet.close();
      }
    }

    return {
      itemList: itemList,
      remainingObjectsToUpgrade: resultMap,
      uuAppErrorMap,
    };
  }

  async _upgradeAttributes(dtoIn, db,  schemaList, session) {
    const resultMap = {};

    // start migration for each schema
    for (let schema of schemaList) {
      let collection = db.collection(schema);

      // add uuObjectStoreg02 required system attributes and oid for simple type
      const bulkResult = await this._addAttributesToCollection(collection, schema, session);
      resultMap[schema] = bulkResult.result ?? bulkResult;
    }
    this._logger.info(`All schemas were migrated with result. ${JSON.stringify(resultMap, null, 2)}`);
  }

  /**
   * Adds required attributes to a collection.
   */
  async _addAttributesToCollection(collection, objectType, session) {
    this._logger.info(`Migration of ${objectType} started.`);
    const findQuery = { "sys.uuObjectType": { $exists: false } };
    let updateQuery = [
      {
        $set: {
          oid: {
            $cond: [{ $eq: [{ $type: "$oid" }, "missing"] }, "$_id", "$oid"],
          },
          "sys.uuObjectType": {
            $cond: [{ $eq: [{ $type: "$sys.uuObjectType" }, "missing"] }, objectType, "sys.uuObjectType"],
          }
        },
      },
    ];

    const result = await collection.updateMany(findQuery, updateQuery, {
      comment: `${session.getIdentity().getUuAppKey()?.toString()}-${CMD_POSTFIX}`,
    });
    this._logger.info(`Updated ${result.modifiedCount} records. Update results: ${JSON.stringify(result, null, 2)}`);
    this._logger.info(`Migration of ${objectType} is finished.`);
    return result;
  }

  async _processKillOperation(dtoIn, itemList, db, uuAppErrorMap) {
    if (dtoIn.operation?.killByOpid) {
      if (!itemList.some((item) => item.opid === dtoIn.operation?.killByOpid)) {
        throw new Errors.MonitorDataUpgradeForObjectStoreg02.OperationKillByOpidNotFound(
          { uuAppErrorMap },
          { opid: dtoIn.operation.killByOpid },
        );
      }
      await db.admin().command({ killOp: 1, op: dtoIn.operation.killByOpid });
    }
  }

  async _getRemainingObjectsToUpgrade(dtoIn, replSetDb, findQuery) {
    const resultMap = {};
    for (let schema of dtoIn.schemaList) {
      resultMap[schema] = await replSetDb.collection(schema).countDocuments(findQuery);
    }
    return resultMap;
  }

  _itemListDtoOut(currentOp) {
    return currentOp.inprog.map(
      ({
         opid,
         active,
         secs_running,
         microsecs_running,
         ns,
         op,
         waitingForLock,
         redacted,
         threaded,
         lockStats,
         numYields,
       }) => ({
        opid,
        active,
        secs_running,
        redacted,
        threaded,
        microsecs_running,
        ns,
        op,
        waitingForLock,
        lockStats,
        numYields,
      }),
    );
  }
}
module.exports = new DataUpgradeForObjectStoreg02Abl();
