"use strict";

const Environment = require("../environment.js");
const DevkitBaseError = require("../errors/devkit-base-error.js");
const LogStoreClient = require("../client/log-store-client.js");
const Help = require("../utils/help.js");

const DEFAULT_LOG_DIR_PATH = "./target";

const printHelp = function(isInProjectScope) {
  Help.print(
    "The task exports logs from the defined app deployment to the specified folder according to user set parameters. Task parameters are:",
    isInProjectScope ?
      [
        ["environment", "Environment for which to execute the task."],
        ["from", "Oldest time of time interval to get records for [defaults to an hour ago]."],
        ["to", "Newest time of time interval to get application log records for [defaults to now]."],
        ["logLevel", "Lowest log level of records to return, the value must be one of: FATAL, ERROR, WARNING, INFO, DEBUG."],
        ["recordType", "Type of log record. Example: directly supported by uuLogstore - TRACE_LOG (errors, debug messages, …),ACCESS_LOG. Other record types can be introduced by other uuApps."],
      ]
    :
      [
        ["uuCloudLogStoreBaseUri", "Base URI of uuLogStore service [mandatory]."],
        ["asid", "The asid of the deployed app you want to get records for [mandatory for uuCloudg02]."],
        ["appDeploymentUri", "The URI of the appdeployment you want to get records for [mandatory for uuCloudg01]."],
        ["from", "Oldest time of time interval to get records for [defaults to an hour ago]."],
        ["to", "Newest time of time interval to get application log records for [defaults to now]."],
        ["logLevel", "Lowest log level of records to return, the value must be one of: FATAL, ERROR, WARNING, INFO, DEBUG."],
        ["recordType", "Type of log record. Example: directly supported by uuLogstore - TRACE_LOG (errors, debug messages, …),ACCESS_LOG. Other record types can be introduced by other uuApps."],
        ["runtimeStackCode", "Code of runtime stack that the returned records contain."],
        ["nodeImageName", "This parameter allows to obtain records only from a particular node."],
        ["nodeName", "This parameter allows to obtain records only from a particular node image."],
        ["hostName", "This parameter allows to obtain only records from a particular host."],
        ["correlationId", "The user can specify last part of index (e.g. 51a..4a6-2) or get all parts of record without specifying (e.g. 51a...4a6)."],
        ["traceId", "Identifier of a request that entered or exited the appplication containers."],
        ["appVersion", "The uuApp version to get records for."],
        ["timeWindowType", "Type of time window, the value must be one of: time, timeStamp, eventTime."],
        ["pageSize", "Result set page size [defaults to 1000]."],
        ["pageIndex", "Result set page number [defaults to 0]."],
        ["logDirPath", "Path to folder where the logs should be exported [defaults to ./target]."],
        [],
        ["credentialsFile", "Path to credentials file containing accessCodes to receive call token from identity provider."],
        ["identityProviderUri", "Uri of identity provider used to issue call token."]
      ],
    {paramPrefix: "--"}
  );
}

module.exports = async function (environment, ...args) {
  let env = new Environment(environment, ...args);
  if (env.getArgumentValue("help") !== undefined) {
    printHelp(env.isInProjectScope());
    return;
  }

  let cloudgDescriptor = env.isInProjectScope() ? env.getCloudg02Descriptor() : null;
  let logStoreUri = env.getArgumentValue("uuCloudLogStoreBaseUri") || env.getDevkitConfig()["uuCloudLogStoreBaseUri"];
  if (!logStoreUri || logStoreUri === Environment.REQUIRED_VALUE_PLACEHOLDER) {
    throw new DevkitBaseError("Missing parameter: uuCloudLogStoreBaseUri");
  }
  let asid = env.getArgumentValue("asid") || (cloudgDescriptor && cloudgDescriptor.uuSubAppDeploymentConfig && cloudgDescriptor.uuSubAppDeploymentConfig.asid);
  let appDeploymentUri = env.getArgumentValue("appDeploymentUri") || env.getDevkitConfig()["appDeploymentUri"];
  if (!asid && !appDeploymentUri) {
    throw new DevkitBaseError("One of parameters must be set: [asid, appDeploymentUri]");
  }
  // TODO handle configuration loading for in project usage
  let from = env.getArgumentValue("from");
  let to = env.getArgumentValue("to");
  let logLevel = env.getArgumentValue("logLevel");
  let recordType = env.getArgumentValue("recordType");
  let runtimeStackCode = env.getArgumentValue("runtimeStackCode");
  let nodeImageName = env.getArgumentValue("nodeImageName");
  let nodeName = env.getArgumentValue("nodeName");
  let hostName = env.getArgumentValue("hostName");
  let correlationId = env.getArgumentValue("correlationId");
  let traceId = env.getArgumentValue("traceId");
  let appVersion = env.getArgumentValue("appVersion");
  let timeWindowType = env.getArgumentValue("timeWindowType");
  let pageSize = env.getArgumentValue("pageSize");
  let pageIndex = env.getArgumentValue("pageIndex");
  let logDirPath = env.getArgumentValue("logDirPath") || DEFAULT_LOG_DIR_PATH;

  if (!from) {
    from = new Date();
    from.setHours(from.getHours() - 1);
    from = from.toISOString();
  }

  if (!to) {
    to = new Date();
    to = to.toISOString();
  }

  let logStoreClient = new LogStoreClient(env);

  const processedIds = new Set();
  let result;
  let firstLoop = true;

  while (true) {
    let params = {};
      
    asid ? (params.asid = asid) : (params.uuUri = appDeploymentUri);
      
    var maxPageSize = 1000;
    params.from = from;
    params.to = to;

    //Testing, validating and saving all logstore parameters
    if (["FATAL", "ERROR", "WARNING", "INFO", "DEBUG"].includes(logLevel)) {
      params.logLevel = logLevel;
    }
    if (typeof recordType === "string") {
      params.recordType = recordType;
    }
    if (runtimeStackCode) {
      params.runtimeStackCode = runtimeStackCode;
    }
    if (typeof nodeImageName === "string") {
      params.nodeImageName = nodeImageName;
    }
    if (typeof nodeName === "string") {
      params.nodeName = nodeName;
    }
    if (typeof hostName === "string") {
      params.hostName = hostName;
    }
    if (typeof correlationId === "string") {
      params.correlationId = correlationId;
    }
    if (typeof traceId === "string") {
      params.traceId = traceId;
    }
    if (/^([0-9]\.[0-9]\.[0-9]\-?.*)$/.test(appVersion)) {
      params.appVersion = appVersion;
    }
    if (typeof timeWindowType === "string") {
      params.timeWindowType = timeWindowType;
    }
    if (!isNaN(Number(pageSize))) {
      var maxPageSize = Math.trunc(pageSize);
      params["pageInfo.pageSize"] = maxPageSize;
    }
    if (!isNaN(Number(pageIndex))) {
      params["pageInfo.pageIndex"] = Math.trunc(pageIndex);
    }

    if (firstLoop == true) {
      console.log("This is the query being used:", Object.entries(params));
      firstLoop = false;
    } else {
      console.log("> Processing query: from=" + from + ", to=" + to);
    }
    let partialResult = await logStoreClient.getRecordList(params)

    // remove duplicates
    partialResult.itemList = partialResult.itemList.filter(item => {
      if (item.id) {
        return processedIds.has(item.id) ? false : processedIds.add(item.id);
      } else {
        return true;
      }
    });
    partialResult.totalSize = partialResult.itemList.length;

    if (result) {
      result.totalSize += partialResult.totalSize;
      result.itemList = result.itemList.concat(partialResult.itemList);
    } else {
      result = partialResult;
    }

    if (partialResult.totalSize < maxPageSize) {
      break;
    } else {
      to = partialResult.itemList[partialResult.itemList.length - 1].time;
      to = new Date(to).toISOString();
      if (new Date(to) < new Date(from)) {
        break;
      }
    }
  }

  const saveAndFormatLogs = require("../utils/save-and-format-logs.js");
  const saveParams = {
    asid,
    appDeploymentUri,
    environment,
    isInProjectScope: env.isInProjectScope(),
    logDirPath,
    from,
    to
  };
  saveAndFormatLogs(result, saveParams);
};
