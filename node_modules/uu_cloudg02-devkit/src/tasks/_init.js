// =============== DO NOT DELETE ================
// Default task providing project initialization.

"use strict";

const Process = require("process");
const Path = require("path");
const Fs = require("fs");
const ChildProcess = require("child_process");
const Environment = require("../environment.js");
const Help = require("../utils/help.js");
const DescriptorConverter = require("../utils/descriptor-converter.js");

const printHelp = function() {
  Help.print(
    "Please specify task to run (use uu_cloudg02-devkit <task> --help to see help for particular task):",
    [
      ["appBox", "The task creates uuAppBox."],
      ["deploy", "The task deploys the application according to user set parameters."],
      ["deployList", "The task exports a list of applications deployed in the given pool."],
      ["swap", "The task swaps appdeployment between the \"production\" and selected \"preview\" slot."],
      ["undeploy", "The task undeploys a specified uuApp from the pool and releases all related allocated resources."],
      ["logExport", "The task exports logs from the defined app deployment to the specified folder according to user set parameters."],
      ["convertDescriptor", "The task provides conversion between uuCloudg01 and uuCloudg02 descriptors."],
      ["appBoxCopy", "The task copies uuAppBox from one registrty into another one."],
      ["appBoxExport", "The task exports uuAppBox into .zip archive on local machine."],
      ["appBoxImport", "The task imports uuAppBox from local zip file created by export task into uuAppBoxRegistry."],
      ["cleanResources", "The task cleans unused uuAppResources in uuAppResourcePool."],
      ["vulnerabilityScan", "The task generates security scan report of uuApp."],
    ]
  );
}

module.exports = async function (environment, ...args) {
  let env = new Environment(environment, ...args);
  if (!env.isInProjectScope()) {
    printHelp();
    return;
  }

  // Load project descriptor
  let projectRoot = Process.env["INIT_CWD"] || Process.cwd();
  let projectPackageJsonPath = Path.join(projectRoot, "package.json");
  let projectPackageJson = JSON.parse(Fs.readFileSync(projectPackageJsonPath));

  // Load plugin descriptor
  let selfPackageJsonPath = Path.join(__dirname, "..", "..", "package.json");
  let selfPackageJson = JSON.parse(Fs.readFileSync(selfPackageJsonPath));
  if (selfPackageJson.name === projectPackageJson.name) {
    return; // do not install into itself or root package.json
  }
  console.log(`Adding ${selfPackageJson.name} plugin to ${projectPackageJson.name}:`);

  // Add plugin as development dependency (if not already present)
  console.log("  Updating project dependencies...");
  let devDependencies = projectPackageJson.devDependencies;
  if (!devDependencies) {
    devDependencies = {};
    projectPackageJson.devDependencies = devDependencies;
  }
  if (!devDependencies[selfPackageJson.name]) {
    devDependencies[selfPackageJson.name] = `^${selfPackageJson.version}`;
  }

  // Load scripts declared in project
  console.log("  Adding npm tasks provided by plugin...");
  let scripts = projectPackageJson.scripts;
  if (!scripts) {
    scripts = {};
    projectPackageJson.scripts = scripts;
  }

  // Compute task prefix (from plugin project name)
  let taskPrefix = selfPackageJson.name
    .replace(/-devkit$/, "")
    .replace(/[\-_][\w0-9]/g, (match) => {
      return `${match[1].toUpperCase()}`;
    });

  // List all task sripts from plugin
  let tasks = Fs.readdirSync(__dirname);
  let isLibWorkspace = projectPackageJson.name.includes("~root");
  tasks.forEach((taskSrc) => {
    // Ignore tasks starting with underscore and convertDescriptor taks
    if (!taskSrc.startsWith("_") && !taskSrc.includes("convert-descriptor")) {
      // Build task name
      let task = taskSrc.split(".")[0].replace(/(-[\w0-9])/g, (match) => {
        return `${match[1].toUpperCase()}`;
      });
      if (!isLibWorkspace || (isLibWorkspace && (task === "deploy" || task === "appBox"))) {
        // Build task qualified name (with plugin project prefix)
        let qualifiedName = `${taskPrefix}${task[0].toUpperCase()}${task.slice(1)}`;
        let command = `${selfPackageJson.name} ${task}`;
        if (!scripts[qualifiedName]) {
          // Add task if not already present
          scripts[qualifiedName] = command;
        } else if (scripts[qualifiedName] !== command) {
          console.warn(`  WARNING: Project already contains custom task \"${qualifiedName}\", skipping.`);
        }
      }
    }
  });

  // Store updated project descriptor
  Fs.writeFileSync(projectPackageJsonPath, JSON.stringify(projectPackageJson, null, 2));

  // Install plugin - install only in case installation is not disabled and project has already installed dependencies
  let nodeModulesPath = Path.join(projectRoot, "node_modules");
  if (Fs.existsSync(nodeModulesPath) && !args.includes("skipinstall")) {
    console.log("  Installing plugin and its dependencies...");
    ChildProcess.execSync(`npm install`, {stdio: 'inherit' });
  }

  // Convert cloud descriptors
  let descriptorDir = Path.join(projectRoot, "env");
  if (!isLibWorkspace && Fs.existsSync(descriptorDir)) {
    console.log("  Preparing uuCloudg02 descriptors...");
    let descriptorDir = Path.join(projectRoot, "env");
    let g01Descriptors = [];
    for (let file of Fs.readdirSync(descriptorDir)) {
      if (file.match(/^uucloudg02-([^\.-]+).json$/)) {
        // In case there is already any existing g02 descriptor
        // skip the conversion as project was already upgraded.
        g01Descriptors = [];
        break;
      } else {
        let g01DescriptorMatch = file.match(/^uucloud-([^\.-]+).json$/);
        if (g01DescriptorMatch) {
          let environment = g01DescriptorMatch[1];
          g01Descriptors.push([file, environment]);
        }
      }
    }
    for (let [file, environment] of g01Descriptors) {
      try {
        let cloudg01Descriptor = JSON.parse(Fs.readFileSync(Path.join(descriptorDir, file)));
        let cloudg02Descriptor = DescriptorConverter.convert(cloudg01Descriptor, {excludeVersion: true});
        let cloudg02DescriptorPath = Path.join(descriptorDir, `uucloudg02-${environment}.json`);
        Fs.writeFileSync(cloudg02DescriptorPath, JSON.stringify(cloudg02Descriptor, null, 2));
      } catch (e) {
        console.warn(`  WARNING: Conversion of descriptor ${file} failed (${e.message}).`);
      }
    }
  }

  // Update project configuration
  let uuappJsonPath = Path.join(projectRoot, isLibWorkspace ? "." : "..", "uuapp.json");
  if (Fs.existsSync(uuappJsonPath)) {
    console.log("  Updating configuration in uuapp.json...");
    let uuappJsonContent = Fs.readFileSync(uuappJsonPath);
    let uuCloudUniverseBaseUriAlreadySet = uuappJsonContent.includes('"uuCloudUniverseBaseUri"');
    let uuCloudLogStoreBaseUriAlreadySet = uuappJsonContent.includes('"uuCloudLogStoreBaseUri"');
    let uu5LibraryRepositoryWorkloadOidAlreadySet = uuappJsonContent.includes('"uu5LibraryRepositoryWorkloadOid"');
    let uuAppBoxRegistryBaseUriAlreadySet = uuappJsonContent.includes('"uuAppBoxRegistryBaseUri"');
    let uuappJsonUpdated = false;
    let updateConfig = function (config) {
      if (!uuCloudUniverseBaseUriAlreadySet && !config.uuCloudUniverseBaseUri) {
        config.uuCloudUniverseBaseUri = Environment.REQUIRED_VALUE_PLACEHOLDER;
        uuappJsonUpdated = true;
      }
      if (!isLibWorkspace) {
        if (!uuCloudLogStoreBaseUriAlreadySet && !config.uuCloudLogStoreBaseUri) {
          config.uuCloudLogStoreBaseUri = Environment.REQUIRED_VALUE_PLACEHOLDER;
          uuappJsonUpdated = true;
        }
      } else {
        if (!uu5LibraryRepositoryWorkloadOidAlreadySet && !config.uu5LibraryRepositoryWorkloadOid) {
          config.uu5LibraryRepositoryWorkloadOid = Environment.REQUIRED_VALUE_PLACEHOLDER;
          uuappJsonUpdated = true;
        }
      }
      if (!uuAppBoxRegistryBaseUriAlreadySet && !config.uuAppBoxRegistryBaseUri) {
        config.uuAppBoxRegistryBaseUri = Environment.REQUIRED_VALUE_PLACEHOLDER;
        uuappJsonUpdated = true;
      }
    };
    let uuappJson = JSON.parse(uuappJsonContent);
    // Update root configuration
    uuappJson.devkit && Object.values(uuappJson.devkit).forEach(updateConfig);
    // Update project specific configuration
    let projectConfig = uuappJson[Path.basename(projectRoot)];
    projectConfig && projectConfig.devkit && Object.values(projectConfig.devkit).forEach(updateConfig);
    if (uuappJsonUpdated) {
      Fs.writeFileSync(uuappJsonPath, JSON.stringify(uuappJson, null, 2));
    }
  }

  console.log(`Project successfully initialized.\n`);
};
