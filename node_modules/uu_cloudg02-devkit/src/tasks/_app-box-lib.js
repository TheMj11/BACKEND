const Path = require("path");
const ChildProcess = require("child_process");
const fs = require("fs");
const path = require("path");

const Environment = require("../environment");
const AppPackRepositoryClient = require("../client/app-pack-repository");
const Help = require("../utils/help");
const AppBoxClient = require("../client/app-box");

class UuAppJson {
  constructor(env) {
    const jsonPath = Path.join(env.getWorkdir(), "uuapp.json");
    this.uuAppJson = require(jsonPath);
  }

  get product() {
    return this.uuAppJson.product;
  }

  get version() {
    return this.uuAppJson.version;
  }

  get packName() {
    return this.product.toLowerCase().replaceAll("_", "-");
  }

  get libraryName() {
    return this.product.replace(/^uu_uu5/, "uu5");
  }
}

const printHelp = function (isInProjectScope) {
  Help.print(
    "The task creates uuAppBox for uu5Libraries into uuAppBoxRegistry. Task parameters are:",
    isInProjectScope
      ? [
          ["environment", "Environment for which to execute the task."],
          ["doNotPublish", "Flag whether created uuAppBox should be published to uuAppBoxRegistry."],
        ]
      : [
          ["uuAppBoxRegistryBaseUri", "Address of uuAppBoxRegistry."],
          ["uuAppBoxJsonOut", "Optional path where to store AppBox in json format."],
          ["doNotPublish", "Flag whether created uuAppBox should be published to uuAppBoxRegistry."],
          [],
          [
            "credentialsFile",
            "Path to credentials file containing accessCodes to receive call token from identity provider.",
          ],
          ["identityProviderUri", "Uri of identity provider used to issue call token."],
        ],
    { paramPrefix: "--" },
  );
};

function validateParameters(env) {
  let uuAppBoxRegistryBaseUri =
    env.getArgumentValue("uuAppBoxRegistryBaseUri") || env.getDevkitConfig().uuAppBoxRegistryBaseUri;
  if (!uuAppBoxRegistryBaseUri || uuAppBoxRegistryBaseUri === Environment.REQUIRED_VALUE_PLACEHOLDER) {
    throw new Error("Missing parameter: uuAppBoxRegistryBaseUri");
  }

  return { uuAppBoxRegistryBaseUri };
}

async function deleteAppbox(appBoxClient, uuAppJson) {
  const appboxList = await appBoxClient.list();
  const currentAppbox = appboxList.itemList.find((item) => {
    const { metadata } = item;
    return (
      metadata.type === "uu5Library" && metadata.code === uuAppJson.packName && metadata.version === uuAppJson.version
    );
  });

  // TODO Use uuAppBox/update if it becomes available instead of deleting. That will also solve potential issue
  // where if developer runs uu5Library deploy (to uuAppLibraryRegistry), appBox gets built & deployed to cloud and then
  // if creating in uuAppLibraryRegistry fails (e.g. in last setDeploymentResult step), the developer might want to run
  // the operation again but that will delete the uuAppBox so uuALR will start complaining that the library versions already
  // exist and that they're from different uuAppBox so they'll have to be deleted manually (or version would have to be
  // adjusted).
  // https://uuapp.plus4u.net/uu-sls-maing01/33053d4f7504459f8ada5cf96500548a/issueDetail?id=6622989d2af5400034eb9b9a
  if (currentAppbox) {
    console.log("Deleting uuAppBox " + currentAppbox.id);

    if (currentAppbox.state === "created") {
      await appBoxClient.cancel(currentAppbox.id);
    } else {
      await appBoxClient.suspend(currentAppbox.id);
      await appBoxClient.close(currentAppbox.id);
    }
    await appBoxClient.delete(currentAppbox.id);
  }
}

async function createAppbox(env, appBoxClient, uu5LibraryAppPackUri, uu5LibrarySourcesAppPackUri) {
  const uuAppJson = new UuAppJson(env);

  // read descriptor
  const libDescriptorNameSuffix = `-${uuAppJson.version}-library-descriptor.json`;
  const targetPath = path.join(env.getWorkdir(), "target");
  const libraryDescriptorFile = fs.readdirSync(targetPath).find((file) => file.endsWith(libDescriptorNameSuffix));
  if (!libraryDescriptorFile) {
    throw new Error("Could not find library descriptor by file name suffix: " + libDescriptorNameSuffix);
  }
  const libraryDescriptorPath = path.join(targetPath, libraryDescriptorFile);
  const libraryDescriptor = require(libraryDescriptorPath, "utf8");

  // TODO Remove after devkit stops supporting uuCloudg01. Devkit currently generates library descriptor usable for both
  // uuCloudg01 && g02 where libraryList[].sourceUri contains pre-computed absolute URL to cdn.plus4u.net (for uuCloudg01).
  // We'll keep at most file name from that, because uuCloudg02+uuALR computes full URL only after deploying to uuCloudg02.
  for (let library of libraryDescriptor.libraryList) {
    if (!library.sourceUri || !/^https?:/.test(library.sourceUri)) continue;
    if (library.sourceUri.endsWith("/" + library.name + ".min.js")) {
      delete library.sourceUri; // same as default by convention, remove
    } else {
      library.sourceUri = library.sourceUri.split(/\/\d+\.\d+\.\d+[^/]*\//).pop(); // non-standard, keep URL path following the version
    }
  }

  const appBoxDescriptor = {
    schemaVersion: "2.0",
    code: uuAppJson.packName,
    version: uuAppJson.version,
    name: uuAppJson.product,
    uuAppPackMap: {
      uuAppPack01: {
        type: "uu5Library",
        uri: uu5LibraryAppPackUri,
      },
      uuAppPack02: {
        type: "uu5Library_sources",
        uri: uu5LibrarySourcesAppPackUri,
      },
    },
    deliverySpecType: "uu5libraryspec:1.0",
    deliverySpec: {
      uuApp: libraryDescriptor.uuApp,
      urlPath: uuAppJson.packName,
      uuAppPackRef: "uuAppPack01",
      generation: libraryDescriptor.generation,
      libraryList: libraryDescriptor.libraryList,
      componentList: libraryDescriptor.componentList,
    },
  };

  console.log("Creating uuAppBox.");
  const publishAppbox =
    env.getArgumentValue("doNotPublish") === undefined ||
    (env.getArgumentValue("doNotPublish") !== null && env.getArgumentValue("doNotPublish") !== "true");
  let appBoxUri;
  if (publishAppbox) {
    let { uri, uuAppBox } = await appBoxClient.create(appBoxDescriptor, { extendedResult: true });
    appBoxUri = uri;
    console.log(`Created appbox:\n  -> ${appBoxUri}`);
    let appBoxId = uuAppBox?.id;
    if (appBoxId) console.log(`  -> ${appBoxClient.baseUri}/uuAppBoxDetail?id=${appBoxId}`);
  }

  let appBoxJsonPath = env.getArgumentValue("uuAppBoxJsonOut");
  if (!appBoxJsonPath && env.isInProjectScope()) {
    appBoxJsonPath = Path.join(env.getWorkdir(), "target", `${uuAppJson.libraryName}-${uuAppJson.version}-appbox.json`);
  }
  if (appBoxJsonPath) {
    fs.writeFileSync(appBoxJsonPath, JSON.stringify(appBoxDescriptor, null, 2) + "\n");
    if (!appBoxUri) console.log(`  -> ${appBoxJsonPath}`);
  }

  if (appBoxUri) {
    env.updateProjectDevkitConfig("uuAppBoxUri", appBoxUri);
  }

  return appBoxUri || appBoxJsonPath;
}

function buildLibrary(env) {
  const skipBuild = env.getArgumentValue("skipBuild");
  if (skipBuild !== true && skipBuild !== "true" && skipBuild !== null) {
    console.log("Building uu5Library.");
    ChildProcess.execSync(`npm run package`, { stdio: "inherit", cwd: env.getWorkdir() });
    env.reload(); // Reload to load changes done by appBox
  }
}

async function uploadUuAppPack(env, packPath, appPackType) {
  const uuAppJson = new UuAppJson(env);
  const appPackRepoClient = new AppPackRepositoryClient(env);
  const appPackKey = `uuAppPack_${uuAppJson.packName}_${uuAppJson.version.replaceAll(".", "_")}_${appPackType}`;
  const appPackData = fs.createReadStream(packPath);
  await appPackRepoClient.uploadPack(appPackType, appPackKey, appPackData, true);
  return { appPackKey };
}

async function uu5LibAppBox(environment, ...args) {
  const env = new Environment(environment, ...args);
  if (env.getArgumentValue("help") !== undefined) {
    printHelp(env.isInProjectScope());
    return;
  }

  console.log("Building uu5Library uuAppBox...\n");

  // validate required parameters
  validateParameters(env);

  // build library to get sources for app pack
  buildLibrary(env);

  // NOTE If uuAppBox already exists, there is no uuAppBox/update, so we have to delete it first...
  // Additionally, deleting uuAppBox deletes associated uuAppPack-s (if they're not used from elsewhere),
  // which means that we have to delete it sooner than we upload new uuAppPacks-s (because they'll have
  // the same code as before and thus would get deleted during uuAppBox/delete).
  const appBoxClient = new AppBoxClient(env);
  const uuAppJson = new UuAppJson(env);
  await deleteAppbox(appBoxClient, uuAppJson);

  // upload app packs
  console.log(`Uploading uuAppPacks to uuAppPackRepository (uu5Library, uu5Library_sources).`);
  const uu5LibraryPackPath = Path.resolve(
    env.getWorkdir(),
    "target",
    `${uuAppJson.libraryName}-${uuAppJson.version}-cdn-pack.zip`,
  );
  const uu5LibrarySourcesPackPath = Path.resolve(
    env.getWorkdir(),
    "target",
    `${uuAppJson.libraryName}-${uuAppJson.version}-library-pack.zip`,
  );
  const packs = await Promise.all([
    uploadUuAppPack(env, uu5LibraryPackPath, "uu5Library"),
    uploadUuAppPack(env, uu5LibrarySourcesPackPath, "uu5Library_sources"),
  ]);
  const [{ appPackKey: uu5LibraryAppPackUri }, { appPackKey: uu5LibrarySourcesAppPackUri }] = packs;

  // create or update appBox
  await createAppbox(env, appBoxClient, uu5LibraryAppPackUri, uu5LibrarySourcesAppPackUri);
}

module.exports = uu5LibAppBox;
