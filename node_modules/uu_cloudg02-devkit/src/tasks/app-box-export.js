const Help = require("../utils/help");
const Environment = require("../environment");
const DevkitBaseError = require("../errors/devkit-base-error");
const AppBox = require("../client/app-box.js");
const os = require("os");
const fs = require("fs");
const path = require("path");
const AdmZip = require("adm-zip");
const childProcess = require("child_process");
const ChildProcessError = require("../errors/child-process-error");
const EnvParamHelper = require("../utils/env-param-helper");

const printHelp = function (isInProjectScope) {
  Help.print(
    "The task exports uuAppBox into .zip archive on local machine. Task parameters are:",
    isInProjectScope
      ? [
          ["environment", "Environment for which to execute the task."],
          [],
          [
            "uuAppPackBuildTool",
            'Preferred uuAppPack build tool used for building the image (one of ["docker", "podman"]).',
          ],
        ]
      : [
          ["uuAppBoxUri", "URI of source uuAppBox"],
          ["uuAppBoxFolderPath", "Path where the uuAppBox export will be stored."],
          [],
          [
            "credentialsFile",
            "Path to credentials file containing accessCodes to receive call token from identity provider.",
          ],
          ["identityProviderUri", "Uri of identity provider used to issue call token."],
          [],
          [
            "uuAppPackBuildTool",
            'Preferred uuAppPack build tool used for building the image (one of ["docker", "podman"]).',
          ],
        ],
    { paramPrefix: "--" }
  );
};

async function validateParameters(env) {
  const appBoxUri = EnvParamHelper.validateSingleParameter(env, "uuAppBoxUri");

  const defaultAppBoxPath = env.isInProjectScope() ? "./target" : null;
  const appBoxPath = EnvParamHelper.validateSingleParameter(env, "uuAppBoxFolderPath", defaultAppBoxPath);

  // create the folder if it does not exist yet (might be a "target" folder)
  if (!fs.existsSync(appBoxPath)) {
    await fs.promises.mkdir(appBoxPath, { recursive: true });
  }

  let containerRuntime = env.getContainerRuntime();
  if (!containerRuntime) {
    throw new DevkitBaseError("Either docker or podman must be installed to be able to export uuAppBox.");
  }

  return { appBoxUri, appBoxPath, containerRuntime };
}

/**
 * Method creates temporary directory and makes sure that it is deleted after the lambda call
 *
 * @param {function} lambda Logic to be executed
 * @returns {Promise<void>}
 */
async function withTmpDir(lambda) {
  const tmpDirName = path.join(os.tmpdir(), "appbox");
  const tmpDir = await fs.promises.mkdtemp(tmpDirName);
  try {
    return await lambda(tmpDir);
  } finally {
    await fs.promises.rm(tmpDir, { recursive: true });
  }
}

async function createAppBoxZip(appBoxPath, appboxFldPath, tmpDir) {
  console.log(`\nCreating .zip archive of uuAppBox and its uuAppPacks...\n`);
  const targetZipPath = path.join(appBoxPath, `${path.basename(appboxFldPath)}.zip`);
  const zip = new AdmZip();
  zip.addLocalFolder(tmpDir);
  await zip.writeZipPromise(targetZipPath);

  return targetZipPath;
}

// TODO implement logic specific for uu5 library
async function downloadUuAppPacks(appBox, containerRuntime, appboxFldPath) {
  for (const uuAppPackKey of Object.keys(appBox.uuAppPackMap)) {
    const appPackData = appBox.uuAppPackMap[uuAppPackKey];
    console.log(`Exporting uuAppPack ${uuAppPackKey} from ${appPackData.uri}...\n`);

    let sourceImage = appPackData.uri;
    if (sourceImage.includes("://")) {
      sourceImage = sourceImage.split("://")[1];
    }

    try {
      childProcess.execSync(`${containerRuntime} pull ${sourceImage}`, {
        cwd: appboxFldPath,
        stdio: "inherit",
      });
    } catch (e) {
      throw new ChildProcessError(`Pulling of image ${uuAppPackKey} failed.`, e.message);
    }

    // compression of .tar to .tar.gz is not necessary, because we use zlib level 9 to compress everything anyway
    try {
      childProcess.execSync(`${containerRuntime} save --output ${uuAppPackKey}.tar ${sourceImage}`, {
        cwd: appboxFldPath,
        stdio: "inherit",
      });
    } catch (e) {
      throw new ChildProcessError(`Exporting of image ${uuAppPackKey} failed.`, e.message);
    }

    // TODO should we rm the image afterwards from local machine?
  }
}

async function downloadUuAppBox(appBoxUri, env, tmpDir) {
  console.log(`Downloading uuAppBox from uri ${appBoxUri}...\n`);
  const appBoxClient = new AppBox(env);
  const { data: appBox } = await appBoxClient.get(appBoxUri);

  const appboxFldPath = path.join(tmpDir, `${appBox.code.replace(/-/g, "_")}-appbox-${appBox.version}`);
  await fs.promises.mkdir(appboxFldPath);

  // save uuAppBox.json to the tmpdir
  await fs.promises.writeFile(path.join(appboxFldPath, "uuAppBox.json"), JSON.stringify(appBox, "\t", 2));

  return { appBox, appboxFldPath };
}

async function exportUuAppBox(environment, ...args) {
  let env = new Environment(environment, ...args);
  if (env.getArgumentValue("help") !== undefined) {
    printHelp(env.isInProjectScope());
    return;
  }

  const { appBoxUri, appBoxPath, containerRuntime } = await validateParameters(env);

  // create tmpdir to save uuAppBox json and the subsequent uuAppPacks
  const targetZipPath = await withTmpDir(async (tmpDir) => {
    const { appBox, appboxFldPath } = await downloadUuAppBox(appBoxUri, env, tmpDir);

    await downloadUuAppPacks(appBox, containerRuntime, appboxFldPath);

    // now pack everything into a zip file and save it to appBoxPath
    return await createAppBoxZip(appBoxPath, appboxFldPath, tmpDir);
  });

  console.log(`uuAppBox exported to path: ${path.resolve(targetZipPath)}`);
}

module.exports = exportUuAppBox;
