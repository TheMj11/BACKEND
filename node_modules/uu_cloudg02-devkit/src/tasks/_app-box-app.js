"use strict";

const Fs = require("fs");
const Os = require("os");
const Path = require("path");
const Http = require("http");
const Process = require("process");
const ChildProcess = require("child_process");
const Environment = require("../environment.js");
const DevkitBaseError = require("../errors/devkit-base-error.js");
const ChildProcessError = require("../errors/child-process-error");
const Help = require("../utils/help.js");
const AppBox = require("../client/app-box.js");
const AppPackRepository = require("../client/app-pack-repository.js");

const printHelp = function(isInProjectScope) {
  Help.print(
    "The task creates uuAppBox. Task parameters are:",
    isInProjectScope ?
      [
        ["environment", "Environment for which to execute the task."],
        ["useProjectPackageLock", "Flag whether dependencies in uuAppBox should be installed based on current package-lock.json from project (defaults to false; uses clean install of dependencies)."],
        ["doNotPublish", "Flag whether created uuAppBox should be published to uuAppBoxRegistry."],
        [],
        ["uuAppPackBuildTool", "Preferred uuAppPack build tool used for building the image (one of [\"docker\", \"podman\"])."],
        ["compatModeEnabled", "Allow image build to run on older version of toolset where \"host-gateway\" mapping is not supported. Results in bigger image size."]
      ]
    :
      [
        ["uuSubAppInstanceDescriptor", "Path to source uuCloud descriptor."],
        ["uuAppPackPath", "Path to application pack."],
        ["uuAppImageRegistryUri", "Address of target docker registry."],
        ["uuAppBoxRegistryBaseUri", "Address of uuAppBoxRegistry."],
        ["uuAppBoxJsonOut", "Optional path where to store AppBox in json format."],
        ["doNotPublish", "Flag whether created uuAppBox should be published to uuAppBoxRegistry."],
        [],
        ["credentialsFile", "Path to credentials file containing accessCodes to receive call token from identity provider."],
        ["identityProviderUri", "Uri of identity provider used to issue call token."],
        [],
        ["uuAppPackBuildTool", "Preferred uuAppPack build tool used for building the image (one of [\"docker\", \"podman\"])."],
        ["compatModeEnabled", "Allow image build to run on older version of toolset where \"host-gateway\" mapping is not supported. Results in bigger image size."]
      ],
    {paramPrefix: "--"}
  );
}

const fileDownloadServer = function(filePath, fileName = null) {
  let server = Http.createServer((req, res) => {
    let fileStream = Fs.createReadStream(filePath);
    res.writeHead(200, {
      "Content-Disposition": `inline; filename="${fileName || Path.basename(filePath)}"`,
      "Content-Type": "application/octet-stream",
      "Connection": "close"
    });
    fileStream.pipe(res);
  });
  let socketList = [];
  server.on("connection", (socket) => socketList.push(socket));
  server.listen(0);
  let origClose = server.close.bind(server);
  server.close = () => {
    for (let socket of socketList) {
      socket.destroy();
    }
    origClose();
  }
  return server;
}

const getLabels = function(env, imageVersion) {
  const selfPackageJsonPath = Path.join(__dirname, "..", "..", "package.json");
  const selfPackageJson = JSON.parse(Fs.readFileSync(selfPackageJsonPath));

  const devkitVersion = selfPackageJson.version;
  const cts = new Date().toISOString().replaceAll(/[T.]/g, ":").replace(/\dZ$/, "Z");

  let missingParameters = [];
  const vendor = env.getArgumentValue("vendor") || env.getDevkitConfig()["vendor"] || "";
  if (!vendor) {
    missingParameters.push("vendor");
  }
  const imageUri = env.getArgumentValue("imageUri") || env.getDevkitConfig()["imageUri"] || "";
  if (!imageUri) {
    missingParameters.push("imageUri");
  }
  const docUri = env.getArgumentValue("docUri") || env.getDevkitConfig()["docUri"] || "";
  if (!docUri) {
    missingParameters.push("docUri");
  }
  
  if (missingParameters.length) {
    console.warn(
      `\nWARNING: Missing ${env.isInProjectScope() ? "uuapp.json keys" : "parameters"}: ${missingParameters.join(", ")}. ` +
      "Image will not be properly labeled!\n"
    );
  }

  return `LABEL maintainer="${vendor}"
    LABEL version="${imageVersion}"
    LABEL uu.appdevkit.version="${devkitVersion}"
    LABEL org.opencontainers.image.created="${cts}"
    LABEL org.opencontainers.image.authors="${vendor}"
    LABEL org.opencontainers.image.url="${imageUri}"
    LABEL org.opencontainers.image.documentation="${docUri}"
    LABEL org.opencontainers.image.version="${imageVersion}"
    LABEL org.opencontainers.image.vendor="${vendor}"`;
}

module.exports = async function (environment, ...args) {
  let env = new Environment(environment, ...args);
  if (env.getArgumentValue("help") !== undefined) {
    printHelp(env.isInProjectScope());
    return;
  }

  console.log("\nCreating uuAppBox...\n");

  if (env.isInProjectScope()) {
    let useProjectPackageLock = env.getArgumentValue("useProjectPackageLock");
    let packageLockArgValue = (useProjectPackageLock === null || useProjectPackageLock === "true") ? "included" : "omitted";
    try {
      ChildProcess.execSync(`npm run package -- --packageLock=${packageLockArgValue}`, {stdio: 'inherit' });
    } catch (e) {
      throw new ChildProcessError("Creating uuApp package failed.", e.message);
    }
    env.reload(); // Reload to load changes done by package (and build)
  }

  let descriptor = env.getCloudg02Descriptor();
  if (!descriptor.uuAppBoxDescriptor || !descriptor.uuAppBoxDescriptor.schemaVersion || !descriptor.uuAppBoxDescriptor.schemaVersion.startsWith("2.")) {
    if (env.isInProjectScope()) {
      throw new DevkitBaseError("Invalid descriptor (schemaVersion 2x is required).");
    } else {
      throw new DevkitBaseError("Missing parameter: uuSubAppInstanceDescriptor");
    }
  }
  let imageVersion = env.getProjectVersion();
  if (!imageVersion) {
    throw new DevkitBaseError("Missing declaration of project version.");
  }
  let imageCode = descriptor.uuAppBoxDescriptor.code;
  if (!imageCode) {
    throw new DevkitBaseError("Missing declaration of project code.");
  }
  let appPackPath = env.getArgumentValue("uuAppPackPath");
  if (!appPackPath && env.isInProjectScope()) {
    if (imageVersion.match(/\-[a-zA-Z][a-zA-Z0-9]*$/)) {
      // Find most recent package
      Fs.readdirSync(Path.join(env.getWorkdir(), "target")).forEach((file) => {
        if (file.includes(`${imageVersion}.`) && file.endsWith(".zip")) {
          appPackPath = Path.join(env.getWorkdir(), "target", file);
        }
      });
      if (appPackPath) {
        // Update image version
        let timestamp = appPackPath.split(`${imageVersion}.`)[1].split(".")[0];
        imageVersion += `.${timestamp}`;
      }
    } else {
      let appPackFilename = `${env.getPackageConfig().name}-${env.getPackageConfig().version}.zip`;
      appPackPath = Path.join(env.getWorkdir(), "target", appPackFilename);
    }
  }
  if (!appPackPath) {
    throw new DevkitBaseError("Missing parameter: uuAppPackPath");
  }
  if (!Fs.existsSync(appPackPath) || !Fs.lstatSync(appPackPath).isFile()) {
    throw new DevkitBaseError(`Application pack [${appPackPath}] does not exist or is not a file.`);
  }
  if (imageVersion.match(/\-[a-zA-Z][a-zA-Z0-9]*$/)) {
    let timestamp = new Date().toISOString().replace(/[\-:T]/g, "").split(".")[0];
    imageVersion += `.${timestamp}`;
  }
  let appBoxClient;
  let appPackRepositoryClient;
  let publishAppbox = (env.getArgumentValue("doNotPublish") === undefined || (env.getArgumentValue("doNotPublish") !== null && env.getArgumentValue("doNotPublish") !== "true"));
  let appBoxRegistryUri = env.getArgumentValue("uuAppBoxRegistryBaseUri") || env.getDevkitConfig()["uuAppBoxRegistryBaseUri"];
  if (!appBoxRegistryUri || appBoxRegistryUri === Environment.REQUIRED_VALUE_PLACEHOLDER) {
    if (publishAppbox) {
      throw new DevkitBaseError("Missing parameter: uuAppBoxRegistryBaseUri");
    }
  }
  if (appBoxRegistryUri && !AppBox.isSupported(appBoxRegistryUri)) {
    throw new DevkitBaseError("Parameter uuAppBoxRegistryBaseUri refers to unsupported storage type.");
  }
  // TODO Only temporary, should not be necessary once resulting image is uploaded
  //   via uuCloud command instead of direct push to docker registry
  let useAbsoluteUri = appBoxRegistryUri && !appBoxRegistryUri.includes(AppBox.APPBOX_REGISTRY);
  let imageRegistryUri = env.getArgumentValue("uuAppImageRegistryUri") || env.getDevkitConfig()["uuAppImageRegistryUri"];
  if (!imageRegistryUri || imageRegistryUri === Environment.REQUIRED_VALUE_PLACEHOLDER) {
    if (appBoxRegistryUri && appBoxRegistryUri.includes(AppBox.APPBOX_REGISTRY)) {
      // If imageRegistryUri is not set but uuAppBoxRegistry is used,
      // imageRegistryUri will be obtained through appPackRepositoryClient
      imageRegistryUri = null;
      appPackRepositoryClient = new AppPackRepository(env);
    } else if (publishAppbox) {
      throw new DevkitBaseError("Missing parameter: uuAppImageRegistryUri");
    }
  }
  let containerRuntime = env.getContainerRuntime();
  if (!containerRuntime) {
    throw new DevkitBaseError("Either docker or podman must be installed to be able to create uuAppBox.");
  }
  if (appBoxRegistryUri) {
    appBoxClient = new AppBox(env);
    if (publishAppbox) {
      try {
        // Ensure, that user is authorized to create uuAppBox
        await appBoxClient.create({});
      } catch (e) {
        if (e.cause.status === 403) {
          throw new DevkitBaseError("User is not authorized to create uuAppBox.", { paramMap: e.cause.paramMap?.dtoOut });
        }
      }
    }
  }

  console.log("\nPreparing image build environment...\n");
  
  let buildDir;
  if (env.isInProjectScope()) {
    buildDir = Path.join(env.getWorkdir(), "target", `apppack_image_build_${Date.now()}`);
  } else {
    buildDir = Path.join(Os.tmpdir(), `apppack_image_build_${Date.now()}`);
  }
  Fs.mkdirSync(buildDir, { recursive: true });
  let compatModeEnabled = env.getArgumentValue("compatModeEnabled") !== undefined && env.getArgumentValue("compatModeEnabled") !== "false";
  if (!compatModeEnabled) {
    if (Process.platform === "win32" && containerRuntime.includes("podman")) {
      console.warn(`\nWARNING: Enforcing build compatibility mode as Podman on Windows does not support optimized image build!`);
      compatModeEnabled = true;
    }
  }

  let fileServer;
  let appPackFilename;
  if (compatModeEnabled) {
    appPackFilename = Path.basename(appPackPath);
    Fs.copyFileSync(appPackPath, Path.join(buildDir, appPackFilename));
  } else {
    fileServer = fileDownloadServer(appPackPath);
  }

  try {

    for (let [appPackCode, appPackData] of Object.entries(descriptor.uuAppBoxDescriptor.uuAppPackMap)) {

      let nodeSet = Object.values(descriptor.uuAppBoxDescriptor.deliverySpec.uuNodeSetMap).find((nodeSet) => nodeSet.uuAppPackRef === appPackCode);
      let urlPath = descriptor.uuAppBoxDescriptor.deliverySpec.urlPath || descriptor.uuAppBoxDescriptor.code;
      if (nodeSet.uuNodeSetType === "cmdAsync") {
        urlPath += "-async";
      }

      let dockerfile = `Dockerfile_${appPackCode}`;
      // TODO Where to get runtime stack? Now it is appended in descriptor extending its specification.
      // URL path is ignored for NodeJs, but is mandatory for java as we need to use proper war name.
      if (!descriptor.uuAppPackRuntimeStackMap || !descriptor.uuAppPackRuntimeStackMap[appPackCode]) {
        throw new DevkitBaseError(`Missing declaration of uAppPackRuntimeStack for uuAppPack "${appPackCode}"`);
      }
      let runtimeStack = descriptor.uuAppPackRuntimeStackMap[appPackCode];
      if (runtimeStack.includes("://")) {
        runtimeStack = runtimeStack.split("://")[1];
      }
      if (compatModeEnabled) {
        Fs.writeFileSync(Path.join(buildDir, dockerfile),
          `FROM ${runtimeStack}
          ${getLabels(env, imageVersion)}
          COPY ./${appPackFilename} /tmp/app_pack.bin
          ENV APP_PACK_URL_PATH=${urlPath}
          RUN /usr/local/build
          CMD /usr/local/start`
        );
      } else {
        let hostname = containerRuntime.startsWith("wsl") ? Os.hostname() : "host.docker.internal";
        Fs.writeFileSync(Path.join(buildDir, dockerfile),
          `FROM ${runtimeStack}
          ${getLabels(env, imageVersion)}
          ENV APP_PACK_URL_PATH=${urlPath}
          RUN curl -s http://${hostname}:${fileServer.address().port} > /tmp/app_pack.bin && /usr/local/build
          CMD /usr/local/start`
        );
      }

      console.log(`\nBuilding image for ${appPackCode}...\n`);

      let appPackImageRegistryUri = imageRegistryUri;
      if (!appPackImageRegistryUri && appPackRepositoryClient) {
        let appPackRepository = await appPackRepositoryClient.get(appPackData.type);
        appPackImageRegistryUri = appPackRepository.uri.replace(/\/$/, "");
      }
      if (appPackImageRegistryUri && appPackImageRegistryUri.includes("://")) {
        appPackImageRegistryUri = appPackImageRegistryUri.split("://")[1];
      }

      let appPackRelativeUri = `${imageCode}-${appPackCode}:${imageVersion}`.toLowerCase();
      let dockerImage = `${appPackImageRegistryUri ? `${appPackImageRegistryUri}/` : "" }${appPackRelativeUri}`;
      appPackData.uri = useAbsoluteUri ? `docker://${dockerImage}` : appPackRelativeUri;
      try {
        // Ensure that the resulting image is built for the correct architecture
        // even on devices with a different architecture than the one used by uuCloudg02.
        let buildCommand = Os.arch() === "x64" ? "build" : "buildx build --platform linux/amd64";
        let hostnameMapping = containerRuntime.includes("podman") || compatModeEnabled ? undefined : "--add-host=host.docker.internal:host-gateway";
        let args = [...containerRuntime.split(" "), ...buildCommand.split(" "), hostnameMapping, "-f", dockerfile, "-t", dockerImage, "--pull", "--force-rm", "." ];
        args = args.filter(arg => arg); // remove emtpy args
        let command = args.shift();
        let process = ChildProcess.spawn(command, args, {cwd: buildDir, stdio: 'inherit' });
        await new Promise((resolve, reject) => {
          process.on("exit", (code) => code ? reject(code) : resolve());
          process.on("error", reject);
        });
      } catch (e) {
        if (!env.isInProjectScope()) {
          try {
            Fs.rmSync(buildDir, { recursive: true });
          } catch (ei) {
            // Nothing to do here
          }
        }
        throw new ChildProcessError("Building docker image failed.", e.message);
      }

      if (!publishAppbox) {
        continue;
      }

      console.log(`\nPublishing image for ${appPackCode}...\n`);

      // TODO Will be needed for uploading image via uuCloud API
      // let exportedImage = `${imageCode}-${appPackCode.toLocaleLowerCase()}-${imageVersion}.tar`;
      // try {
      //   ChildProcess.execSync(`${containerRuntime} save -o ${exportedImage} ${dockerImage}`, {cwd: buildDir, stdio: 'inherit' });
      // } catch (e) {
      //   if (!env.isInProjectScope()) {
      //     try {
      //       Fs.rmSync(buildDir, { recursive: true });
      //     } catch (ei) {
      //       // Nothing to do here
      //     }
      //   }
      //   throw new ChildProcessError("Exporting of docker image failed.", e.message);
      // }
      // TODO Upload image via uuAppBoxRegistry

      // TODO Temporary solution publishing image directly via registry
      try {
        ChildProcess.execSync(`${containerRuntime} push ${dockerImage}`, {cwd: buildDir, stdio: 'inherit' });
      } catch (e) {
        if (!env.isInProjectScope()) {
          try {
            Fs.rmSync(buildDir, { recursive: true });
          } catch (ei) {
            // Nothing to do here
          }
        }
        throw new ChildProcessError("Publishing of docker image failed.", e.message);
      }
      // TODO "RepoDigest" checksum cannot be obtained before image is pushed to repository.
      //   Which checksum should be added to appbox? It will not be availabe if image will be
      //   uploaded via appbox registry.
      try {
        let imageInfo = JSON.parse(ChildProcess.execSync(`${containerRuntime} inspect ${dockerImage}`).toString());
        appPackData.checksum = imageInfo[0].RepoDigests[0].split("sha256:")[1];
      } catch (e) {
        console.error(`Unable to get image checkum: ${e.message}`);
      }

    };

  } finally {
    fileServer && fileServer.close();
  }

  if (!env.isInProjectScope()) {
    try {
      Fs.rmSync(buildDir, { recursive: true });
    } catch (ei) {
      // Nothing to do here
    }
  }

  descriptor.uuAppBoxDescriptor.version = imageVersion;

  let appBoxJsonPath = env.getArgumentValue("uuAppBoxJsonOut");
  if (!appBoxJsonPath && env.isInProjectScope()) {
    appBoxJsonPath = Path.join(env.getWorkdir(), "target", `${env.getPackageConfig().name}-${descriptor.uuAppBoxDescriptor.version}-appbox.json`);
  }
  if (appBoxJsonPath) {
    Fs.mkdirSync(Path.dirname(appBoxJsonPath), { recursive: true });
    Fs.writeFileSync(appBoxJsonPath, JSON.stringify(descriptor.uuAppBoxDescriptor, null, 2));
  }

  let appBoxUri;
  if (publishAppbox) {
    console.log(`\nPublishing uuAppBox (descriptor)...\n`);
    appBoxUri = await appBoxClient.create(descriptor.uuAppBoxDescriptor);
  }

  // Update does nothing if uuapp.json is not found. Avoiding check of nodejs
  // project scope will help integration into java project (so that appBoxUri
  // need not to be providet via external parameter for deploy).
  //if (env.isInProjectScope()) {
    env.updateProjectDevkitConfig("uuAppBoxUri", appBoxUri);
  //}

  console.log(`\nUuAppBox successfully created${appBoxUri ? `: ${appBoxUri}` : appBoxJsonPath ? `: file://${appBoxJsonPath}` : "."}\n`);
};
