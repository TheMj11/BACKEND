"use strict";

const Fs = require("fs");
const Path = require("path");
const Process = require("process");
const ChildProcess = require("child_process");
const DescriptorConverter = require("./utils/descriptor-converter.js");

class Environment {

  constructor(environment, ...args) {
    this._environment = environment;
    this._args = args.join(" ");
    this._workdir = Process.env["INIT_CWD"] || Process.cwd();
    this.reload();
  }

  reload() {
    this._uuAppJsonPath = this._setUuAppJsonPath();
    this._packageConfig = this._loadPackageConfig(this._environment);
    const uuAppJson = Fs.existsSync(this._uuAppJsonPath)
      ? JSON.parse(Fs.readFileSync(this._uuAppJsonPath, "utf-8"))
      : {};
    this._devkitConfig = uuAppJson ? this._loadDevkitConfig(uuAppJson, this._environment) : {};
    this._projectConfig = uuAppJson ? this._loadProjectConfig(uuAppJson) : {};
    this._cloudg02Descriptor = this._loadCloudg02Descriptor(this._environment);
    this._cloudg01Descriptor = this._loadCloudg01Descriptor(this._environment);
  }

  getProjectVersion() {
    let descriptorVersion = this.getCloudg02Descriptor()?.uuAppBoxDescriptor?.version;
    if (descriptorVersion && descriptorVersion !== "${projectVersion}") {
      return descriptorVersion;
    } else {
      return this.getProjectConfig()?.version || this.getPackageConfig()?.version;
    }
  }

  getWorkdir() {
    return this._workdir;
  }

  getArgumentValue(name) {
    let argMatch = this._args.match(`--${name}([\\s=]([^\\s]*))?`);
    if (!argMatch) {
      return undefined;
    }
    let value = argMatch[2];
    if (!value || value.startsWith("--")) {
      return null;
    }
    return value;
  }

  getPackageConfig() {
    return this._packageConfig;
  }

  getDevkitConfig() {
    return this._devkitConfig;
  }

  getProjectConfig() {
    return this._projectConfig;
  }

  getCloudg02Descriptor() {
    return this._cloudg02Descriptor;
  }

  getCloudg01Descriptor() {
    return this._cloudg01Descriptor;
  }

  isInProjectScope() {
    let packageJsonPath = Path.join(this.getWorkdir(), "package.json");
    return Fs.existsSync(packageJsonPath);
  }

  updateProjectDevkitConfig(key, value) {
    if (Fs.existsSync(this._uuAppJsonPath)) {
      let uuappJson = JSON.parse(Fs.readFileSync(this._uuAppJsonPath));
      let projectDir = Path.basename(this.getWorkdir());
      let projectConfig = uuappJson;
      if (!this._isWorkspaceRoot()) {
        projectConfig = uuappJson[projectDir];
        if (!projectConfig) {
          projectConfig = {};
          uuappJson[projectDir] = projectConfig;
        }
      }
      let devkitConfig = projectConfig.devkit;
      if (!devkitConfig) {
        devkitConfig = {};
        projectConfig.devkit = devkitConfig;
      }
      let environmentConfig = devkitConfig[this._environment];
      if (!environmentConfig) {
        environmentConfig = {};
        devkitConfig[this._environment] = environmentConfig;
      }
      environmentConfig[key] = value;
      Fs.writeFileSync(this._uuAppJsonPath, JSON.stringify(uuappJson, null, 2));
    }
  }

  _setUuAppJsonPath() {
    // check root first
    let productConfigPath = Path.join(this.getWorkdir(), "uuapp.json");

    if (!Fs.existsSync(productConfigPath)) {
      productConfigPath = Path.join(this.getWorkdir(), "..", "uuapp.json");
    }

    return productConfigPath;
  }

  _loadPackageConfig(environment) {
    let packageJsonPath = Path.join(this.getWorkdir(), "package.json");
    if (!Fs.existsSync(packageJsonPath)) {
      return {};
    }
    return JSON.parse(Fs.readFileSync(packageJsonPath));
  }

  _loadDevkitConfig(productConfig, environment) {
    let globalConfig = productConfig.devkit?.[environment];
    let projectConfig = !this._isWorkspaceRoot()
      ? productConfig[Path.basename(this.getWorkdir())]?.devkit?.[environment]
      : undefined;
    return { ...globalConfig, ...projectConfig };
  }

  _loadProjectConfig(productConfig) {
    let { devkit: _, ...projectGlobalConfig } = productConfig;
    let { devkit: __, ...projectConfig } =
      (!this._isWorkspaceRoot() && productConfig[Path.basename(this.getWorkdir())]) || {};
    return { ...projectGlobalConfig, ...projectConfig };
  }

  _loadCloudg02Descriptor(environment) {
    let descriptorPath = this.getArgumentValue("uuSubAppInstanceDescriptor");
    if (!descriptorPath) {
      descriptorPath = Path.join(this.getWorkdir(), "env", `uucloudg02-${environment}.json`);
      if (!Fs.existsSync(descriptorPath)) {
        descriptorPath = Path.join(this.getWorkdir(), "env", `uucloud-${environment}.json`);
      }
    }
    if (!Fs.existsSync(descriptorPath)) {
      return {};
    }
    let descriptor = JSON.parse(Fs.readFileSync(descriptorPath));
    if (descriptor.schemaVersion && descriptor.schemaVersion.startsWith("1.")) {
      descriptor = DescriptorConverter.convert(descriptor);
    }
    return descriptor;
  }

  _loadCloudg01Descriptor(environment) {
    let descriptorPath = Path.join(this.getWorkdir(), "env", `uucloud-${environment}.json`);
    if (!Fs.existsSync(descriptorPath)) {
      return {};
    }
    return JSON.parse(Fs.readFileSync(descriptorPath));
  }

  _isWorkspaceRoot() {
    return (
      this.getWorkdir() === Path.dirname(this._uuAppJsonPath) &&
      Fs.existsSync(Path.join(this.getWorkdir(), "package.json"))
    );
  }

  getContainerRuntime() {
    let uuAppPackBuildTool = this.getArgumentValue("uuAppPackBuildTool");
    if (uuAppPackBuildTool) {
      const supportedUuAppPackBuildTool = ["docker", "podman"];
      if (!supportedUuAppPackBuildTool.includes(uuAppPackBuildTool)) {
        console.warn(
          `\nRequired uuAppPackBuildTool '${uuAppPackBuildTool}' is not supported, the default will be used.\nSupported build tools: ${supportedUuAppPackBuildTool}\n`,
        );
        uuAppPackBuildTool = null;
      }
    }

    let containerRuntime;
    // Windows without wsl are using same syntax as other platforms
    if (uuAppPackBuildTool) {
      try {
        ChildProcess.execSync(`${uuAppPackBuildTool} --version`, { stdio: "ignore" });
        containerRuntime = uuAppPackBuildTool;
      } catch (_) {}
    } else {
      try {
        ChildProcess.execSync("docker --version", { stdio: "ignore" });
        containerRuntime = "docker";
      } catch (_) {
        try {
          ChildProcess.execSync("podman --version", { stdio: "ignore" });
          containerRuntime = "podman";
        } catch (_) {}
      }
    }
    if (!containerRuntime && Process.platform === "win32") {
      // On windows, try also wsl installation
      if (uuAppPackBuildTool) {
        try {
          ChildProcess.execSync(`wsl ${uuAppPackBuildTool} --version`, { stdio: "ignore" });
          containerRuntime = `wsl ${uuAppPackBuildTool}`;
        } catch (_) {}
      } else {
        try {
          ChildProcess.execSync("wsl docker --version", { stdio: "ignore" });
          containerRuntime = "wsl docker";
        } catch (_) {
          try {
            ChildProcess.execSync("wsl podman --version", { stdio: "ignore" });
            containerRuntime = "wsl podman";
          } catch (_) {}
        }
      }
    }
    if (containerRuntime && containerRuntime.includes("podman")) {
      // https://blog.nashcom.de/nashcomblog.nsf/dx/podman-3.x-health-script-issues-with-oci-image-manifest-format.htm
      Process.env["BUILDAH_FORMAT"] = "docker";
    }
    return containerRuntime;
  }

}

Environment.REQUIRED_VALUE_PLACEHOLDER = "----- VALUE REQUIRED -----";

module.exports = Environment;
