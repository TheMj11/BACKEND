"use strict";

class Help {

  static print(description, parameters, options = {}) {
    console.log("");
    this._print(description, 0, options.maxLength);
    console.log("");
    if (!parameters || parameters.length === 0) {
      return;
    }
    let maxParamLength = 0;
    parameters.forEach(([paramName, paramDesc]) => {
      if (paramName && paramName.length > maxParamLength) {
        maxParamLength = paramName.length;
      }
    });
    let paramOffset = options.paramOffset || 2;
    let paramPrefix = options.paramPrefix || "";
    let newLineOffset = paramOffset + paramPrefix.length + maxParamLength + 3;
    parameters.forEach(([paramName, paramDesc]) => {
      if (!paramName) {
        console.log("");
        return;
      }
      let message = "".padStart(paramOffset, " ") + paramPrefix + paramName;
      message = message.padEnd(newLineOffset, " ");
      message += paramDesc;
      this._print(message, newLineOffset, options.maxLength);
    });
    console.log("");
  }

  static _print(message, newLineOffset = 0, maxLength = 96) {
    if (!newLineOffset) {
      newLineOffset = 0;
    }
    if (!maxLength) {
      maxLength = 96;
    }
    let padding = message.match(/^(\s+)/);
    let tokens = message.split(" ");
    let line = `${padding ? padding[1] : ""}`;
    tokens.forEach((token) => {
      line += `${!line || !line.trim() ? "" : " "}${token}`;
      if (line.length > maxLength) {
        console.log(line);
        line = "".padStart(newLineOffset, " ");
      }
    });
    if (line.length > newLineOffset) {
      console.log(line);
    }
  }

}

module.exports=Help;
