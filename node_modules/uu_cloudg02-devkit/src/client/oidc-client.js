"use strict";

const Crypto = require("crypto");
const Fs = require("fs");
const Path = require("path");
const Http = require("http");
const Process = require("process");
const ChildProcess = require("child_process");
const UuAppClient = require("./uu-app-client.js");
const DevkitBaseError = require("../errors/devkit-base-error.js");

const DEFAULT_PROVIDER_URI = "https://uuidentity.plus4u.net/uu-oidc-maing02/bb977a99f4cc4c37a2afce3fd599d0a7/oidc";
const DEFAULT_CLIENT_ID = "00000000000000000000000000000000";
const DEFAULT_CLIENT_SECRET = "foo";

class OidcClient  {

  constructor(environment, opts = {}) {
    let verifySsl = (opts && opts.verifySsl !== undefined) ? opts.verifySsl : (environment.getArgumentValue("verifySsl") !== "false");
    this._providerUri = (opts && opts.identityProviderUri) || environment.getArgumentValue("identityProviderUri") || environment.getDevkitConfig()["identityProviderUri"] || DEFAULT_PROVIDER_URI;
    this._credentialsFile = (opts && opts.credentialsFile) || environment.getArgumentValue("credentialsFile") || environment.getDevkitConfig()["credentialsFile"];
    this._tokenCacheFile = Path.join(Process.env.HOME, ".uu", "devkit-tokens");
    this._appClient = new UuAppClient({baseUri: this._providerUri, verifySsl});
  }

  async getToken(scope) {
    let tokenCache = this._loadTokenCache();
    let cacheKey = this._getTokenCacheKey(scope);
    let cachedToken = tokenCache[cacheKey];
    if (!cachedToken || cachedToken.expiresAt < Date.now()) {
      let grantedToken = await this._grantToken(scope);
      tokenCache = this._loadTokenCache();
      tokenCache[cacheKey] = grantedToken;
      this._storeTokenCache(tokenCache);
      return grantedToken.token;
    } else {
      return cachedToken.token;
    }
  }

  _loadTokenCache() {
    if (!this._tokenCacheFile || !Fs.existsSync(this._tokenCacheFile)) {
      return {};
    }
    return JSON.parse(Fs.readFileSync(this._tokenCacheFile));
  }

  _storeTokenCache(tokenCache) {
    if (!this._tokenCacheFile) {
      return;
    }
    if (!Fs.existsSync(this._tokenCacheFile)) {
      let tokenCacheDir = Path.dirname(this._tokenCacheFile);
      if (!Fs.existsSync(tokenCacheDir)) {
        Fs.mkdirSync(tokenCacheDir);
      }
    }
    Fs.writeFileSync(this._tokenCacheFile, JSON.stringify(tokenCache, null, 2));
  }

  _getTokenCacheKey(scope) {
    let hash = Crypto.createHash("sha1");
    hash.update(`${this._baseUri}|${scope}`);
    return hash.digest("hex");
  }

  async _getMetadata() {
    if (!this._metadata) {
      this._metadata = await this._appClient.get(".well-known/openid-configuration");
    }
    return this._metadata;
  }

  _getCredentials() {
    if (!this._credentialsFile || !Fs.existsSync(this._credentialsFile)) {
      return {};
    }
    let credentials = Fs.readFileSync(this._credentialsFile).toString();
    let usernameMatch = credentials.match(/"?(?:username|accessCode1)"?\s*(?::|=)\s*"?([^"\s]+)/);
    let username = usernameMatch ? usernameMatch[1] : undefined;
    let passwordMatch = credentials.match(/"?(?:password|accessCode2)"?\s*(?::|=)\s*"?([^"\s]+)/);
    let password = passwordMatch ? passwordMatch[1] : undefined;
    return {username, password};
  }

  _getClientCredentials() {
    if (!this._credentialsFile || !Fs.existsSync(this._credentialsFile)) {
      return {};
    }
    let clientCredentials = Fs.readFileSync(this._credentialsFile).toString();
    let clientIdMatch = clientCredentials.match(/"?(?:clientId|client_id)"?\s*(?::|=)\s*"?([^"\s]+)/);
    let client_id = clientIdMatch ? clientIdMatch[1] : undefined;
    let clientSecretMatch = clientCredentials.match(/"?(?:clientSecret|client_secret)"?\s*(?::|=)\s*"?([^"\s]+)/);
    let client_secret = clientSecretMatch ? clientSecretMatch[1] : undefined;
    return {client_id, client_secret};
  }

  async _grantToken(scope) {
    let grantResult;
    let {username, password} = this._getCredentials();
    if (username && password) {
      let grantTokenUrl = (await this._getMetadata())["token_endpoint"];
      let {client_id, client_secret} = this._getClientCredentials();
      scope = `openid${scope ? ` ${scope}` : ""}`;
      let body = {grant_type: "password", username, password, client_id, client_secret, scope};
      grantResult = await this._appClient.post(grantTokenUrl, body);
    } else {
      grantResult = await this._grantTokenInteractive(scope);
    }
    let token = grantResult.id_token;
    let expiresAt = Date.now() + Math.round(grantResult.expires_in * 1000 * 0.8);
    return {token, expiresAt};
  }

  async _grantTokenInteractive(scope) {
    let metadata = await this._getMetadata();
    let {client_id, client_secret} = this._getClientCredentials();
    client_id ||= DEFAULT_CLIENT_ID;
    client_secret ||= DEFAULT_CLIENT_SECRET;
    return await new Promise((resolve, reject) => {
      // Start local server to handle auth callback
      let server = Http.createServer((req, res) => {
        let query = new URL(req.url, "http://localhost").searchParams;
        let code = query.get("code");
        if (code) {
          scope = `openid${scope ? ` ${scope}` : ""}`;
          let redirect_uri = `http://localhost:${server.address().port}`;
          let body = {grant_type: "authorization_code", code, client_id, client_secret, scope, redirect_uri};
          this._appClient.post(metadata["token_endpoint"], body).then((grantResult) => {
            resolve(grantResult);
            let content = Fs.readFileSync(Path.join(__dirname, "oidc-client-success.html"));
            res.writeHead(200, {"Content-Type": "text/html"});
            res.write(content);
            res.end(() => {
              // Close server after response is handled
              this._closeServer(server);
            });
          }).catch((error) => {
            reject(new DevkitBaseError("Interactive login failed, token not received from OIDC server.", null, error));
            let content = Fs.readFileSync(Path.join(__dirname, "oidc-client-error.html"));
            content = content.toString().replace("<%error%>", error);
            res.writeHead(500, {"Content-Type": "text/html"});
            res.write(content);
            res.end(() => {
              // Close server after response is handled
              this._closeServer(server);
            });
          });
        } else {
          let error = query.get("uuAppErrorMap") || query.get("error_description") || query.get("error");
          reject(new DevkitBaseError("Interactive login failed, token not received from OIDC server.", null, error));
          let content = Fs.readFileSync(Path.join(__dirname, "oidc-client-error.html"));
          content = content.toString().replace("<%error%>", error);
          res.writeHead(500, {"Content-Type": "text/html"});
          res.write(content);
          res.end(() => {
            // Close server after response is handled
            this._closeServer(server);
          });
        }
      });
      server.on("connection", (socket) => server.clientSocket = socket);
      server.listen(0);
      // Open browser to initialize auth process
      let authzUri = metadata["authorization_endpoint"];
      authzUri += `?client_id=${encodeURIComponent(client_id || DEFAULT_CLIENT_ID)}`;
      authzUri += `&redirect_uri=${encodeURIComponent(`http://localhost:${server.address().port}`)}`;
      authzUri += `&response_type=code`;
      authzUri += `&acr_values=${encodeURIComponent("standard high veryHigh")}`;
      authzUri += `&scope=${encodeURIComponent(`openid${scope ? ` ${scope}` : ""}`)}`;
      let { platform } = Process;
      let cmd;
      let args;
      switch (platform) {
        case "android":
        case "linux":
          cmd = "xdg-open";
          args = [authzUri];
          break;
        case "darwin":
          cmd = "open";
          args = [authzUri];
          break;
        case "win32":
          cmd = "cmd";
          args = ["/c", "start", authzUri.replace(/&/g, "^&")];
          break;
        default:
          reject(new DevkitBaseError(`Interactive login failed, platform [${platform}] isn't supported.`));
          this._closeServer(server);
      }
      let opts = {stdio: "ignore", detached: true};
      let process = ChildProcess.spawn(cmd, args, opts);
      process.on("exit", (exitCode) => {
        if (exitCode) { // code = 0 ~ false
          reject(new DevkitBaseError(`Interactive login failed, opening browser failed with exit code ${exitCode}).`, {exitCode}));
          this._closeServer(server);
        }
      });
      process.on("error", (error) => {
        reject(new DevkitBaseError(`Interactive login failed, opening browser failed.`, {}, error));
        this._closeServer(server);
      });
    });
  }

  _closeServer(server) {
    try {
      server.close();
    } catch (e) {
      // ignore error
    }
    if (server.clientSocket) {
      try {
        server.clientSocket.destroy();
      } catch (e) {
        // ignore error
      }
    }
  }

}

module.exports = OidcClient;
