"use strict";

const Https = require("https");
const Http = require("http");
const Path = require("path");
const { PassThrough, Readable } = require("stream");
const UuAppClientError = require("../errors/uu-app-client-error.js");

const COMMON_HEADERS = {
  "User-Agent": "uuCloudg02Devkit"
};

const GET_HEADERS = {
  ...COMMON_HEADERS,
  "Accept": "application/json"
};

const POST_HEADERS = {
  ...COMMON_HEADERS,
  "Accept": "application/json",
  "Content-type": "application/json",
};

const UPLOAD_HEADERS = {
  ...COMMON_HEADERS,
  "Accept": "application/json"
};

const DOWNLOAD_HEADERS = {
  ...COMMON_HEADERS,
};

class UuAppClient {

  constructor(opts = {}) {
    this._baseUri = (opts && opts.baseUri && opts.baseUri.replace(/\/$/, "")) || "UNDEFINED";
    this._entity = opts && opts.entity;
    this._oidcClient = opts && opts.oidcClient;
    this._verifySsl = (opts && opts.verifySsl !== undefined) ? opts.verifySsl : true;
  }

  async get(useCase, dtoIn = null) {
    let commandUrl = this.getCommandUrl(useCase, dtoIn);
    let requestOpts = {method: "GET", headers: {...GET_HEADERS}};
    let responseBody = await this._callCommand(commandUrl, requestOpts, null);
    return this._getDtoOut(responseBody);
  }

  async post(useCase, dtoIn = null) {
    let commandUrl = this.getCommandUrl(useCase);
    let requestOpts = {method: "POST", headers: {...POST_HEADERS}};
    let requestBody = dtoIn ? JSON.stringify(dtoIn) : null;
    let responseBody = await this._callCommand(commandUrl, requestOpts, requestBody);
    return this._getDtoOut(responseBody);
  }

  async download(useCase, dtoIn = null) {
    let commandUrl = this.getCommandUrl(useCase, dtoIn);
    let requestOpts = {method: "GET", headers: {...DOWNLOAD_HEADERS}};
    return this._callCommand(commandUrl, requestOpts, null);
  }

  async upload(useCase, dtoIn = null) {
    let commandUrl = this.getCommandUrl(useCase);
    let requestOpts = {method: "POST", headers: {...UPLOAD_HEADERS}};
    let [contentType, requestBody] = dtoIn ? this._getFormData(dtoIn) : [];
    if (contentType) {
      requestOpts.headers["Content-Type"] = contentType;
    }
    let responseBody = await this._callCommand(commandUrl, requestOpts, requestBody);
    return this._getDtoOut(responseBody);
  }

  getCommandUrl(useCase, dtoIn = null) {
    let commandUrl;
    if (!useCase) {
      commandUrl = `${this._baseUri}${this._entity ? "/" + this._entity : ""}`;
    } else if (useCase.match("^https?://")) {
      commandUrl = useCase;
    } else {
      commandUrl = `${this._baseUri}/${this._entity ? this._entity + "/" : ""}${useCase}`;
    }
    if (dtoIn) {
      let query = "";
      for (let [name, value] of Object.entries(dtoIn)) {
        if (value instanceof Date) {
          value = value.toISOString();
        } else if (typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean") {
          value = JSON.stringify(value);
        }
        query += `${query ? "&" : "?"}${name}=${encodeURIComponent(value)}`;
      };
      commandUrl += query;
    }
    return commandUrl;
  }

  _getFormData(dtoIn) {
    let boundary = `${Math.floor(Math.random() * 1e16)}`.padEnd(16, "0");
    let itemDelimiter = `--${boundary}\r\n`;
    let requestEnd = `--${boundary}--`;

    let chunks = [];
    for (let [name, value] of Object.entries(dtoIn)) {
      let contentDisposition = `Content-Disposition: form-data; name="${name}"`;
      let contentType = null;
      if (typeof value === "string") {
        value = Readable.from(value);
      } else if (typeof value === "number" || typeof value === "boolean") {
        value = Readable.from(`${value}`);
      } else if (value instanceof Date) {
        value = Readable.from(value.toISOString());
      } else if (!(value instanceof Readable)) {
        contentType = "Content-Type: application/json";
        value = Readable.from(JSON.stringify(value));
      } else {
        contentType = `Content-Type: ${value.contentType || value.type || "application/octet-stream"}`;
        contentDisposition += `; filename="${Path.basename(value.filename || value.path || value.name || name)}"`;
      }
      chunks.push(Readable.from(itemDelimiter));
      chunks.push(Readable.from([contentDisposition, "\r\n"]));
      if (contentType) {
        chunks.push(Readable.from([contentType, "\r\n"]));
      }
      chunks.push(Readable.from("\r\n"));
      chunks.push(value);
      chunks.push(Readable.from("\r\n"));
    };

    let requestBody = new PassThrough();
    let pipeNext = () => {
      let next = chunks.shift();
      if (next) {
        next.pipe(requestBody, {end: false});
        next.once("end", () => pipeNext());
      } else {
        Readable.from(requestEnd).pipe(requestBody);
      }
    };
    pipeNext();

    return [`multipart/form-data; boundary=${boundary}`, requestBody];
  }

  async _callCommand(commandUrl, options, requestBody = null) {
    if (this._oidcClient) {
      let scope = commandUrl.startsWith(this._baseUri) ? this._baseUri : commandUrl.split("?")[0];
      let token = await this._oidcClient.getToken(scope);
      options.headers["Authorization"] = `Bearer ${token}`;
    }
    if (this._verifySsl === false) {
      options.rejectUnauthorized = false;
    }
    let protocol = commandUrl.startsWith("https") ? Https : Http;
    return new Promise((resolve, reject) => {
      let request = protocol.request(commandUrl, options, (response) => {
        if (response.statusCode >= 300) {
          this._readBody(response).then(
            (responseBody) => {
              reject(new UuAppClientError("Command call failed.", response.statusCode, responseBody));
            },
            (error) => {
              reject(error);
            }
          );
        } else {
          let contentType = response.headers["content-type"];
          let contentDisposition = response.headers["content-disposition"] || "";
          let filename = contentDisposition.match(/filename\s*=\s*"?([^";]+)/);
          let responseBody = new PassThrough();
          responseBody.contentType = contentType;
          responseBody.filename = filename && filename[1];
          response.pipe(responseBody);
          resolve(responseBody);
        }
      });
      request.on("error", (e) => {
        reject(e);
      });
      if (requestBody instanceof Readable) {
        requestBody.pipe(request);
      } else if (requestBody) {
        request.write(requestBody);
        request.end();
      } else {
        request.end();
      }
    });
  }

  async _readBody(body) {
    return new Promise((resolve, reject) => {
      let buffer = "";
      body.on("error", (e) => {
        reject(e)
      })
      body.on("data", (chunk) => {
        buffer += chunk;
      });
      body.on("end", () => {
        resolve(buffer);
      });
    });
  }

  async _getDtoOut(responseBody) {
    let dtoOutJson = await this._readBody(responseBody);
    return dtoOutJson ? JSON.parse(dtoOutJson) : null;
  }

}

module.exports = UuAppClient;
