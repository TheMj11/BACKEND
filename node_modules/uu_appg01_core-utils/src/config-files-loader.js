"use strict";

const Fs = require("fs");
const BaseError = require("./base-error.js");
const Config = require("./config/config.js");
const Finder = require("./finder.js");
const Json = require("./json.js");

const CONFIG_FOLDER_PATTERN = "{src,app}/config";
const CONFIG_TEMPLATE_REGEXP = /(?:\\?")?(\${([^}]+(:[^}]+)?)})(?:\\?")?/g;
const CONFIG_EXPRESSION_REGEXP = /(?:\\?")?(#{([^}]+)})(?:\\?")?/g;

/**
 * Component for loading and merging of configuration files.
 */
class ConfigFilesLoader {

  /**
   * @callback partialConfigHandler
   * @param {object} config Loaded partial configuration (may be modified)
   * @param {string} configFilePath Path to corresponding configuration file
   * @returns {void}
   * @throws Error to interrupt further procession
   */

  /**
   * @callback finalConfigHandler
   * @param {object} config Final merged configuration (may be modified)
   * @param {array} configFilePaths List of all processed configuration files
   * @returns {void}
   * @throws Error to interrupt further procession
   */

  /**
   * Loads and parses configuration files based on given parameters.
   * @param {string} configFilePattern Glob pattern to match configuration files name (e.g. "persistence.json")
   * @param {object} opts Additional loading options:
   * @param {string} opts.projectRoot Directory where to start scanning (defaults to server_root or current working directory)
   * @param {string} opts.configFolderPattern Glob pattern to match folder with configuration (defaults to "{src,app}/config")
   * @param {string} opts.overwritePolicy Strategy for overwriting of concurrent declarations (one of ["projectOnly", "allowed", "forbidden"])
   * @param {string} opts.configurationPrefix Prefix of (deploy) configuration for overriding particular attributes. If not set, override is not done.
   * @param {partialConfigHandler} opts.partialConfigHandler Callback invoked for each parsed configuration file (before it is merged to global).
   * @param {finalConfigHandler} opts.finalConfigHandler Callback invoked for final configuration including all additional configuration overrides.
   */
  static load(configFilePattern, opts = {}) {
    if (!configFilePattern) {
      throw new BaseError("Missing configuration file pattern.");
    }

    let projectRoot = opts.projectRoot || Config.getString("server_root") || process.cwd();
    let configFolderPattern = opts && opts.configFolderPattern || CONFIG_FOLDER_PATTERN;
    let overwritePolicy = opts && opts.overwritePolicy || "projectOnly"; // "forbidden", "allowed"
    let configurationPrefix = opts && opts.configurationPrefix || null;
    let partialConfigHandler = opts && opts.partialConfigHandler || null;
    let finalConfigHandler = opts && opts.finalConfigHandler || null;

    let processedFiles = [];
    let configuration = {};

    // Load configuration from dependencies
    let libConfigFiles = Finder.findInModules(projectRoot, `${configFolderPattern}/${configFilePattern}`);
    for (let libConfigFile of libConfigFiles) {
      let libConfig = this._parseConfigFile(libConfigFile, partialConfigHandler);
      let conflicts = this._mergeConfiguration(configuration, libConfig, overwritePolicy === "allowed" ? true : false);
      if (conflicts.length > 0) {
        throw new BaseError(`Configuration file [${libConfigFile}] contains conflicting keys [${conflicts.join(", ")}] already declared in some of already loaded files [${processedFiles.join(', ')}].`);
      }
      processedFiles.push(libConfigFile);
    }

    // Load configuration from project itself
    let projectConfigFiles = Finder.findInProject(projectRoot, `${configFolderPattern}/${configFilePattern}`);
    if (projectConfigFiles.length === 1) {
      let projectConfig = this._parseConfigFile(projectConfigFiles[0], partialConfigHandler);
      let conflicts = this._mergeConfiguration(configuration, projectConfig, overwritePolicy === "forbidden" ? false : true);
      if (conflicts.length > 0) {
        throw new BaseError(`Configuration file [${projectConfigFiles[0]}] contains conflicting keys [${conflicts.join(", ")}] already declared in some of already loaded files [${processedFiles.join(', ')}].`);
      }
      processedFiles.push(projectConfigFiles[0]);
    }

    // Load configuration config overrides
    if (configurationPrefix) {
      let effectiveConfig = Config.toJSON();
      for (let [loadedKey, loadedValue] of Object.entries(configuration)) {
        let rootConfigKey = `${configurationPrefix}.${loadedKey}`;
        let configPrefix = `${rootConfigKey}.`;
        for (let [configKey, configValue] of Object.entries(effectiveConfig)) {
          if (configKey === rootConfigKey) {
            configuration[loadedKey] = configValue;
            continue;
          }
          if (!configKey.startsWith(configPrefix)) {
            continue;
          }
          let nestedValue = loadedValue;
          let parts = configKey.substring(configPrefix.length).split(".");
          for (let part of parts.slice(0, -1)) {
            if (!nestedValue[part]) {
              nestedValue[part] = {};
            }
            nestedValue = nestedValue[part];
          }
          nestedValue[parts.slice(-1)] = configValue;
        }
      }
    }

    if (finalConfigHandler) {
      finalConfigHandler(configuration, processedFiles);
    }

    return configuration;
  }

  static _parseConfigFile(configFile, partialConfigHandler = null) {
    // Load configuration file content
    let configContent;
    try {
      configContent = Fs.readFileSync(configFile).toString();
    } catch (e) {
      throw new BaseError(`Loading of configuration file [${configFile}] failed.`, e);
    }

    // Resolve configuration variables in configuration file
    configContent = this._resolveConfigVariables(configContent, configFile);
    // Resolve expressions like #{....}
    configContent = this._resolveExpressions(configContent, configFile);

    // Parse configuration file
    let config;
    try {
      config = Json.parse(configContent);
    } catch (e) {
      throw new BaseError(`Parsing of configuration file [${configFile}] failed.`, e);
    }

    if (partialConfigHandler) {
      partialConfigHandler(config, configFile);
    }

    return config;
  }

  static _resolveConfigVariables(configContent, configFile) {
    let runtimeConfig;
    for (let match of configContent.matchAll(CONFIG_TEMPLATE_REGEXP)) {
      let toReplace = match[0];
      let inlined = !toReplace.startsWith("\"") || !toReplace.endsWith("\"");
      if (inlined) {
        toReplace = match[1];
      }
      let [configKey, defaultValue] = match[2].split(":", 2);
      let value = Config.get(configKey, false);
      if (value === undefined) {
        if (configKey.includes(".")) {
          runtimeConfig ||= Config.toJSON();
          let parentValue = runtimeConfig;
          let parts = configKey.split(".");
          let partialKey = null;
          for (let part of parts) {
            if (!this._isShape(parentValue)) {
              throw new BaseError(`Configuration file [${configFile}] contains invalid configuration key referrence [${configKey}].`);
            }
            partialKey = partialKey ? `${partialKey}.${part}` : part;
            let nestedValue = parentValue[partialKey];
            if (nestedValue !== undefined) {
              parentValue = nestedValue;
              if (this._isShape(parentValue)) {
                partialKey = null;
              } else {
                value = parentValue;
              }
            }
          }
        }
      }
      if (value == null) {
        value = defaultValue;
      }
      if (typeof value === "string") {
        if (value.match(/^[0-9]+(.[0-9]+)?$/)) {
          value = Number(value);
        } else if (!inlined && !value.match(/^(true|false|null)$/)) {
          value = `"${value}"`;
        }
      } else if (value instanceof Date) {
        value = Json.stringify(value);
        if (inlined) {
          value = value.slice(1, -1);
        }
      } else if (value == null) {
        value = "null";
      } else if (typeof value !== "boolean" && typeof value !== "number") {
        throw new BaseError(`Configuration file [${configFile}] contains configuration replacement [${toReplace}] resolving to unsupported value.`);
      }
      configContent = configContent.replace(toReplace, value);
    }

    return configContent;
  }

  static _resolveExpressions(configContent, configFile) {
    for (let match of configContent.matchAll(CONFIG_EXPRESSION_REGEXP)) {
      let toReplace = match[0];
      let inlined = !(toReplace.startsWith("\"") && toReplace.endsWith("\""));
      if (inlined) {
        toReplace = match[1];
      }

      let value;
      try {
        let evaluatedExp = match[2];
        value = eval(evaluatedExp);
      } catch(e) {
        throw new BaseError(`Failed to evaluate expression [${toReplace}] in configuration file [${configFile}].`, e);
      }

      if (typeof value === "string") {
        if (value.match(/^[0-9]+(.[0-9]+)?$/)) {
          value = Number(value);
        } else if (!inlined && !value.match(/^(true|false|null)$/)) {
          value = `"#{value}"`;
        }
      } else if (value instanceof Date) {
        value = Json.stringify(value);
        if (inlined) {
          value = value.slice(1, -1);
        }
      } else if (value == null) {
        value = "null";
      } else if (typeof value !== "boolean" && typeof value !== "number") {
        throw new BaseError(`Configuration file [${configFile}] contains expression replacement [${toReplace}] resolving to unsupported value.`);
      }

      configContent = configContent.replace(toReplace, value);
    }
    return configContent;
  }

  static _mergeConfiguration(existingConfig, newConfig, allowOverwrite = true, parentPath = "$") {
    let conflicts = [];
    for (let [key, value] of Object.entries(newConfig)) {
      if (this._isShape(existingConfig[key]) && this._isShape(value)) {
        conflicts.push(...this._mergeConfiguration(existingConfig[key], value, allowOverwrite, parentPath += `.${key}`));
      } else if (!allowOverwrite && existingConfig[key] !== undefined) {
        conflicts.push(`${parentPath}.${key}`);
      } else {
        existingConfig[key] = value;
      }
    }
    return conflicts;
  }

  static _isShape(object) {
    return object != null &&
           !(["string", "number", "boolean"].includes(typeof object)) &&
           !(object instanceof Date) && !(Array.isArray(object));
  }

}

module.exports = ConfigFilesLoader;
