"use strict";

const BaseError = require("./base-error.js");
const Json = require("./json.js");

let localStorageAvailable;
try {
  let check = localStorage;
  localStorageAvailable = !!check;
} catch (e) {
  localStorageAvailable = false;
}

const SUPPORTED_EVICTION_POLICIES = ["lfu", "lru", "mru", "fifo", "lifo"];

/**
 * Cache item.
 * @private
 */
class Item {

  /**
   * Creates new instance of cache item.
   * @param key Item name
   * @param value Item value
   * @param exp Item expiration
   * @param hits Item hits
   */
  constructor(key, value, exp, hits) {
    this.key = key;
    this.value = value;
    this.exp = exp;
    this.hits = hits || 0;
    this.next = null;
    this.prev = null;
  }

  /**
   * Checks if item is expired.
   * @returns {boolean} True if item is expired
   */
  isExpired() {
    return this.exp > -1 && this.exp <= Date.now();
  }

  /**
   * Returns object representation of cache item.
   * @returns {*[]} Array containing key, value end expiration (in this order)
   */
  toJSON() {
    return [this.key, this.value, this.exp, this.hits];
  }

}

const NEXT_WRITE_DELAY = 5000; // in milliseconds

/**
 * Browser friendly implementation of cache with support of persisting cache
 * to browser local storage, supporting multiple cache replacement policies
 */
class Cache {

  /**
   * Creates new instance of cache.
   * @param {Object|null} opts Cache options
   * @param {String} opts.evictionPolicy Cache eviction policy (one of ["lfu", "lru", "mru", "fifo", "lifo"]; defaults to "lru")
   * @param {function} opts.evictionCallback Callback invoked when item is evicted either due to being expired or cache exceeding max size.
   * @param {number} opts.maxSize Maximal number of items to be stored
   * @param {number} opts.maxAge How long (in milliseconds) should items be stored
   * @param {number} opts.pruneInterval How often (in milliseconds) are expired items pruned. If not set, they are pruned only lazily when touched.
   * @param {String} opts.localStorageKey If set, cache will be persisted to browser
   *   local storage. Local storage key should contain product identification to
   *   avoid conflicting names between various components.
   * @param {number} opts.nextWriteDelay This parameter specifies delay (in milliseconds) of storing cache content into browser localStorage. 
   * Writing to localStorage too often can cause Chrome to run out of memory - this parameter is introduced to prevent this issue.
   */
  constructor(opts = {}) {
    let evictionPolicy = opts.evictionPolicy || "lru";
    if (!SUPPORTED_EVICTION_POLICIES.includes(evictionPolicy)) {
      throw new BaseError(`Unsupported cache eviction policy [${evictionPolicy}] (supported policies [${SUPPORTED_EVICTION_POLICIES.join(", ")}]).`);
    }
    this._name = opts.localStorageKey;
    this._items = new Map();
    this._hitCount = 0;
    this._missCount = 0;
    this._first = null;
    this._last = null;
    this._nextWrite = 0;
    this._nextWriteDelay = opts.nextWriteDelay || NEXT_WRITE_DELAY;
    this._isContentLoaded = false;
    this._isContentStoreScheduled = false;
    this._loadFromStorage();
    this._evictionCallback = opts.evictionCallback;
    this._evictionPolicy = evictionPolicy;
    if (typeof opts.maxSize === "number") {
      this._maxSize = opts.maxSize;
    } else {
      this._maxSize = -1;
    }
    if (typeof opts.maxAge === "number") {
      this._maxAge = opts.maxAge;
    } else {
      this._maxAge = -1;
    }
    if (typeof opts.pruneInterval === "number") {
      this._pruneInterval = opts.pruneInterval;
    } else {
      this._pruneInterval = -1;
    }
    this._storeToStorage();
    if (this._pruneInterval > 0) {
      setInterval(() => this._prune(0), this._pruneInterval).unref();
    }
  }

  /**
   * Stores value into cache.
   * @param key Key to access cached value
   * @param value Value to be cached
   * @param maxAge How long (in milliseconds) should this value be stored (overrides global maxAge)
   * @returns {*} Value previously stored under this key (or undefined if none)
   */
  set(key, value, maxAge = null) {
    this._loadFromStorage();
    maxAge = typeof maxAge === "number" ? maxAge : this._maxAge;
    if (maxAge === 0 || this._maxSize === 0) {
      // Cache is disabled, do not add anything
      return undefined;
    }
    let origValue = undefined;
    let exp = maxAge > -1 ? maxAge + Date.now() : -1;
    let existingItem = this._items.get(key);
    if (existingItem) {
      // If there is same existing item...
      if (existingItem.isExpired()) {
        // If item is expired, remove it and create new one
        this._remove(existingItem, true);
        this._push(new Item(key, value, exp));
      } else {
        // If item is not expired, overwrite existing
        origValue = existingItem.value;
        existingItem.value = value;
        existingItem.exp = exp;
      }
    } else {
      // It item does not exist and cache is full we have to prune it first
      if (this._maxSize > -1 && this._items.size >= this._maxSize) {
        this._prune(this._items.size - this._maxSize + 1);
      }
      // Push new item to cache
      this._push(new Item(key, value, exp));
    }

    this._storeToStorage();
    // Return original value (if any)
    return origValue;
  }

  /**
   * Check if a key is in the cache, without updating the recent-ness or deleting it for being stale.
   * @param {Check} key Key of cached value
   * @returns {boolean} True if key is in cache, else false
   */
  has(key) {
    this._loadFromStorage();
    let item = this._items.get(key);
    if (!item) {
      return false;
    } else if (item.isExpired()) {
      this._remove(item, true);
      this._storeToStorage();
      return false;
    } else {
      return true;
    }
  }

  /**
   * Returns value from cache.
   * @param key Key of cached value
   * @returns {*} Cached value (or undefined)
   */
  get(key) {
    this._loadFromStorage();
    let item = this._items.get(key);
    let value = undefined;
    if (item) {
      if (item.isExpired()) {
        // It item is expired, just delete it
        this._remove(item, true);
        this._missCount += 1;
      } else {
        value = item.value;
        this._touch(item);
        this._hitCount += 1;
      }
    } else {
      this._missCount += 1;
    }
    this._storeToStorage();
    return value;
  }

  /**
   * Deletes value from cache.
   * @param key Key of cached value
   * @returns {*} Cached value (or undefined)
   */
  delete(key) {
    this._loadFromStorage();
    let value = undefined;
    let item = this._items.get(key);
    if (item) {
      let itemExpired = item.isExpired();
      if (!itemExpired) {
        // In case item is not expired, return value of deleted item
        value = item.value;
      }
      this._remove(item, itemExpired);
      this._storeToStorage();
    }
    return value;
  }

  /**
   * Clears cache.
   * @param includingStats Flag whether to reset also statistics
   */
  clear(includingStats = false) {
    this._clearInMemoryData(includingStats);
    this._storeToStorage();
  }
  
  _clearInMemoryData(includingStats = false) {
    this._items.clear();
    if (includingStats) {
      this._hitCount = 0;
      this._missCount = 0;
    }
    this._first = null;
    this._last = null;
  }

  /**
   * Returns actual cache size.
   * @returns {number}
   */
  getSize() {
    return this._items.size;
  }

  /**
   * Returns cache hit count.
   * @returns {number}
   */
  getHitCount() {
    return this._hitCount;
  }

  /**
   * Returns cache miss count.
   * @returns {number}
   */
  getMissCount() {
    return this._missCount;
  }

  /**
   * Returns object representation of cache item.
   * @returns {Array} List of cached items
   */
  toJSON() {
    let items = [];
    let item = this._first;
    while (item) {
      if (!item.isExpired()) {
        items.push(item.toJSON());
      }
      item = item.next;
    }
    return [this._maxSize, this._maxAge, items, this._hitCount, this._missCount];
  }

  /**
   * Initializes cache from serialized value (clears any existing data).
   * @param json Serialized cache
   */
  fromJSON(json) {
    this._clearInMemoryData(true);
    if (typeof json === "string") {
      json = Json.parse(json);
    }
    let [maxSize, maxAge, items, hitCount, missCount] = json;
    this._maxSize = maxSize;
    this._maxAge = maxAge;
    this._hitCount = hitCount || 0;
    this._missCount = missCount || 0;
    for (let [key, value, exp, hits] of items) {
      this._push(new Item(key, value, exp, hits));
    }
  }

  /**
   * Iterates through cached items (from first to last depenging on eviction policy).
   * @param callback Function receiving item key, item value and hit count.
   *    Function may return false to stop the loop.
   */
  forEach(callback) {
    if (typeof callback !== 'function') {
      throw new BaseError(`Parameter must be function`);
    }
    for (let [key, value, hits] of this) {
      let doNext = callback(key, value, hits);
      if (typeof doNext === 'boolean' && !doNext) {
        break;
      }
    }
  }

  /**
   * Cache iterator.
   */
  [Symbol.iterator] = function* () {
    this._loadFromStorage();
    let item = this._first;
    let itemsRemoved = false;
    while (item) {
      if (item.isExpired()) {
        this._remove(item, true);
        itemsRemoved = true;
      } else {
        yield [item.key, item.value, item.hits];
      }
      item = item.next;
    }
    if (itemsRemoved) {
      this._storeToStorage();
    }
  }

  /**
   * Pushes new item to cache.
   * @param item Cached item
   * @private
   */
  _push(item) {
    if (!this._first) {
      // Pushing first item
      item.next = null;
      item.prev = null;
      this._first = item;
      this._last = item;
    } else {
      item.next = null;
      item.prev = this._last;
      this._last.next = item;
      this._last = item;
    }
    // Store the item
    this._items.set(item.key, item);
  }

  /**
   * Increases item hits and updates item position based on eviction policy.
   * @param item Touched item
   * @private
   */
  _touch(item) {
    item.hits += 1;
    // If item is already first do nothing
    if (item.prev) {
      if (["mru", "lru"].includes(this._evictionPolicy)) {
        // Move item to first position
        this._moveItemHigher(item);
      } else if (this._evictionPolicy === "lfu") {
        // Move item to higher position based on "hits"
        // Find "new previous item" as item which has
        // higher number of hits than touched item
        let newPrevItem = item.prev;
        while (newPrevItem && newPrevItem.hits <= item.hits) {
          newPrevItem = newPrevItem.prev;
        }
        if (!newPrevItem) {
          // No item with higher hit count found
          // Move item to first position
          this._moveItemHigher(item);
        } else if (newPrevItem.key !== item.prev.key) {
          // We have found new previous item with higher hit
          // count which is different to current previous item
          // Move item to be next to this found item
          this._moveItemHigher(item, newPrevItem);
        }
      }
    }
  }

  /**
   * Moves item to "higher" position.
   * @param item Item to be moved
   * @param newPrevItem Item which should be higher than moved item (if null, item is moved to be first)
   * @private
   */
  _moveItemHigher(item, newPrevItem = null) {
    // Link previous item with next of moved item
    item.prev.next = item.next;
    if (item.next) {
      // Link next item with prev of moded item
      item.next.prev = item.prev;
    } else {
      // In case we are moving last item, update tail
      this._last = item.prev;
    }
    if (newPrevItem) {
      // New previous item given, move after it
      item.prev = newPrevItem;
      item.next = newPrevItem.next;
      newPrevItem.next.prev = item;
      newPrevItem.next = item;
    } else {
      // No new previous item given, we are moving to first place
      // Set previous first item after moved item
      item.next = this._first;
      item.prev = null;
      if (this._first) {
        this._first.prev = item;
      }
      // Set moved item to first place
      this._first = item;
    }
  }

  /**
   * Removes item from cache.
   * @param item Item to be removed
   * @param invokeCallback Flag if prune callback should be invoked
   * @private
   */
  _remove(item, invokeCallback = false) {
    if (item.prev) {
      // Link previous item with next of deleted item
      item.prev.next = item.next;
    } else {
      // In case we are deleting first item, update head
      this._first = item.next;
    }
    if (item.next) {
      // Link next item with prev of deleted item
      item.next.prev = item.prev;
    } else {
      // In case we are deleting last item, update tail
      this._last = item.prev;
    }
    // Delete the item
    this._items.delete(item.key);
    if (invokeCallback && this._evictionCallback) {
      this._evictionCallback(item.key, item.value, item.hits);
    }
  }

  /**
   * Prune at least specified number of items, first delete
   * expired ones, then delete from last item until given
   * number of items to be deleted is reached.
   * @param atLeast Number of items to be removed
   * @private
   */
  _prune(atLeast = 1) {
    let fromFirst = ["mru", "fifo"].includes(this._evictionPolicy);
    let deleted = 0;
    // Delete all expired items first
    let item = fromFirst ? this._first : this._last;
    while (item) {
      if (item.isExpired()) {
        this._remove(item, true);
        deleted++;
      }
      item = fromFirst ? item.next : item.prev;
    }
    // Delete remaining number of items
    if (deleted < atLeast) {
      let item = fromFirst ? this._first : this._last;
      for (let i = 0; i < (atLeast - deleted); i++) {
        this._remove(item, true);
        item = fromFirst ? item.next : item.prev;
        // Break in case all items are gone
        if (!item) {
          break;
        }
      }
    }
  }

  /**
   * If available, deserializes cache content from browser local storage.
   * @private
   */
  _loadFromStorage() {
    if (localStorageAvailable && this._name && !this._isContentLoaded) {
      let persistedCache = localStorage.getItem(this._name);
      if (persistedCache) {
        this.fromJSON(persistedCache);
      }
      this._isContentLoaded = true;
    }
  }

  /**
   * If available, serilalizes cache content to browser local storage.
   * @private
   */
  _storeToStorage() {
    if (localStorageAvailable && this._name && !this._isContentStoreScheduled) {
      if (!this._nextWrite) { // use microtask for the first time
        queueMicrotask(() => {
          this._saveToLocalStorage(); 
        });
      } else {
        setTimeout(() => {
          this._saveToLocalStorage();
        }, Math.max(this._nextWrite - Date.now(), 0));
      }
      this._isContentStoreScheduled = true;
    }
  }
  
  _saveToLocalStorage() {
    localStorage.setItem(this._name, Json.stringify(this));
    this._isContentStoreScheduled = false;
    this._isContentLoaded = false; // allow to reload cache content
    this._nextWrite = Date.now() + this._nextWriteDelay; // the next write to the localStore will be delayed
  }

}

module.exports = Cache;
