"use strict";

const EVENT_DRAIN = "drain";
const EVENT_SATURATED = "saturated";

/**
 * Component for limiting number of concurrently running async tasks.
 */
class AsyncExecutor extends EventTarget {

  /**
   * Event invoked in case number of currently running tasks is lower than limit.
   */
  static get EVENT_DRAIN() {
    return EVENT_DRAIN;
  }

  /**
   * Event invoked in case limit of concurrently running tasks was reached.
   */
  static get EVENT_SATURATED() {
    return EVENT_SATURATED;
  }

  /**
   * Creates new instance of AsyncExecutor.
   * @param {number} limit Limit of concurrently running tasks (defaults to 1)
   */
  constructor(limit = 1) {
    super();
    this._limit = limit >= 0 ? limit : 1;
    this._waitingTasks = [];
    this._runningTasks = new Map();
  }

  /**
   * Returns current executor limit.
   * @returns Current executor limit
   */
  getLimit() {
    return this._limit;
  }

  /**
   * Sets new executor limit.
   * @param {number} limit New executor limit
   */
  setLimit(limit) {
    if (limit >= 0) {
      let increasing = limit > this._limit;
      this._limit = limit;
      if (increasing) {
        this._runNext();
      }
    }
  }

  /**
   * Returns count of tasks waiting in queue. 
   * @returns Count of tasks waiting in queue
   */
  getWaitingCount() {
    return this._waitingTasks.length;
  }

  /**
   * Returns count of currently running tasks.
   * @returns Count of currently running tasks
   */
  getRunningCount() {
    return this._runningTasks.size;
  }

  /**
   * Submits new task to be executed. Returns promise exdended with "resolve" and "reject" methods
   * allowing to explicitly finish (or fail) task, which also tries to abort the task (tasks which
   * are waiting are cancelled and immediatelly removed, tasks which are already running receives
   * abort signal via abort controller received via task parameter).
   * @param {function} executor Task to be invoked accepting instance of AbortController as parameter
   * @returns Task result promise (with "resolve" and "reject" methods)
   */
  submit(executor) {
    if (typeof executor !== "function") {
      let retVal = executor;
      executor = () => {return retVal};
    }

    let id = [...Array(32)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
    let resolve;
    let reject;
    let promise = new Promise((res, rej) => {resolve = res; reject = rej});
    promise.resolve = (result) => {
      resolve(result);
      return this._abort(id);
    }
    promise.reject = (error) => {
      reject(error);
      return this._abort(id);
    }
    // Append empty handler to prevent unhandled errors
    // in case error on returned promise is not processed
    promise.catch(() => {});

    let abortController = new AbortController();
    this._waitingTasks.push({executor, id, resolve, reject, abortController});
    this._runNext();

    return promise;
  }

  _runNext() {
    while (this.getRunningCount() < this.getLimit() && this.getWaitingCount() > 0) {
      let task = this._waitingTasks.shift();
      this._runningTasks.set(task.id, task);

      this._invoke(task).then(task.resolve).catch(task.reject).finally(() => {
        this._runningTasks.delete(task.id);
        this._runNext()
      });
    }
    if (this.getRunningCount() < this.getLimit()) {
      this.dispatchEvent(new Event(EVENT_DRAIN));
    } else {
      this.dispatchEvent(new Event(EVENT_SATURATED));
    }
  }

  async _invoke(task) {
    return await task.executor(task.abortController);
  }

  _abort(id) {
    let task = this._runningTasks.get(id);
    if (task) {
      // Taks is aready running
      task.abortController.abort();
      return false;
    } else {
      // Task is waiting in queue
      let idx = this._waitingTasks.findIndex(task => task.id === id);
      if (idx >= 0) {
        this._waitingTasks.splice(idx, 1);
      }
      return true;
    }
  }

}

module.exports = AsyncExecutor;
