"use strict";

const { AsyncLocalStorage, AsyncResource } = require("async_hooks");
const GlobalStore = require("./global-store.js");
const BaseError = require("./base-error.js");

/**
 * ThreadLocal alike context store.
 */
class ContextStore {

  /**
   * Creates new context store
   * @param ctxName Context store name.
   * @param fn Function to which should context store be bound.
   * @returns {*} Return value of invoked function.
   */
  static create(ctxName, fn) {
    let asyncLocalStorages = GlobalStore.get("uuAppAsyncLocalStorages");
    let asyncLocalStorage = asyncLocalStorages.get(ctxName);
    if (!asyncLocalStorage) {
      asyncLocalStorage = new AsyncLocalStorage();
      asyncLocalStorages.set(ctxName, asyncLocalStorage);
    } else if (asyncLocalStorage.getStore()) {
      throw new BaseError(`Context "${ctxName}" is already created.`);
    }
    let contextStore = new ContextStore(ctxName);
    let result;
    asyncLocalStorage.run(contextStore, () => {
      result = fn();
    });
    return result;
  }

  /**
   * Returns context store bound to current context.
   * @param ctxName Context store name.
   * @returns {ContextStore|null} Instance of context store or null.
   */
  static get(ctxName) {
    let asyncLocalStorages = GlobalStore.get("uuAppAsyncLocalStorages");
    let asyncLocalStorage = asyncLocalStorages.get(ctxName);
    return asyncLocalStorage ? asyncLocalStorage.getStore() || null : null;
  }

  /**
   * Creates new instance of context store.
   * @private
   */
  constructor(ctxName, parentStore = null) {
    this._ctxName = ctxName;
    this._parentStore = parentStore;
    this._attributes = {};
  }

  /**
   * Stores context attribute.
   * @param key Context attribute name.
   * @param value Context attribute value.
   */
  set(key, value) {
    this._attributes[key] = value;
  }

  /**
   * Returns context attribute.
   * @param key Context attribute name.
   * @returns {*} Context attribute value.
   */
  get(key) {
    if (this._attributes.hasOwnProperty(key)) {
      return this._attributes[key];
    } else if (this._parentStore) {
      return this._parentStore.get(key);
    } else {
      return undefined;
    }
  }

  /**
   * Deletes context attribute.
   * @param key Context attribute name.
   */
  delete(key) {
    delete this._attributes[key];
  }

  /**
   * Binds context store to emitter object. This is necessary to ensure context
   * is visible inside methods invoked by emitter events (like "on data" etc.).
   * @param emitter Emitter object (e.g. stream, socket, etc.)
   */
  bind(emitter) {
    if (!emitter._uuAppContextStoreWrappedListeners) {
      emitter._uuAppContextStoreWrappedListeners = {};
    }

    // Bind to EventEmitter object
    if (emitter.on && !emitter._uuAppContextStoreOriginalOn) {
      emitter._uuAppContextStoreOriginalOn = (emitter.on).bind(emitter);
      emitter.on = (event, listener) => {
        let wrappedListener = this._wrapListener(emitter, event, listener);
        return emitter._uuAppContextStoreOriginalOn(event, wrappedListener);
      };
    }
    if (emitter.removeListener && !emitter._uuAppContextStoreOriginalRemoveListener) {
      emitter._uuAppContextStoreOriginalRemoveListener = (emitter.removeListener).bind(emitter);
      emitter.removeListener = (event, listener) => {
        this._removeListener(emitter, event, listener, (listener) => {
          emitter._uuAppContextStoreOriginalRemoveListener(event, listener);
        });
        return emitter;
      }
    }

    // Bind to EventTarget object
    if (emitter.addEventListener && !emitter._uuAppContextStoreOriginalAddEventListener) {
      emitter._uuAppContextStoreOriginalAddEventListener = (emitter.addEventListener).bind(emitter);
      emitter.addEventListener = (event, listener, opts) => {
        let wrappedListener = this._wrapListener(emitter, event, listener);
        return emitter._uuAppContextStoreOriginalAddEventListener(event, wrappedListener, opts);
      };
    }
    if (emitter.removeEventListener && !emitter._uuAppContextStoreOriginalRemoveEventListener) {
      emitter._uuAppContextStoreOriginalRemoveEventListener = (emitter.removeEventListener).bind(emitter);
      emitter.removeEventListener = (event, listener, opts) => {
        this._removeListener(emitter, event, listener, (listener) => {
          emitter._uuAppContextStoreOriginalRemoveEventListener(event, listener, opts);
        });
      }
    }

  }

  /**
   * @deprecated Use {@link bind}.
   */
  bindEmitter(emitter) {
    this.bind(emitter);
  }

  /**
   * Forks context and runs given function.
   * @param fn Function to which should forked context store be bound.
   * @returns {*} Return value of invoked function.
   */
  fork(fn) {
    let asyncLocalStorages = GlobalStore.get("uuAppAsyncLocalStorages");
    let asyncLocalStorage = asyncLocalStorages.get(this._ctxName);
    if (!asyncLocalStorage) {
      throw new BaseError(`Context "${this._ctxName}" is not initialized.`);
    }
    let contextStore = new ContextStore(this._ctxName, this);
    let result;
    asyncLocalStorage.run(contextStore, () => {
      result = fn();
    })
    return result;
  }

  _wrapListener(emitter, event, listener) {
    if (!emitter._uuAppContextStoreWrappedListeners[event]) {
      emitter._uuAppContextStoreWrappedListeners[event] = new WeakMap();
    }
    if (!emitter._uuAppContextStoreWrappedListeners[event].has(listener)) {
      emitter._uuAppContextStoreWrappedListeners[event].set(listener, []);
    }
    let wrappedListener;
    if (Number(process.versions.node.split(".")[0]) <= 15) {
      // Workaround for https://github.com/nodejs/node/issues/36051
      // (AsyncResource.bind were not passing parameters to bound function)
      let asyncResource = new AsyncResource(this._ctxName);
      wrappedListener = function(...args) {
        return asyncResource.runInAsyncScope(listener, emitter, ...args);
      }
    } else {
      wrappedListener = AsyncResource.bind(listener);
    }
    emitter._uuAppContextStoreWrappedListeners[event].get(listener).push(wrappedListener);
    return wrappedListener;
  }

  _removeListener(emitter, event, listener, removeFn) {
    let wrappedListeners = emitter._uuAppContextStoreWrappedListeners[event] && emitter._uuAppContextStoreWrappedListeners[event].get(listener);
    if (wrappedListeners) {
      for (let wrappedListener of wrappedListeners) {
        removeFn(wrappedListener);
      }
      emitter._uuAppContextStoreWrappedListeners[event].delete(listener);
    }
    removeFn(listener);
  }

}

module.exports = ContextStore;
