"use strict";

const { Config, LruCache, Mutex } = require("uu_appg01_core-utils");
const { Uri, UriBuilder } = require("uu_appg01_core-uri");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { ValidationHelper, UseCaseError } = require("uu_appg01_core-appserver");
const { AppClient, SessionHandler } = require("uu_appg01_core-appclient");
const { AuthenticationService } = require("uu_appg01_core-authentication");
const { UuSubAppInstance, UuAppWorkspace } = require("uu_appg01_workspace");
const { ClientCredentialsProvider } = require("uu_appg01_oidc").Internal;
const ClientCredentialsHandler = require("./client-credentials-handler.js");
const Errors = require("../api/errors/oidc-errors.js");

const ASID = Config.get("asid");
const DEFAULT_PROVIDER_NAME = "oidcg02";

const ACCESS_POLICY_CACHE_TTL_CONFIG_NAME = "uu_app_oidc_access_policy_cache_ttl";
const ACCESS_POLICY_CACHE_TTL_DEFAULT_VALUE = 30 * 60;
const ACCESS_POLICY_CACHE_SIZE_CONFIG_NAME = "uu_app_oidc_access_policy_cache_size";
const ACCESS_POLICY_CACHE_SIZE_DEFAULT_VALUE = 1000;

class OidcAbl {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.oidc.appserver.OidcAbl");
    this.validator = Validator.load();
    let accessPolicyCacheTtl = (Config.getNumber(ACCESS_POLICY_CACHE_TTL_CONFIG_NAME) || ACCESS_POLICY_CACHE_TTL_DEFAULT_VALUE) * 1000;
    let accessPolicyCacheSize = Config.getNumber(ACCESS_POLICY_CACHE_SIZE_CONFIG_NAME) || ACCESS_POLICY_CACHE_SIZE_DEFAULT_VALUE;
    this.accessPolicyCache = new LruCache({maxAge: accessPolicyCacheTtl, maxSize: accessPolicyCacheSize});
    this.mutex = new Mutex();
  }

  async initOidcClient(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcInitOidcClientDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.InitOidcClient.UC_CODE}unsupportedKeys`,
      Errors.InitOidcClient.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.clientId) {
      dtoIn.clientId = dtoIn.awid;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 3
    let awid = dtoIn.awid;
    if (awid === ASID) {
      try {
        await UuSubAppInstance.get(ASID);
      } catch (e) {
        //A3
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppNotInitialized({ uuAppErrorMap }, { asid: ASID }, e);
        }
        throw e;
      }
    } else {
      try {
        await UuAppWorkspace.get(awid);
      } catch (e) {
        // A4
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppWorkspaceNotInitialized({ uuAppErrorMap }, { awid }, e);
        }
        throw e;
      }
    }

    // HDS 4
    let providerName = dtoIn.providerName;
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(awid, providerName, session);
    } catch (e) {
      // A5
      throw new Errors.InitOidcClient.IntegrationNotEnabled({ uuAppErrorMap }, { providerName }, e);
    }

    // HDS 5
    let clientId = dtoIn.clientId;
    let oidcConfig;
    let setPublicKeyDtoOut;
    if (dtoIn.clientSecret) {
      // HDS 5.1
      let authenticationService = AuthenticationService.get(providerName);
      try {
        // AuthenticationService.authenticate() does not allow login via clientId and clientSecret,
        // so we utilize the private attribute _oauthClient to check validity of clientSecret
        await authenticationService._oauthClient.grantClientCredentialsToken({client_id: clientId, client_secret: dtoIn.clientSecret});
      } catch (e) {
        // A6
        throw new Errors.InitOidcClient.InvalidCredentials({ uuAppErrorMap }, { clientId, providerName }, e);
      }
      oidcConfig = { clientSecret: dtoIn.clientSecret };
    } else {
      // HDS 5.2
      let keyPair = await ClientCredentialsHandler.generateClientKeyPair();
      let setPublicKeyDtoIn = { clientId, publicKey: keyPair.publicKey };
      if (dtoIn.credentialsInitToken) {
        setPublicKeyDtoIn.credentialsInitToken = dtoIn.credentialsInitToken;
      }
      try {
        setPublicKeyDtoOut = await oidcServerClient.post("authOidcClient/setPublicKey", setPublicKeyDtoIn);
      } catch (e) {
        if (e.code && e.code.endsWith("/oidcClientNotExist")) {
          // A7
          throw new Errors.InitOidcClient.OidcClientDoesNotExist({uuAppErrorMap}, {clientId}, e);
        } else if (e.code && e.code.endsWith("/invalidInitToken")) {
          // A8
          throw new Errors.InitOidcClient.InvalidCredentialsInitToken({uuAppErrorMap}, {clientId}, e);
        } else {
          // A9
          throw new Errors.InitOidcClient.RegistrationOfPublicKeyFailed({ uuAppErrorMap }, { clientId, providerName }, e);
        }
      }
      oidcConfig = { keyPair };
    }

    // HDS 6
    try {
      await ClientCredentialsHandler.configureOidcClient(awid, providerName, clientId, oidcConfig);
    } catch (e) {
      // A10
      throw new Errors.InitOidcClient.StoringOfOidcClientConfigurationFailed({ uuAppErrorMap }, { clientId }, e);
    }

    // HDS 7
    oidcServerClient = await this._getOidcServerClient(awid, providerName, session);

    // HDS 8
    let oidcClient;
    try {
      oidcClient = (await oidcServerClient.get("oidcClient/get", { clientId })).oidcClient;
    } catch (e) {
      // A11
      throw new Errors.InitOidcClient.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }

    // HDS 9
    let defaultRedirectUriBuilder = UriBuilder.parse(uri);
    defaultRedirectUriBuilder.setAwid(awid);
    defaultRedirectUriBuilder.setUseCase("oidc/callback");
    defaultRedirectUriBuilder.clearParameters();
    let defaultRedirectUri = defaultRedirectUriBuilder.toUri().toString();
    let redirectUriList = oidcClient.redirectUriList || [];
    if (!redirectUriList.includes(defaultRedirectUri)) {
      redirectUriList.push(defaultRedirectUri);
    }
    if (redirectUriList.length > 16) {
      // A12
      let message = `Redirect uri list of OidcClient ${clientId} is greater than 16. Default redirect uri ${defaultRedirectUri} was not set. Use oidc/setAllowedRedirects to set required redirects.`;
      let params = { clientId, redirectUri: defaultRedirectUri };
      ValidationHelper.addWarning(uuAppErrorMap, `${Errors.InitOidcClient.UC_CODE}tooManyRedirectUris`, message, params);
      this.logger.error(message);
    } else {
      let updateClientDtoIn = { clientId, redirectUriList };
      try {
        oidcClient = (await oidcServerClient.post("oidcClient/update", updateClientDtoIn)).oidcClient;
      } catch (e) {
        // A13
        throw new Errors.InitOidcClient.UpdateOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
      }
    }

    // HDS 10
    return {
      clientId: oidcClient.clientId,
      credentialsId: setPublicKeyDtoOut && setPublicKeyDtoOut.credentials.id,
      publicKey: setPublicKeyDtoOut && setPublicKeyDtoOut.publicKey,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async setAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcSetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAllowedRedirects.UC_CODE}unsupportedKeys`,
      Errors.SetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.awid, dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = { providerName: dtoIn.providerName };
      throw new Errors.SetAllowedRedirects.IntegrationNotEnabled({ uuAppErrorMap }, params, e);
    }

    // HDS 3, 4
    let oidcClient = await this._getOidcClient(oidcServerClient, dtoIn.providerName, dtoIn.awid,
      // A4
      Errors.SetAllowedRedirects.LoadingOfOidcClientConfigurationFailed,
      // A5
      Errors.SetAllowedRedirects.NoOidcClientConfigured,
      // A6
      Errors.SetAllowedRedirects.RetrievingOfOidcClientFailed,
      // A7
      Errors.SetAllowedRedirects.OidcClientDoesNotExist,
      uuAppErrorMap
    );

    // HDS 5
    let redirectUriList = dtoIn.redirectUriList || oidcClient.redirectUriList || [];
    let postLogoutUriList = dtoIn.postLogoutUriList || oidcClient.postLogoutUriList || [];
    let updateClientDtoIn = { clientId: oidcClient.clientId };
    if (redirectUriList.length > 0) {
      updateClientDtoIn.redirectUriList = redirectUriList;
    }
    if (postLogoutUriList.length > 0) {
      updateClientDtoIn.postLogoutUriList = postLogoutUriList;
    }
    try {
      let updateClientDtoOut = await oidcServerClient.post("oidcClient/update", updateClientDtoIn);
      oidcClient = updateClientDtoOut.oidcClient;
    } catch (e) {
      // A8
      throw new Errors.SetAllowedRedirects.UpdateOfOidcClientFailed({ uuAppErrorMap }, { clientId: oidcClient.clientId }, e);
    }

    // HDS6
    return {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async getAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcGetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.GetAllowedRedirects.UC_CODE}unsupportedKeys`,
      Errors.GetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.awid, dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = { providerName: dtoIn.providerName };
      throw new Errors.GetAllowedRedirects.IntegrationNotEnabled({ uuAppErrorMap }, params, e);
    }

    // HDS 3, 4
    let oidcClient = await this._getOidcClient(oidcServerClient, dtoIn.providerName, dtoIn.awid,
      // A4
      Errors.GetAllowedRedirects.LoadingOfOidcClientConfigurationFailed,
      // A5
      Errors.GetAllowedRedirects.NoOidcClientConfigured,
      // A6
      Errors.GetAllowedRedirects.RetrievingOfOidcClientFailed,
      // A7
      Errors.GetAllowedRedirects.OidcClientDoesNotExist,
      uuAppErrorMap
    );

    // HDS5
    return {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async verifyAccessPolicy(awid, session) {
    let uuAppErrorMap = {};
    let serviceName = session.getServiceName();
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(ASID, serviceName, session);
    } catch (e) {
      throw new Errors.VerifyAccessPolicy.IntegrationNotEnabled({ uuAppErrorMap }, { serviceName }, e);
    }

    let accessPolicyCacheKey = `${serviceName}|${awid}`;
    let accessPolicy = this.accessPolicyCache.get(accessPolicyCacheKey);
    if (!accessPolicy) {
      accessPolicy = await this.mutex.runOneAtTime(accessPolicyCacheKey, async () => {
        let loadedPolicy = await this._getOidcClientAuthNConfig(oidcServerClient, serviceName, awid,
          Errors.VerifyAccessPolicy.LoadingOfOidcClientConfigurationFailed,
          Errors.VerifyAccessPolicy.NoOidcClientConfigured,
          Errors.VerifyAccessPolicy.RetrievingOfOidcClientFailed,
          Errors.VerifyAccessPolicy.OidcClientDoesNotExist,
          uuAppErrorMap
        );
        this.accessPolicyCache.set(accessPolicyCacheKey, loadedPolicy);
        return loadedPolicy;
      });
    }

    let errorParamMap = {};
    if (accessPolicy.maxAuthenticationAge && accessPolicy.maxAuthenticationAge > 0) {
      let authExpireAt = session.getAuthenticationTime().getTime() + (accessPolicy.maxAuthenticationAge * 1000);
      if (Date.now() > authExpireAt) {
        errorParamMap.maxAuthenticationAge = accessPolicy.maxAuthenticationAge;
      }
    }

    if (accessPolicy.acrValuesList && accessPolicy.acrValuesList.length > 0) {
      if (!accessPolicy.acrValuesList.includes(session.getAttribute("acr"))) {
        errorParamMap.supportedAcrValues = accessPolicy.acrValuesList;
      }
    }

    let sessionRealmList = session.getAttribute("amr");
    let realmVerifyMode = accessPolicy.realmListVerifyMode;
    let deniedRealmList = accessPolicy.deniedRealmList;
    let allowedRealmList = accessPolicy.allowedRealmList;
    if (realmVerifyMode != "none" &&
        sessionRealmList && sessionRealmList.length > 0 &&
        ((deniedRealmList && deniedRealmList.length > 0) || (allowedRealmList && allowedRealmList.length > 0))) {
      let blockedRealms = [];
      let allowedRealms = [];
      for (let sessionRealm of sessionRealmList) {
        // Check if realm is not denied
        if (deniedRealmList && deniedRealmList.find(realm => realm.code === sessionRealm)) {
          blockedRealms.push(sessionRealm);
          continue;
        }
        // Check if realm is allowed
        if (allowedRealmList && allowedRealmList.length > 0 && !allowedRealmList.find(realm => realm.code === sessionRealm)) {
          blockedRealms.push(sessionRealm);
          continue;
        }
        allowedRealms.push(sessionRealm);
      }
      let sessionBlocked;
      if (realmVerifyMode === "strict") {
        // In string mode, all realms on session must be allowed
        sessionBlocked = blockedRealms.length > 0;
      } else {
        // In lax mode, any allowed realm is sufficient
        sessionBlocked = allowedRealms.length === 0;
      }
      if (sessionBlocked) {
        deniedRealmList.forEach((realm) => {
          if (!blockedRealms.includes(realm.code)) {
            blockedRealms.push(realm.code);
          }
        });
        errorParamMap.deniedAuthenticationRealms = blockedRealms;
      }
    }

    if (Object.keys(errorParamMap).length > 0) {
      throw new Errors.VerifyAccessPolicy.UntrustedSession({uuAppErrorMap}, errorParamMap);
    }
  }

  async _getOidcServerClient(awid, providerName, session) {
    let authenticationService = AuthenticationService.get(providerName);
    let baseUri = Uri.parse(await authenticationService.getServiceUri()).getBaseUri();
    let verifySsl = Config.getBoolean(`uu_app_oidc_providers_${providerName}_verify_ssl`, false);
    if (verifySsl == null) {
      verifySsl = true;
    }

    let useAuthFallback = true;
    // If awid system identity is initialized, try to authenticate as awid system identity
    let clientId = await ClientCredentialsProvider.getClientId(providerName, awid)
    if (clientId && !(await ClientCredentialsProvider.isUnregisteredClient(clientId, providerName, awid))) {
      try {
        session = await authenticationService.authenticate({systemIdentity: awid}, baseUri);
        useAuthFallback = false;
      } catch (e) {
        if (awid === ASID) {
          this.logger.warn(`Authentication as asid system identity [${awid}] failed.`, e);
        } else {
          this.logger.warn(`Authentication as awid system identity [${awid}] failed.`, e);
        }
      }
    }
    // If we are not working with asid and asid systemIdetity is initialized, try to authenticate as asid systemIentity
    if (useAuthFallback && awid !== ASID) {
      clientId = await ClientCredentialsProvider.getClientId(providerName, ASID)
      if (clientId && !(await ClientCredentialsProvider.isUnregisteredClient(clientId, providerName, ASID))) {
        try {
          session = await authenticationService.authenticate({systemIdentity: ASID}, baseUri);
          useAuthFallback = false;
        } catch (e) {
          this.logger.warn(`Authentication as asid system identity [${ASID}] failed.`, e);
        }
      }
    }
    // Try to authenticate as OidcClient executive (which is by default represented by asidOwner)
    // TODO This is only fallback for backward compatibility which can be removed in future once uuEes are dropped
    if (useAuthFallback) {
      let clientExecutive = Config.get(`uu_app_oidc_providers_${providerName}_client_executive`, false) || "app_identity";
      let executiveCredentials = await AuthenticationService.get()._resolvePasswordFileCredentials(clientExecutive);
      if (typeof executiveCredentials !== "string") {
        // Disable configured client credentials as they might not be valid.
        let unregisteredClientCredentials = await ClientCredentialsHandler.getUnregisteredCredentials(providerName, awid);
        executiveCredentials.clientCredentials = {
          client_id: unregisteredClientCredentials.clientId,
          client_secret: unregisteredClientCredentials.clientSecret
        };
        try {
          session = await authenticationService.authenticate(executiveCredentials, baseUri);
          useAuthFallback = false;
        } catch (e) {
          this.logger.warn(`Authentication as oidc client executive [${clientExecutive}] failed.`, e);
        }
      } else {
        this.logger.warn(`Unable to authenticate as oidc client executive because password file [${clientExecutive}] is not available.`);
      }
    }

    let interceptors = [...AppClient.getDefaultInterceptors(), SessionHandler];
    // Token exchange is disabled as without properly initialized system identity
    // exchange will fail and oidc server does not require matching token scope.
    // (Moreover this affects only using original user session as both system identity
    // and asid owner session are initialized with proper scope.)
    return new AppClient({baseUri, verifySsl, interceptors, session, useTokenExchange: false});
  }

  async _getOidcClientAuthNConfig(oidcServerClient, serviceName, awid, loadConfigurationError, missingConfigurationError, retrieveFailedError, clientDoesNotExistError, uuAppErrorMap) {
    uuAppErrorMap = uuAppErrorMap || {};
    let clientId;
    try {
      clientId = await ClientCredentialsProvider.getClientId(serviceName, awid);
    } catch (e) {
      throw new loadConfigurationError({ uuAppErrorMap }, e);
    }
    if (!clientId || (await ClientCredentialsProvider.isUnregisteredClient(clientId, serviceName, awid))) {
      throw new missingConfigurationError({ uuAppErrorMap }, { serviceName });
    }
    let authNConfig;
    try {
      authNConfig = await oidcServerClient.cmdGet("oidcClient/loadAuthenticationConfig", { clientId });
      delete authNConfig.uuAppErrorMap;
    } catch (e) {
      if (e.code && e.code.includes("oidcClientNotFound")) {
        throw new clientDoesNotExistError({ uuAppErrorMap }, { clientId });
      } else {
        throw new retrieveFailedError({ uuAppErrorMap }, { clientId }, e);
      }
    }
    return authNConfig;
  }

  async _getOidcClient(oidcServerClient, serviceName, awid, loadingConfigurationError, missingConfigurationError, retrieveFailedError , clientDoesNotExistError, uuAppErrorMap) {
    uuAppErrorMap = uuAppErrorMap || {};
    let clientId;
    try {
      clientId = await ClientCredentialsProvider.getClientId(serviceName, awid);
    } catch (e) {
      throw new loadingConfigurationError({ uuAppErrorMap }, e);
    }
    if (!clientId || (await ClientCredentialsProvider.isUnregisteredClient(clientId, serviceName, awid))) {
      throw new missingConfigurationError({ uuAppErrorMap }, { serviceName });
    }
    let getClientDtoOut;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", { clientId });
    } catch (e) {
      throw new retrieveFailedError({ uuAppErrorMap }, { clientId }, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      throw new clientDoesNotExistError({ uuAppErrorMap }, { clientId });
    }
    return getClientDtoOut.oidcClient;
  }

}

module.exports = new OidcAbl();
