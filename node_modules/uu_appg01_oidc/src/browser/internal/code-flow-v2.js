"use strict";

const { AppClient } = require("uu_appg01_core-appclient");
const ClientCredentialsProvider = require("./client-credentials-provider.js");
const AbstractAuthorizationFlow = require("./abstract-authorization-flow.js");
const CodeFlow = require("./code-flow.js");
const InteractionRequired = require("../interaction-required.js");

const RESTORE_SESSION_FORCED = "forced";
const WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
const CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");

const DEFAULT_ERROR_CODE = "interaction_required";
const DEFAULT_ERROR_MESSAGE = "Authentication Request cannot be completed without displaying a user interface for End-User interaction.";
const INVALID_ACR_ERROR_MESSAGE = "Requested acr values are not satisfied.";
const INVALID_MAX_AGE_ERROR_MESSAGE = "Requested max age is not satisfied.";

/**
 * Implementation of code flow with mitigation for thirdparty cookies.
 * (uses redirect for session restore, command for refresh and calltoken)
 */
class CodeFlowV2 extends CodeFlow {

  constructor(oauthClient, serviceName, redirectUri, appBaseUri) {
    super(oauthClient, serviceName, redirectUri);
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._redirectUri = redirectUri;
    this._appBaseUri = appBaseUri;
    this._client = new AppClient();
    this._doOnlyLocalSessionCheck = false;
  }

  async restoreSession(options, scope) {
    let isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    let result = await this._restoreSessionViaAppSession(options, scope);
    let resultValid = result && await this._assertConstraints(result.claims, options, isAuthCallback);
    if (!resultValid && !isAuthCallback) {
      result = await this._restoreSessionViaIdpSession(options, scope);
    }
    if (!result) {
      // We have to load asynchronous data, else interactive login will fail.
      await this._oauthClient.getMetadata();
      await ClientCredentialsProvider.getClientId(this._serviceName);
      let callbackError = sessionStorage.getItem("uu_app_oidc_auth_cb_error");
      if (callbackError) {
        callbackError = Object.values(JSON.parse(callbackError))[0];
      }
      let errorMessage = callbackError?.message || DEFAULT_ERROR_MESSAGE;
      let errorId = callbackError.id || null;
      let error = new InteractionRequired(errorMessage);
      error.code = DEFAULT_ERROR_CODE;
      if (errorId) {
        error.id = errorId;
      }
      throw error;
    }
    return result;
  }

  async checkSession(query) {
    let result;
    if (this._doOnlyLocalSessionCheck) {
      return this._isSessionValid() ? "unchanged" : "changed";
    } else {
      result = await super.checkSession(query);
      if (result === "unknown") {
        this._logger.warn("Switching global session check to application session check due to blocked thirdparty cookies.");
        this._doOnlyLocalSessionCheck = true;
        result = "unchanged";
      }
    }
    return result;
  }

  async refreshSession(options, scope = null) {
    if (!this._isSessionValid()) {
      let error = new InteractionRequired(DEFAULT_ERROR_MESSAGE);
      error.code = DEFAULT_ERROR_CODE;
      throw error;
    }
    let authResponseTime = Date.now();
    let claims;
    try {
      claims  = (await this._client.post(this._appBaseUri + "oidc/extendSession")).data;
    } catch (e) {
      if (e.status && e.status === 401) {
        let error = new InteractionRequired(DEFAULT_ERROR_MESSAGE, e);
        error.code = DEFAULT_ERROR_CODE;
        throw error;
      } else {
        throw e;
      }
    }
    await this._assertConstraints(claims, options, true);
    let globalSessionExpiresAt = authResponseTime + 1000 * claims.session_info.session_expires_in;
    let globalSessionState = claims.session_info.session_state;
    let clientId = claims.session_info.client_id;
    delete claims.session_info;
    delete claims.uuAppErrorMap;
    return {claims, globalSessionExpiresAt, globalSessionState, clientId};
  }

  async getCallToken(options, scope = null) {
    let grantResult = (await this._client.post(this._appBaseUri + "oidc/grantCallToken", {scope})).data;
    let expireAt = Date.now() + grantResult.expires_in * 1000;
    return {idToken: grantResult.id_token, accessToken: grantResult.access_token, expireAt};
  }

  async _restoreSessionViaAppSession(options, scope) {
    this._logger.debug("Trying to restore session based on existing application session.");
    if (!this._isSessionValid()) {
      this._logger.debug("Application session not found.");
      return null;
    }
    let authResponseTime = Date.now();
    let claims;
    try {
      claims = (await this._client.get(this._appBaseUri + "oidc/introspect", {_: Date.now()})).data;
    } catch (e) {
      this._logger.debug("Restoring of session based on existing application session failed.", e);
      return null;
    }

    if (!claims || !claims.session_info) {
      this._logger.debug("Application session not found.");
      return null;
    }

    let globalSessionExpiresAt = authResponseTime + 1000 * claims.session_info.session_expires_in;
    let globalSessionState = claims.session_info.session_state;
    let clientId = claims.session_info.client_id;
    delete claims.session_info;
    delete claims.uuAppErrorMap;
    let acrValues = options.acrValues || this._defaultAcrValues;
    let maxAge = options.maxAge || this._defaultMaxAge;
    let authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
    if (authenticationContext) {
      authenticationContext = JSON.parse(authenticationContext);
      sessionStorage.removeItem("uu_app_oidc_auth_ctx");
    }

    return {
      claims,
      idToken: null,
      accessToken: null,
      authenticationContext,
      globalSessionExpiresAt,
      globalSessionState,
      clientId,
      scope,
      acrValues,
      maxAge
    };
  }

  async _restoreSessionViaIdpSession(options, scope) {
    this._logger.debug("Restoring session by redirection to configured identity provider.");
    // We have to load metadata, else redirect will not work
    // due to requirement of metadata being available locally
    await this._oauthClient.getMetadata();
    options = {...options, usePopup: false, prompt: "none", noIframe: true};
    if (AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED) {
      delete options.prompt;
    }
    // Store current referrer to provide it after redirect
    sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
    return this.authenticate(options, scope);
  }

  async _assertConstraints(claims, options, throwError) {
    let acrValues = options.acrValues || this._defaultAcrValues;
    if (acrValues && !acrValues.includes(claims.acr)) {
      if (throwError) {
        let error = new InteractionRequired(INVALID_ACR_ERROR_MESSAGE);
        error.code = DEFAULT_ERROR_CODE;
        throw error;
      } else {
        return false;
      }
    }
    let maxAge = options.maxAge || this._defaultMaxAge;
    if (maxAge && ((claims.auth_time + maxAge) * 1000) < Date.now()) {
      if (throwError) {
        let error = new InteractionRequired(INVALID_MAX_AGE_ERROR_MESSAGE);
        error.code = DEFAULT_ERROR_CODE;
        throw error;
      } else {
        return false;
      }
    }
  }

  _isSessionValid() {
    let csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
    if (!csrfToken) {
      return false;
    }
    let tokenParts = csrfToken.split(".");
    if (tokenParts.length === 3) {
      // Token with expiration (newer version of backend)
      return Number(tokenParts[0]) * 1000 > Date.now() ? true : false;
    } else {
      // Token without expiration (older version of backend)
      return true;
    }
  }

}

module.exports = CodeFlowV2;
