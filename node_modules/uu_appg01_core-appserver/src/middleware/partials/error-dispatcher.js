"use strict";
const fs = require("fs");
const path = require("path");

const httpStatusCodes = require("../../http/http-status-codes.js");
const { LoggerFactory } = require("uu_appg01_core-logging");
const errorConverter = require("../../utils/error-converter");

const VAR_REG_EXP = /<%=\s*(\w[\w\.]*)\s*%>/g;
const COMMENT_REG_EXP = /<!--.*?-->/s;
const UNDEFINED_VALUE = "";

/**
 * ErrorDispatcher is a helper class that takes care of error serialization.
 * Both ErrorHandler and NoResponse middleware depend on this module.
 */
class ErrorDispatcher {
  /**
   * Dispatch method uses Express res.format API to correctly serialize
   * errors based on request accept headers. HTML and JSON error responses
   * are supported.
   * @param {BaseError, UseCaseError} err
   * @param {Object} res
   * @param {Object} opts
   */
  dispatch(err, res, opts) {
    let { htmlEnabled, verbose } = opts;
    let { dtoOut, status, headers, errorCode, errorMessage } = errorConverter.buildErrorDtoOut(err, verbose);
    res.locals.dispatchedError = err;
    res.locals.dispatchedErrorCode = errorCode;
    res.locals.dispatchedErrorMessage = errorMessage;

    if (status >= 500) {
      this._getLogger().fatal(err.message || "Request failed.", err);
    } else {
      this._getLogger().error(err.message || "Request failed.", err);
    }
    res.format({
      json: () => {
        res.status(status);
        res.set(headers);
        res.json(dtoOut);
      },
      html: () => {
        res.status(status);
        res.set(headers);
        if (htmlEnabled) {
          let params = this._buildHttpErrorResponse(err, status, verbose);
          fs.readFile(path.join(__dirname, "..", "..", "views", `error-${status}.html`), "utf8", (err, text) => {
            if (err) {
              if (err.code === "ENOENT") {
                this._getLogger().debug("No error template found in views folder. Using default set of templates.");
                fs.readFile(path.join(__dirname, "..", "..", "views", "error-default.html"), "utf8", (err, text) => {
                  params.verboseMessage = params.verbose ? `<div>Error backtrace:</div><div style="white-space:pre">${params.error?.trace || ""}</div>` : "";
                  params.reportProblem = status < 500 ? "" :
                    `<div class="buttons-container">
            			     <a class="border-button" href="mailto:helpdesk@plus4u.net?subject=Report of problem ${params.error.id}" target="_blank">Report A Problem</a>
        			       </div>`;
        			    text = this._removeComments(text);
                  res.send(this._resolveVariables(text, params));
                });
              } else {
                throw err;
              }
            } else {
              text = this._removeComments(text);
              res.send(this._resolveVariables(text, params));
            }
          });
        } else {
          res.json(dtoOut);
        }
      },
      default: () => {
        // default is a reserved keyword
        res.status(status);
        res.set(headers);
        res.json(dtoOut);
      }
    });
  }

  /**
   * Builds standardized error message, assigning default values
   * and headers where missing.
   * @param {BaseError, UseCaseError} error
   * @param {Boolean} verbose
   * @returns {{errorMessage: (*|{}), status: number, headers: {}}}
   * @private
   */
  _buildErrorMessage(error, verbose = false) {
    let status = error.status || 500;
    let headers = error.headers || {};
    headers["Connection"] = headers["Connection"] || "close";
    let errorMessage = error.dtoOut || {};
    let code = error.code || "uu-appg01/server/internalServerError";
    errorMessage["uuAppErrorMap"] = errorMessage["uuAppErrorMap"] || {};

    let messageBody = {};
    let raisedErrorMessage = {
      [code]: messageBody
    };

    if (error.id) {
      messageBody.id = error.id;
    }
    if (error.timestamp) {
      messageBody["timestamp"] = error.timestamp.toISOString();
    }
    if (error.type) {
      messageBody.type = error.type;
    } else {
      messageBody.type = "error";
    }
    if (verbose || error.message !== error.constructor.name) {
      messageBody.message = error.message;
    } else {
      messageBody.message = "Unexpected error";
    }
    if (error.paramMap && typeof error.paramMap === "object" && Object.keys(error.paramMap).length) {
      messageBody.paramMap = error.paramMap;
    }
    if (verbose) {
      messageBody.trace = error.stack;
      if (error.cause) {
        messageBody.cause = this._buildErrorMessage(error.cause, verbose).errorMessage;
      }
    } else {
      if (error.cause && error.cause.code) {
        messageBody.cause = this._buildErrorMessage(error.cause, verbose).errorMessage;
      }
    }

    delete errorMessage.uuAppErrorMap.code;
    errorMessage.uuAppErrorMap = Object.assign(raisedErrorMessage, errorMessage.uuAppErrorMap);

    return {
      errorMessage,
      status,
      headers,
      errCode: code,
      errMessage: messageBody.message
    };
  }

  /**
   * Prepares a data object for serialization (rendering) using EJS template.
   * @param {BaseError, UseCaseError} error
   * @param {Number} status
   * @param {Boolean} verbose
   * @returns {{verbose: boolean, statusCode: number, statusText: string, error: {message: string, trace, code: string, id: uuid}}}
   * @private
   */
  _buildHttpErrorResponse(error, status, verbose = false) {
    return {
      verbose,
      statusCode: status,
      statusText: httpStatusCodes[status],
      error: {
        message: error.message,
        trace: error.stack,
        code: error.code || "",
        id: error.id
      }
    };
  }

  _getLogger() {
    if (!this._logger) {
      this._logger = LoggerFactory.get("Uu.Appg01.Core.Appserver.Middleware.Partials.ErrorDispatcher");
    }
    return this._logger;
  }
  
  _resolveVariables(value, parameters = {}) {
    let result = value;
    if (value) {
      result = value.toString().replace(VAR_REG_EXP, (_, paramName) => this._resolveValue(paramName, parameters));
    }
    return result;
  }

  _removeComments(value) {
    let result = value;
    if (value) {
      result = value.toString().replace(COMMENT_REG_EXP, "");
    }
    return result;
  }

  _resolveValue(paramName, parameters) {
    let result = UNDEFINED_VALUE;
    if (paramName) {
      result = parameters;
      paramName.split('.').forEach(namePart => {
        result = result ? result[namePart] : null;
      });
    }
    return result ? result : UNDEFINED_VALUE;
  }
  
}

/**
 * Module exports a single instance of ErrorDispatcher that is initialized
 * at application startup (when the first relevant require call is resolved).
 * @type {ErrorDispatcher}
 */
module.exports = new ErrorDispatcher();
