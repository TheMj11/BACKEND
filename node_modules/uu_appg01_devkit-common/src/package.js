const child_process = require("child_process");
const fs = require("fs-extra");
const path = require("path");
const util = require("util");

let fs_readFile = util.promisify(fs.readFile);
let fs_writeFile = util.promisify(fs.writeFile);

let instances = new Map();
let instancesSync = new Map();

const ORDERED_KEYS = [
  "name",
  "version",
  "private",
  "workspaces",
  "description",
  "license",
  "namespace",
  "spec",
  "dependencies",
  "uuBuildSettings",
  "devDependencies",
  "engines",
  "scripts",
  "main",
  "jsnext:main",
  "module",
  "files",
  "prettier",
];

module.exports = class Package {
  constructor(path) {
    this._path = path;
  }

  // returns same instance of Package, if it was called with same path
  // (optimizes access to package.json from various components)
  static async getSingleton(filePath = "package.json") {
    let normPath = path.resolve(filePath);
    let instance = instances.get(normPath);
    if (!instance) {
      instance = new Package(normPath).load();
      instances.set(normPath, instance);
    }
    let result = await instance;
    // solve situation if someone called get & getSync, i.e. getSync is already done
    // (we want to always use only a single instance of Package class per file path)
    // => prefer sync instance if present
    if (!instancesSync.has(normPath)) instancesSync.set(normPath, result);
    else result = instancesSync.get(normPath);
    return result;
  }

  // returns same instance of Package, if it was called with same path
  /**
   *
   * @param {*} filePath
   * @return {Package}
   */
  static getSingletonSync(filePath = "package.json") {
    let normPath = path.resolve(filePath);
    let instance = instancesSync.get(normPath);
    if (!instance) {
      instance = new Package(normPath).loadSync();
      instancesSync.set(normPath, instance);
    }
    return instance;
  }

  /**
   * @param {*} json Object whose keys are to be sorted.
   */
  static sort(json, orderedKeys = ORDERED_KEYS) {
    let max = orderedKeys.length;
    let keys = Object.keys(json);
    keys.sort((a, b) => {
      let orderA = orderedKeys.indexOf(a);
      let orderB = orderedKeys.indexOf(b);
      if (orderA === -1) orderA = max;
      if (orderB === -1) orderB = max;
      return orderA - orderB || (a < b ? -1 : a > b ? 1 : 0); // unknown keys at the end alphabetically
    });
    let result = {};
    for (let key of keys) result[key] = json[key];
    return result;
  }

  static parseProduct(name) {
    let normName = name.match(/^uu5/) ? "uu_" + name : name;
    let [product, ...dashPartsRest] = normName.split("-");
    let specifier = dashPartsRest.join("-");
    let [vendor, app, subApp, ...sppParts] = product.split("_");
    let spp = sppParts.join("_");
    return { vendor, app, subApp, spp, specifier, product, name: normName.replace(/^uu_uu5/, "uu5") };
  }

  static getDefaultFields() {
    return {
      engines: {
        node: ">=" + require("./config/preconditions.js").NODEJS_VERSION, // this is just a plain-text hint, by default it is not enforced by node/npm
      },
      prettier: {
        printWidth: 120,
      },
    };
  }

  get() {
    if (this._json && !Object.hasOwn(this._json, "normalizedUuName")) {
      Object.defineProperty(this._json, "normalizedUuName", {
        enumerable: false,
        configurable: true,
        get: () => this.normalizedUuName,
      });
    }
    return this._json;
  }
  set(json) {
    if (this._json && json && this._json.spec !== json.spec) delete this._templateInfo;
    this._json = json;
  }
  merge(json) {
    if (this._json && json && this._json.spec !== json.spec) delete this._templateInfo;
    Object.assign(this._json, json);
  }
  async load() {
    this.set(JSON.parse(await fs_readFile(this._path, "utf-8")));
    return this;
  }
  loadSync() {
    this.set(JSON.parse(fs.readFileSync(this._path, "utf-8")));
    return this;
  }
  async save() {
    if (!this._json) throw new Error("Unable to save package.json - JSON is empty. Save path is " + this._path);
    let json = Package.sort(this._json);
    await fs_writeFile(this._path, JSON.stringify(json, null, 2) + "\n", "utf-8");
  }
  saveSync() {
    if (!this._json) throw new Error("Unable to save package.json - JSON is empty. Save path is " + this._path);
    let json = Package.sort(this._json);
    fs.writeFileSync(this._path, JSON.stringify(json, null, 2) + "\n", "utf-8");
  }

  async prepareNpmPackFiles({ outputDir = "target/npm-pack", uuAppJson } = {}) {
    if (path.resolve(outputDir) !== path.resolve(".")) {
      fs.emptyDirSync(outputDir);

      // copy license
      if (!(await fs.pathExists("LICENSE")) && (await fs.pathExists("../LICENSE"))) {
        await fs.copy("../LICENSE", path.join(outputDir, "LICENSE"), { overwrite: true });
      }

      // copy all files as given by "files" field in package.json to our npmPackDir
      let packResult = child_process.spawnSync("npm", ["pack", "--dry-run", "--json", "--loglevel=notice"], {
        shell: true,
        cwd: path.dirname(path.resolve(this._path)),
      });
      let json = packResult.stdout.toString().trim();
      let extraFiles;
      try {
        extraFiles = json ? (((JSON.parse(json) || [])[0] || {}).files || []).map((it) => it.path) : [];
      } catch (e) {
        // npm >= 7.x no longer supports "--json" flag therefore JSON.parse fails; but it does output something like:
        //   npm notice === Tarball Contents ===
        //   npm notice 9.7kB LICENSE
        //   npm notice 2.1kB package.json
        //   ...
        // in stderr, so try to parse that :-/
        let plainText = packResult.stderr
          .toString()
          .trim()
          .replace(/\033\[[0-9;]+m/g, ""); // strip color codes
        extraFiles = [];
        plainText.replace(/(?:^|\n)npm notice\s+\d+(?:\.\d+)?[kmg]?B\s+(.*)/g, (m, g) => extraFiles.push(g.trim()));
        if (extraFiles.length === 0) {
          // old versions of npm also don't support "--json" or it's new version of npm with different output...
          // => estimate files to package
          extraFiles = ["package.json", "LICENSE", "README.md"];
          let isFatal;
          let pkg = this.get();
          if (Array.isArray(pkg.files)) {
            let incompatible = pkg.files.filter(
              (f) =>
                typeof f !== "string" || (f.indexOf("*") !== -1 && !f.match(/^dist(\*|-node\/\*|-esm\/\*|\/\*)?$/)),
            );
            isFatal = incompatible.length > 0;
            if (!isFatal) extraFiles = extraFiles.concat(pkg.files.filter((f) => f.indexOf("*") === -1));
          }
          const chalk = require("chalk");
          if (isFatal) {
            console.error(
              "  " +
                chalk.red("ERROR") +
                ` Unable to create npm package - this project is using custom "files" value in package.json. Upgrade Node.js to >= 10.16.0 to fix this issue. If that is not possible then do not use glob patterns in "files" array.`,
            );
            process.exit(1);
          }
          console.warn(
            "  " +
              chalk.yellow("WARN") +
              " This version of npm is not fully supported - try to upgrade it. Extracting list of files from `npm pack --dry-run` was unsuccessful, but it should still be OK (will use estimated list - you can check resulting .tgz file whether it contains all expected files).",
          );
          extraFiles = [...new Set(extraFiles)].filter((f) => fs.existsSync(f));
        }
      }
      let jobFns = extraFiles.map(
        (file) => async () => fs.copy(file, path.join(outputDir, file), { overwrite: false }),
      );
      await this._batchExecute(20, jobFns);
    }

    // update package.json fields by data in uuAppJson
    if (uuAppJson !== null) {
      uuAppJson ??= JSON.parse(
        await fs.readFile((await fs.pathExists("uuapp.json")) ? "uuapp.json" : "../uuapp.json", "utf-8"),
      );
      let pkg = this.get();
      let config = { ...uuAppJson, ...uuAppJson[path.basename(path.dirname(path.resolve(this._path)))] };
      let { version, description, license } = config;
      if (description?.en) description = description.en;
      if (version) pkg.version = version;
      if (description) pkg.description = description;
      if (license) pkg.license = license;
      await fs.writeFile(path.join(outputDir, "package.json"), JSON.stringify(pkg, null, 2), "utf-8");
    }

    return outputDir;
  }

  get name() {
    return this.get()["name"];
  }
  get normalizedUuName() {
    // workspace root can be e.g. "name": "uu5g05~root"; it cannot simply be "uu5g05" because it would collide
    // with nested uu5g05/package.json name (which then causes issues if npm/pnpm symlinks the wrong one into another
    // project, e.g. uu5g05-elements/node_modules/uu5g05)
    //   => remove suffix
    // TODO Next major - workspace root should probably use product name from uuapp.json, not "name" from root package.json.
    return this.name.replace(/~.*/, "");
  }
  get vendor() {
    return this._getNameParts().vendor;
  }
  get nameNoVendor() {
    return this._getNameParts().nameNoVendor;
  }
  get nameWithVendor() {
    let { vendor, nameNoVendor } = this._getNameParts();
    return vendor + "_" + nameNoVendor;
  }

  get templateInfo() {
    if (!this._templateInfo) {
      let spec = this.get()["spec"];
      if (!spec)
        throw new Error(
          "This project is not properly initialized (missing 'spec' field in package.json). Project conversion is not supported. Run 'npx create-uuapp -h' or 'npx create-uulib -h' for help on creating new project.",
        );
      let specParts = spec.split(/\s*;\s*/); // e.g. "nodejs-lib; uu_appg01@0.1.0"
      specParts[0] = specParts[0].replace(/^node-/, "nodejs-"); // TODO Remove.
      let specList = specParts
        .slice(1)
        .map((it) => {
          let [name, version] = it.split("@");
          if (name) name = name.trim();
          if (name === "uu_appg01") name = "uu_appg01_devkit"; // rename really old specs
          version = version?.trim() || "";
          return name ? { name, version } : undefined;
        })
        .filter(Boolean);
      if (!specList.some((it) => it.name === "uu_appg01_devkit")) {
        throw new Error(
          "This project is not properly initialized or it was initialized using different generation of devkit (value in 'spec' field in package.json is not valid for uu_appg01_devkit).",
        );
      }
      this._templateInfo = {
        type: specParts[0],
        specList,
        toString: function () {
          let { type, specList } = this;
          return [type || "", ...specList.map(({ name, version }) => `${name}${version ? "@" + version : ""}`)].join(
            "; ",
          );
        },
      };
    }
    return this._templateInfo;
  }

  _getNameParts() {
    let vendor, nameNoVendor;
    let nameParts = this.normalizedUuName.split("_");
    if (nameParts.length === 1) [vendor, nameNoVendor] = ["uu", nameParts[0]];
    else [vendor, nameNoVendor] = [nameParts[0], nameParts.slice(1).join("_")];
    return { vendor, nameNoVendor };
  }

  async _batchExecute(maxBatchSize, jobFns) {
    // runs all jobFns; at most maxBatchSize run in parallel at any time
    // NOTE Rejects on 1st error encountered (jobs that are in-flight at the time
    // of the error are not cancelled, i.e. they will finish later than the rejection).
    let { result } = await jobFns.reduce(
      async (partialResult, jobFn, i, arr) => {
        let { result, inFlightSet } = await partialResult;
        if (inFlightSet.size >= maxBatchSize) await Promise.race(inFlightSet);
        let jobPromise = Promise.resolve().then(jobFn);
        let jobPromiseWithRemoval = jobPromise.then(() => inFlightSet.delete(jobPromiseWithRemoval));
        inFlightSet.add(jobPromiseWithRemoval);
        result.push(jobPromise);
        return { result, inFlightSet };
      },
      { result: [], inFlightSet: new Set() },
    );
    return Promise.all(result);
  }
};
