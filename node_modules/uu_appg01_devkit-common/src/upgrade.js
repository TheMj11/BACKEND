const child_process = require("child_process");
const fs = require("fs");
const path = require("path");
const semver = require("semver");

const Package = require("./package.js");

module.exports = async function (config, templateInfo) {
  let pack = Package.getSingletonSync();
  let pluginNames = getDevkitPlugins(pack);

  // install newest version of devkit/plugins first
  if (config.get("devkitVersionCheck") !== false) {
    let modulesToCheck = ["uu_appg01_devkit", ...pluginNames];
    let modulesToUpdate = (
      await Promise.all(
        modulesToCheck.map(async (name) => {
          let modulePkg = requireOptionalPackageJson(name);
          let installedVersion = modulePkg?.version;
          let availableVersionList = await listAvailableVersions(name); // sorted
          if (availableVersionList.length === 0) {
            return !modulePkg ? { name, specifiedVersion: pack.get().devDependencies[name] } : undefined;
          }

          let moduleLastUpgradeVersion =
            pack.templateInfo.specList.find((it) => it.name === name)?.version || undefined;
          if (!availableVersionList.includes(moduleLastUpgradeVersion)) {
            moduleLastUpgradeVersion = undefined;
          }

          let minCompatibleVersion;
          if (!moduleLastUpgradeVersion) {
            minCompatibleVersion = installedVersion;
            if (!minCompatibleVersion) {
              try {
                minCompatibleVersion = semver.minVersion(pack.get().devDependencies[name]);
              } catch (e) {
                // e.g. version specifier is actually link to .tgz file => fall back to newest
              }
              minCompatibleVersion ||= availableVersionList[availableVersionList.length - 1];
            }
          } else {
            minCompatibleVersion = moduleLastUpgradeVersion;
          }

          if (
            installedVersion &&
            semver.compare(minCompatibleVersion, installedVersion) < 0 &&
            !semver.satisfies(installedVersion, "^" + minCompatibleVersion)
          ) {
            // NOTE This is e.g. case where project was upgraded to devkit 5.18.0 (in "spec" field in package.json),
            // but locally installed is 6.5.0 (newer major). It could be better to downgrade locally installed devkit
            // to latest 5.x such as 5.22.0 first, run upgrades between 5.19.0 and 5.22.0 and then either to tell user
            // to run upgrade again or to continue with installing 6.x version and running upgrades 6.0.0..6.x.y. Doing it that
            // way would allow 6.x versions to not include upgrade scripts for old (5.x) versions.
            // TODO Think scenarios through. For now we'll take current installed version and upgrade it to higher but compatible
            // version (same major).
            minCompatibleVersion = installedVersion;
          }
          let highestCompatibleVersion = [...availableVersionList]
            .reverse()
            .find((version) => semver.satisfies(version, "^" + minCompatibleVersion));
          let latestVersion = availableVersionList[availableVersionList.length - 1];

          let targetVersion = highestCompatibleVersion;
          let needsUpdate = !installedVersion || (targetVersion && semver.compare(installedVersion, targetVersion) < 0);
          return needsUpdate ? { name, installedVersion, targetVersion, latestVersion } : undefined;
        }),
      )
    ).filter(Boolean);

    if (modulesToUpdate.length > 0) {
      console.log(
        `Installing newer compatible devkit and/or plugins (use '-- --no-devkit-version-check' to skip this):
  ${modulesToUpdate.map((it) => `${it.name} ${it.installedVersion || "(not installed)"} -> ${it.targetVersion || it.specifiedVersion}${it.latestVersion && it.latestVersion !== it.targetVersion ? ` (latest is ${it.latestVersion})` : ``}`).join("\n  ")}`,
      );
      const PackageManager = require("./tools/package-manager.js");
      await PackageManager.update({
        packages: modulesToUpdate
          .map((it) => (it.targetVersion ? it.name + "@" + it.targetVersion : ""))
          .filter(Boolean),
        inWholeWorkspace: templateInfo.type === "nodejs-multi",
      });
      // NOTE Not passing "--no-devkit-version-check" because nodejs-multi would then pass it down to underlying projects
      // (which can still have old versions). Could be optimized.
      child_process.spawnSync("npm", ["run", "uuAppDevKitUpgrade"], {
        shell: true,
        stdio: "inherit",
        env: process.env,
        cwd: process.cwd(),
      });
      return { ranNewerUpgrade: true }; // at this point, upgrade was already performed by newer devkit, don't continue
    }
  }

  // run all relevant upgrades from ./upgrades/* folder, based on version in project's "spec" field in its package.json
  console.log("Running uu_appg01_devkit upgrades...");
  let { specList } = templateInfo;
  let devkitSpec = specList.find((it) => it.name === "uu_appg01_devkit");
  let upgrades = fs.readdirSync(path.join(__dirname, "upgrades")).filter((name) => name.match(/^upgrade-.*\.js$/));
  let upgradeVersions = upgrades.map((name) => name.replace(/^upgrade-(.*)\.js$/, "$1"));
  if (!devkitSpec.version || !semver.valid(devkitSpec.version)) {
    throw new Error(
      'Invalid spec version in package.json in \'spec\' field. The value should look like: "${templateInfo.type}; ${specName}@3.0.0", e.g. "uu5-lib; uu_appg01_devkit@3.0.0". The version denotes which devkit version was the project last updated to.',
    );
  }
  let upgradeVersionsToDo = upgradeVersions.filter((version) => semver.compare(devkitSpec.version, version) < 0);
  upgradeVersionsToDo.sort((a, b) => semver.compare(a, b));
  for (let upgradeVersion of upgradeVersionsToDo) {
    let upgrade = require(`./upgrades/upgrade-${upgradeVersion}.js`);
    await upgrade(config, templateInfo);
  }

  // update spec
  pack.loadSync();
  await updateSpec(pack, "uu_appg01_devkit", require("../package.json").version);

  // run upgrades in all plugins
  pluginNames = getDevkitPlugins(pack); // reload plugins
  for (let pluginName of pluginNames) {
    let pluginApi;
    try {
      pluginApi = require(require.resolve(pluginName, { paths: ["."] }));
    } catch (e) {
      if (e?.code !== "MODULE_NOT_FOUND") throw e;
      // if plugin got installed as a part of our devkit's upgrade, there's an issue that it's not directly require-able
      // for some reason - try requiring directly plugin/src/index.js instead
      try {
        pluginApi = require(require.resolve(pluginName + "/src/index.js", { paths: ["."] }));
      } catch (e) {
        // not all devkit plugins need to export API => skip those
        if (e?.code !== "MODULE_NOT_FOUND") throw e;
        continue;
      }
    }
    let hasApi = typeof pluginApi?.Tasks?.upgrade === "function";
    if (hasApi) {
      let pluginSpec = pack.templateInfo.specList.find((it) => it.name === pluginName);
      let pluginLastUpgradeVersion = pluginSpec?.version || undefined;

      // do the upgrade
      let result = await pluginApi?.Tasks?.upgrade?.({ versionFrom: pluginLastUpgradeVersion });

      // update spec
      let versionTo =
        result?.versionTo || require(require.resolve(pluginName + "/package.json", { paths: ["."] })).version;
      pack.loadSync(); // reload package.json
      await updateSpec(pack, pluginName, versionTo);
    }
  }
};

async function updateSpec(pack, specName, specVersion) {
  let templateInfo = pack.templateInfo;
  let spec = templateInfo.specList.find((it) => it.name === specName);
  if (!spec) templateInfo.specList.push((spec = { name: specName }));
  spec.version = specVersion;
  let newSpec = templateInfo.toString();
  if (newSpec !== pack.get().spec) {
    pack.merge({ spec: newSpec });
    await pack.save();
  }
}

async function listAvailableVersions(module) {
  let result;
  let child = child_process.spawn("npm", ["show", module, "versions", "--json", "--no-workspaces"], {
    shell: true,
    stdio: ["ignore", "pipe", "pipe"],
  });
  let stdoutChunks = [];
  let stderrChunks = [];
  child.stdout.on("data", (chunk) => stdoutChunks.push(chunk));
  child.stderr.on("data", (chunk) => stderrChunks.push(chunk));
  let promise = new Promise((resolve, reject) => child.on("close", (code) => (code ? reject() : resolve())));
  let error;
  try {
    await promise;
    let stdout = Buffer.concat(stdoutChunks).toString();
    result = stdout ? JSON.parse(stdout) : [];
  } catch (e) {
    error = e;
    if (!error) {
      let stdout = Buffer.concat(stdoutChunks).toString();
      if (stdout && stdout.startsWith("{")) {
        let npmJson;
        try {
          npmJson = JSON.parse(stdout);
        } catch (e) {
          // ignore
        }
        let message = npmJson?.error?.summary;
        if (message) error = new Error(message);
      }
    }
  }
  let stderr = Buffer.concat(stderrChunks).toString();
  if (error || stderr) {
    console.warn(
      `WARN Unable to find out available versions for ${module} - skipping. Cause:\n${error ? "  " + error : stderr}`,
    );
    result = [];
  }
  return result;
}

function getDevkitPlugins(pack = Package.getSingletonSync()) {
  let devDependencies = pack.get().devDependencies;
  let pluginNames = Object.keys(devDependencies || {}).filter(
    (name) => name.includes("devkit") && /g\d\d/.test(name) && name !== "uu_appg01_devkit",
  );
  return pluginNames;
}

function requireOptionalPackageJson(module) {
  try {
    let path = require.resolve(module + "/package.json", { paths: ["."] });
    return require(path);
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND") throw e;
    return;
  }
}
