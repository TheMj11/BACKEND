"use strict";

const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, InvalidRevision, ObjectNotFound } = require("uu_appg01_objectstore");

const ASID = Config.get("asid");
const UU_APP_METRICS_ENABLED = Config.getBoolean("uu_app_metrics_enabled");

const SYNC_PERIOD_MS_PARAM = "uu_app_metrics_sync_period_ms";
const SYNC_PERIOD_MS_DEFAULT = 10000;
const SYNC_PERIOD_MS = Config.getNumber(SYNC_PERIOD_MS_PARAM) || SYNC_PERIOD_MS_DEFAULT;
const UU_IDENTITY_MAX_COUNT = 100000;

const LOGGER = LoggerFactory.get();

class AppStatusMetrics {
  constructor() {
    if (UU_APP_METRICS_ENABLED) {
      const { MeterProviderFactory, SyncingMetricAccumulator } = require("uu_app_metricsg01");
      const meterProvider = MeterProviderFactory.get();

      let uuAwsUseCaseMeter = meterProvider.getMeter("uuAwsUseCase");
      let uuAsidUseCaseMeter = meterProvider.getMeter("uuAsidUseCase");
      let uuAwsAuthnMeter = meterProvider.getMeter("uuAwsAuthn");
      this._awsMetricAccumulator = new SyncingMetricAccumulator(uuAwsUseCaseMeter, "CallCount");
      this._asidMetricAccumulator = new SyncingMetricAccumulator(uuAsidUseCaseMeter, "CallCount");
      this._uuIdentityOtherCount = uuAwsAuthnMeter.getInstrument("uuIdentityOtherCount");
      this._awidIdentityMap = new Map();
      this._awidIdentityPeriodMap = new Map();
      this._totalAwidIdentityPeriodMap = new Map();
      this._lastAddTime = null;
      this._dao = DaoFactory.getDao("sysUuIdentityStats");

      const uuIdentityCountPm = uuAwsAuthnMeter.getInstrument("uuIdentityCountPm");
      const uuIdentityCountPh = uuAwsAuthnMeter.getInstrument("uuIdentityCountPh");
      const uuIdentityCountPd = uuAwsAuthnMeter.getInstrument("uuIdentityCountPd");
      const uuIdentityCountPw = uuAwsAuthnMeter.getInstrument("uuIdentityCountPw");
      const uuIdentityCountPmo = uuAwsAuthnMeter.getInstrument("uuIdentityCountPmo");
      const uuIdentityCountPmTotal = uuAwsAuthnMeter.getInstrument("uuIdentityCountPmTotal");
      const uuIdentityCountPhTotal = uuAwsAuthnMeter.getInstrument("uuIdentityCountPhTotal");
      const uuIdentityCountPdTotal = uuAwsAuthnMeter.getInstrument("uuIdentityCountPdTotal");
      const uuIdentityCountPwTotal = uuAwsAuthnMeter.getInstrument("uuIdentityCountPwTotal");
      const uuIdentityCountPmoTotal = uuAwsAuthnMeter.getInstrument("uuIdentityCountPmoTotal");

      uuAwsAuthnMeter.addBatchObservableCallback(
        (batchObservableResult) => {
          for (const [awid, uuIdentityPeriodCountList] of this._awidIdentityPeriodMap) {
            batchObservableResult.observe(uuIdentityCountPm, uuIdentityPeriodCountList[0], { awid });
            batchObservableResult.observe(uuIdentityCountPh, uuIdentityPeriodCountList[1], { awid });
            batchObservableResult.observe(uuIdentityCountPd, uuIdentityPeriodCountList[2], { awid });
            batchObservableResult.observe(uuIdentityCountPw, uuIdentityPeriodCountList[3], { awid });
            batchObservableResult.observe(uuIdentityCountPmo, uuIdentityPeriodCountList[4], { awid });
          }
          for (const [awid, uuIdentityPeriodCountList] of this._totalAwidIdentityPeriodMap) {
            batchObservableResult.observe(uuIdentityCountPmTotal, uuIdentityPeriodCountList[0], { awid });
            batchObservableResult.observe(uuIdentityCountPhTotal, uuIdentityPeriodCountList[1], { awid });
            batchObservableResult.observe(uuIdentityCountPdTotal, uuIdentityPeriodCountList[2], { awid });
            batchObservableResult.observe(uuIdentityCountPwTotal, uuIdentityPeriodCountList[3], { awid });
            batchObservableResult.observe(uuIdentityCountPmoTotal, uuIdentityPeriodCountList[4], { awid });
          }
        },
        [
          uuIdentityCountPm,
          uuIdentityCountPh,
          uuIdentityCountPd,
          uuIdentityCountPw,
          uuIdentityCountPmo,
          uuIdentityCountPmTotal,
          uuIdentityCountPhTotal,
          uuIdentityCountPdTotal,
          uuIdentityCountPwTotal,
          uuIdentityCountPmoTotal,
        ],
      );

      const runSync = () => {
        this._synchronize()
          .catch((e) => LOGGER.error(`Synchronisation of uuAppMetrics failed.`, e))
          .finally(() => {
            setTimeout(runSync, SYNC_PERIOD_MS);
          });
      };

      runSync();
    }
  }

  record(resData) {
    if (UU_APP_METRICS_ENABLED) {
      this._awsMetricAccumulator.add(1, { awid: resData.awid });
      this._asidMetricAccumulator.add(1, { asid: ASID });

      const now = new Date();
      let resetValue;
      if (this._awidIdentityMap.size > UU_IDENTITY_MAX_COUNT) {
        LOGGER.warn(
          `The maximum number of uuIdentities (${UU_IDENTITY_MAX_COUNT}) has been exceeded.` +
          " Resetting local uuIdentity counters to avoid memory overflow."
        );
        resetValue = 0;
      }
      resetValue ??= this._getResetValue(now, this._lastAddTime);
      if (resetValue !== null) {
        this._reset(resetValue);
      }

      if (resData.uuId) {
        const key = `${resData.awid}.${resData.uuId}`;
        const value = this._awidIdentityMap.get(key);

        if (value === 31) {
          return;
        } else if (value) {
          let periodList = this._awidIdentityPeriodMap.get(resData.awid);
          if (value <= 15) periodList[0]++;
          if (value <= 7) periodList[1]++;
          if (value <= 3) periodList[2]++;
          if (value <= 1) periodList[3]++;
        } else {
          let periodList = this._awidIdentityPeriodMap.get(resData.awid);
          if (!periodList) {
            this._awidIdentityPeriodMap.set(resData.awid, [1, 1, 1, 1, 1]);
          } else {
            periodList.forEach((_, index) => periodList[index]++);
          }
        }

        this._awidIdentityMap.set(key, 31);
      }

      this._lastAddTime = now;
    }
  }

  getAwsMetricAccumulator() {
    return this._awsMetricAccumulator;
  }

  getAsidMetricAccumulator() {
    return this._asidMetricAccumulator;
  }

  _reset(resetValue) {
    if (resetValue === 0) {
      this._awidIdentityMap.clear();
      this._awidIdentityPeriodMap.clear();
    } else if (resetValue !== null) {
      this._awidIdentityMap.forEach((value, key) => {
        if (value !== (value &= resetValue)) {
          this._awidIdentityMap.set(key, value);
        }
      });
      this._awidIdentityPeriodMap.forEach((periodList) => {
        if (resetValue <= 15) periodList[0] = 0;
        if (resetValue <= 7) periodList[1] = 0;
        if (resetValue <= 3) periodList[2] = 0;
        if (resetValue <= 1) periodList[3] = 0;
      });
    }
  }

  async _synchronize() {
    let sharedMetrics;
    let lastError;

    let tries = 0;
    const maxTries = 5;
    do {
      const now = new Date();
      const localResetValue = this._getResetValue(now, this._lastAddTime);
      if (localResetValue !== null) {
        this._reset(localResetValue);
        this._lastAddTime = now;
      }

      sharedMetrics = await this._dao.getByAsid(ASID);
      const shouldCreate = !sharedMetrics;
      sharedMetrics ||= { awidMap: {} };

      let uuIdentityCount = 0;
      const resetValue = this._getResetValue(now, sharedMetrics.sys?.mts);
      if (resetValue === 0) {
        sharedMetrics.awidMap = {};
      } else if (resetValue !== null) {
        Object.values(sharedMetrics.awidMap).forEach((uuIdentityMap) => {
          const uuIdentityList = Object.keys(uuIdentityMap);
          uuIdentityList.forEach((uuIdentity) => {
            uuIdentityMap[uuIdentity] &= resetValue;
          });
          uuIdentityCount += uuIdentityList.length;
        });
      } else {
        Object.values(sharedMetrics.awidMap).forEach((uuIdentityMap) => {
          uuIdentityCount += Object.keys(uuIdentityMap).length;
        });
      }

      this._awidIdentityMap.forEach((value, key) => {
        const [awid, uuIdentity] = key.split(".");
        if (sharedMetrics.awidMap[awid]) {
          sharedMetrics.awidMap[awid][uuIdentity] |= value;
        } else {
          sharedMetrics.awidMap[awid] = { [uuIdentity]: value };
          uuIdentityCount++;
        }
      });

      let uuIdentityDeletedCount = 0;
      if (uuIdentityCount > UU_IDENTITY_MAX_COUNT) {
        sharedMetrics.awidMap = Object.entries(sharedMetrics.awidMap)
          .flatMap(([awid, uuIdentityMap]) => {
            return Object.entries(uuIdentityMap).map(([uuIdentity, value]) => {
              return [`${awid}.${uuIdentity}`, value];
            });
          })
          .sort((a, b) => b[1] - a[1])
          .splice(0, UU_IDENTITY_MAX_COUNT * 0.8)
          .reduce((awidMap, [key, value]) => {
            const [awid, uuIdentity] = key.split(".");
            awidMap[awid] ? (awidMap[awid][uuIdentity] = value) : (awidMap[awid] = { [uuIdentity]: value });
            return awidMap;
          }, {});
          uuIdentityDeletedCount = uuIdentityCount - (UU_IDENTITY_MAX_COUNT * 0.8);
      }

      try {
        shouldCreate ? await this._dao.create(sharedMetrics) : await this._dao.replaceByAsid(sharedMetrics, now);
        if (uuIdentityDeletedCount) {
          this._uuIdentityOtherCount.record(uuIdentityDeletedCount, { asid: ASID });
          LOGGER.info(
            "Maximum number of uuIdentities reached. " +
            `${uuIdentityDeletedCount} uuIdentities moved to uuIdentityOtherCount metric.`
          );
        }
      } catch (e) {
        if (e instanceof ObjectNotFound || e instanceof InvalidRevision) {
          lastError = e;
        } else {
          throw e;
        }
      }

      break;
    } while (++tries < maxTries);

    let periodMap = new Map();

    if (tries < maxTries) {
      Object.entries(sharedMetrics.awidMap).forEach(([awid, uuIdentityMap]) => {
        Object.values(uuIdentityMap).forEach((value) => {
          if (periodMap.has(awid)) {
            this._updatePeriodList(periodMap.get(awid), value);
          } else {
            let periodList = [0, 0, 0, 0, 0];
            this._updatePeriodList(periodList, value);
            periodMap.set(awid, periodList);
          }
        });
      });
      this._totalAwidIdentityPeriodMap = periodMap;
    } else {
      LOGGER.error(`Synchronisation of uuAppMetrics failed after ${tries} tries.`, lastError);
    }
  }

  _getResetValue(now, lastUpdateDate) {
    if (!lastUpdateDate) return null;

    if (now.getMonth() !== lastUpdateDate.getMonth()) return 0;
    if (!this._doesWeekMatch(now, lastUpdateDate)) return 1;
    if (now.getDay() !== lastUpdateDate.getDay()) return 3;
    if (now.getUTCHours() !== lastUpdateDate.getUTCHours()) return 7;
    if (now.getMinutes() !== lastUpdateDate.getMinutes()) return 15;

    return null;
  }

  _doesWeekMatch(date1, date2) {
    let weekStart1 = new Date(date1);
    weekStart1.setDate(date1.getDate() - ((date1.getDay() - 1 + 7) % 7));

    let weekStart2 = new Date(date2);
    weekStart2.setDate(date2.getDate() - ((date2.getDay() - 1 + 7) % 7));

    return weekStart1.getDate() === weekStart2.getDate();
  }

  _updatePeriodList(periodList, value) {
    if (!value) return;
    if (value >= 31) periodList[0]++;
    if (value >= 15) periodList[1]++;
    if (value >= 7) periodList[2]++;
    if (value >= 3) periodList[3]++;
    if (value >= 1) periodList[4]++;
  }
}

module.exports = new AppStatusMetrics();
