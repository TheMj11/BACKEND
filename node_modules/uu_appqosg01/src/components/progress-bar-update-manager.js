"use strict";
const { Sys } = require("uu_appg01_core-appserver");

const { UuSubAppInstance, Profile } = require("uu_appg01_workspace");

const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");
const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { AuthenticationService } = require("uu_appg01_core-authentication");
const SysQosConfigurationAbl = require("../abl/sys-qos-configuration-abl.js");
const RequestCountHandler = require("./request-count-handler.js");
const PROGRESS_BUS_LOAD = "progressBus/load";
const PROGRESS_BUS_CREATE = "progressBus/create";
const PROGRESS_CREATE = "progressBus/progress/create";
const PROGRESS_START = "progressBus/progress/start";
const PROGRESS_PROCEED = "progressBus/progress/proceed";
const LOCKSECRET = "442bce0ca09d14fdea0077895468bf38857649da8b7034338aed94f71e501bc3";
const PROGRESS_BUS_DOES_NOT_EXIST = "progressBusDoesNotExist";
const PROGRESS_DOES_NOT_EXIST = "progressDoesNotExist";
const PROGRESS_IS_NOT_IN_PROPER_STATE = "progressIsNotInProperState";
const APP_QOS = "uuAppQoS";
const APP_QOS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME = "uu_app_qos_progress_expire_period_ms";
const APP_QOS_PROGRESS_EXPIRE_PERIOD_DEFAULT_VALUE = 60 * 60 * 1000;
const DEFAULT_AUTHZ_STRATEGY = "artifact";
// maps standard asid profiles to corresponding console progress(Bus) profiles
// if multiple profiles are mapped to the same console progress profile, the first one is used
const AUTHZ_ASID_PROFILE_MAP = {
  AsidAuthorities: "Authorities",
  AsidExecutives: "Writers",
  AsidAuditors: "Readers",
};
const AUTHZ_REQUIRED_PROFILES = ["Authorities", "Writers"];
const PROGRESS_STATES = ["waiting", "completed", "completedWithWarning", "completedWithError"];
const DEFAULT_STATE = "running";
const SPP_DEFAULT = "";
const LOGGER = LoggerFactory.get("uuapp.qos.RateLimiting");
const APPINFO = Sys.getAppInfo();
const PROGRESS_DELAY_WARNING = 15;
const PROGRESS_DELAY_ERROR = 30;

class ProgressBarUpdateManager {
  // 4.1.2. is unclear
  constructor() {
    this.asid = Config.get("asid");
    // System sets nodeName from environment (nodeName format example:   "nodeName": "uuappg01_async-uu_script_engineg02_async-1617198494548.1.nkvnwdhr0k5w5pvcw5x2vsfpj"),
    this.nodeName =
      typeof process.env.UU_CLOUD_NODE_NAME !== "undefined"
        ? process.env.UU_CLOUD_NODE_NAME
        : `uuappg01-${APPINFO.uuSubApp.replace("-server", "")}-${new Date().getTime()}.1.${new Date().getTime()}`;
    // System sets spp
    this.spp =
      this.nodeName.split("-")[1] !== APPINFO.uuSubApp.replace("-server", "")
        ? this.nodeName.split("-")[1].slice(this.nodeName.split("-")[1].lastIndexOf("_") + 1)
        : SPP_DEFAULT;
    // System sets progressCode
    const progressCodePostfix = this.nodeName.split("-")[2].replace(/\./g, "_");
    this.progressCode = `${APP_QOS}_${progressCodePostfix}`;
    this.nodeNumber = progressCodePostfix.split("_")[1];
    this.progressName = this.spp === SPP_DEFAULT ? `node ${this.nodeNumber}` : `${this.spp} - node ${this.nodeNumber}`;

    this.uuSubAppName = ProgressBarUpdateManager._getSubAppName();
    this.progressBusName = `${this.uuSubAppName} - ${this.asid}`;
  }

  async updateProgress(indicationData = {}, uuAppErrorMap = {}) {
    let date = new Date();
    let estimatedNextProgressTs = new Date(date.getTime());
    estimatedNextProgressTs.setSeconds(
      estimatedNextProgressTs.getSeconds() + SysQosConfigurationAbl.getProgressUpdatePeriod()
    );
    let quota = await SysQosConfigurationAbl.getConfiguration();
    let proceedData = {
      limitError: quota.totalLimitError,
      counterResetTimeInterval: quota.counterResetTimeInterval,
    };
    let proceedDtoIn = this._composeProceedDtoIn(
      this.uuSubAppName,
      proceedData,
      this.progressCode,
      indicationData,
      estimatedNextProgressTs,
      uuAppErrorMap
    );
    let progressBaseUri = UriBuilder.parse(quota.progressBaseUri);
    await this._updateProgress(progressBaseUri, proceedDtoIn);
  }

  isConsoleUriConfigured() {
    return !!(SysQosConfigurationAbl.getProgressBaseUri() && SysQosConfigurationAbl.getProgressUpdateEnabled());
  }

  async _updateProgress(progressBaseUri, proceedDtoIn) {
    let session = await AuthenticationService.authenticate({ systemIdentity: this.asid });
    try {
      let appClient = new AppClient({ baseUri: progressBaseUri });
      await appClient.post(PROGRESS_PROCEED, proceedDtoIn, { session });
    } catch (e) {
      if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
        LOGGER.error(this._getAuthorizationErrorMessage(progressBaseUri, session, "Failed to update progress."));
        return;
      }
      await this._runAlternativeScenario(e, session, progressBaseUri, proceedDtoIn);
    }
  }

  _composeProceedDtoIn(
    uuSubAppName,
    proceedData,
    progressCode,
    indicationData,
    estimatedNextProgressTs,
    uuAppErrorMap
  ) {
    let counter = RequestCountHandler.getCounter;
    let data = {
      uuSubAppName,
      uuSubAppVersion: APPINFO.uuSubAppVersion,
      nodeName: this.nodeName,
      spp: this.spp,
      asid: this.asid,
      uuAppErrorMap,
    };
    data = { ...data, ...RequestCountHandler.getCounterHistory };

    return {
      code: progressCode,
      estimatedNextProgressTs: estimatedNextProgressTs.toISOString(),
      delayWarning: PROGRESS_DELAY_WARNING,
      delayError: PROGRESS_DELAY_ERROR,
      lockSecret: LOCKSECRET,
      message: indicationData.message,
      totalWork: proceedData.limitError,
      doneWork: counter.total,
      state: indicationData.state || DEFAULT_STATE,
      expireAt: this._getExpirationTime(),
      data,
    };
  }

  async _runAlternativeScenario(error, session, progressBaseUri, proceedDtoIn) {
    // System checks if progressDoesNotExist or progressIsNotInProperState error occured and procceses it
    if (error.code && error.code.endsWith(PROGRESS_DOES_NOT_EXIST)) {
      LOGGER.debug(`Progress with code ${proceedDtoIn.code} doesn't exist. Creating...`);

      //System prepares progressCreateDtoIn
      let progressCreateDtoIn = {
        code: proceedDtoIn.code,
        progressBusCode: SysQosConfigurationAbl.getProgressBusCode(),
        name: this.progressName,
        expireAt: this._getExpirationTime(),
      };
      //node number 1 in each nodeSet checks if exist progressBus
      if (this.nodeNumber === "1") {
        // System tries to get progressBus
        try {
          // System sets use case to progressBus/load
          let appClient = new AppClient({ baseUri: progressBaseUri });
          // System loads progressBus using AppClient with session from HDS 4.
          await appClient.get(
            PROGRESS_BUS_LOAD,
            { code: SysQosConfigurationAbl.getProgressBusCode() },
            { session }
          );
        } catch (e) {
          // progressBus/load failed
          await this._createProgressBus(e, session, progressBaseUri);
        }
      }
      // System sets progress/create use case
      // System tries to create new progress
      try {
        let appClient = new AppClient({ baseUri: progressBaseUri });
        await appClient.post(PROGRESS_CREATE, progressCreateDtoIn, { session });
      } catch (e) {
        if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
          LOGGER.error(this._getAuthorizationErrorMessage(progressBaseUri, session, "Failed to create progress."));
          return;
        } else {
          LOGGER.error(`Failed to create progress:`, e);
        }
      }
      await this._startAndProceedProgress(progressBaseUri, proceedDtoIn, session);
    } else if (error.code && error.code.endsWith(PROGRESS_IS_NOT_IN_PROPER_STATE)) {
      // If e.paramMap.state exist and is in one of the state "waiting", "completed", "completedWithWarning" or "completedWithError"
      if (error.paramMap && error.paramMap.state && PROGRESS_STATES.includes(error.paramMap.state)) {
        await this._startAndProceedProgress(progressBaseUri, proceedDtoIn, session);
      }
    } else {
      LOGGER.error(`Progress proceed failed: `, error);
    }
  }

  async _createProgressBus(error, session, progressBaseUri) {
    if (error.code && error.code.endsWith(PROGRESS_BUS_DOES_NOT_EXIST)) {
      LOGGER.debug(`ProgressBus with code ${SysQosConfigurationAbl.getProgressBusCode()} doesn't exist. Creating...`);

      // System prepares progressBusCreateDtoIn
      const authorizationStrategy = await this._getAuthorizationStategy();
      let progressBusCreateDtoIn = {
        code: SysQosConfigurationAbl.getProgressBusCode(),
        name: this.progressBusName,
        maxNumberOfProgressItems: SysQosConfigurationAbl.getProgressItemsMaxCount(),
        data: {
          uuSubAppName: this.uuSubAppName,
          uuSubAppVersion: APPINFO.uuSubAppVersion,
          asid: this.asid,
        },
        ...authorizationStrategy,
      };
      // System sets use case to progressBus/create;
      // System tries to create progressBus
      try {
        let appClient = new AppClient({ baseUri: progressBaseUri });
        await appClient.post(PROGRESS_BUS_CREATE, progressBusCreateDtoIn, { session });
      } catch (e) {
        if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
          LOGGER.error(this._getAuthorizationErrorMessage(progressBaseUri, session, "Failed to create progressBus."));
          return;
        }
        LOGGER.error(`ProgressBus create failed: `, e);
      }
    } else {
      LOGGER.error(`ProgressBus load failed: `, error);
    }
  }

  async _startAndProceedProgress(progressBaseUri, proceedDtoIn, session) {
    // System prepares progressStartDtoIn
    let progressStartDtoIn = {
      code: proceedDtoIn.code,
      lockSecret: LOCKSECRET,
    };
    // System sets progress/start use case
    // System tries to start progress
    try {
      let appClient = new AppClient({ baseUri: progressBaseUri });
      await appClient.post(PROGRESS_START, progressStartDtoIn, { session });
    } catch (e) {
      LOGGER.error(`Progress start failed: `, e);
      return;
    }
    // System sets progress/proceed use case
    // System tries to proceed progress
    try {
      let appClient = new AppClient({ baseUri: progressBaseUri });
      await appClient.post(PROGRESS_PROCEED, proceedDtoIn, { session });
    } catch (e) {
      LOGGER.error(`Progress proceed failed: `, e);
    }
  }

  static _getSubAppName() {
    return APPINFO.uuSubApp
      .split("_")
      .map((s, i) => (i === 0 ? s : s && s[0].toUpperCase() + s.slice(1)))
      .join("")
      .replace("-server", "");
  }

  /**
   * Loads and maps subAppInstance authorization strategy to corresponding progress authorization strategy
   * This allows AsidAuthorities, AsidExecutives and AsidAuditors to inherit casts from subApp as progress(Bus) Authorities, Writers, etc.
   * @returns {Promise<{authorizationStrategy: string}>}
   */
   async _getAuthorizationStategy() {
    const DEFAULT_AUTHZ_FALLBACK = { authorizationStrategy: DEFAULT_AUTHZ_STRATEGY };

    let subAppInstance;
    try {
      subAppInstance = await UuSubAppInstance.get(this.asid);
    } catch (e) {
      LOGGER.warn(
        `UuSubAppInstance get for the current asid (${this.asid}) failed. Progress will use default authz strategy: `,
        e
      );
      subAppInstance = {};
    }
    const authorizationData = subAppInstance.authorizationData;

    const mapAsidProfilesToConsoleProfiles = (profileList) =>
      profileList
        .filter((profile) => Object.keys(AUTHZ_ASID_PROFILE_MAP).includes(profile))
        .map((profile) => AUTHZ_ASID_PROFILE_MAP[profile]);
    const getMissingProfiles = (profileList) =>
      AUTHZ_REQUIRED_PROFILES.filter((profile) => !profileList.includes(profile));

    const logMissingProfiles = (missingConsoleProfiles, authStrategy) => {
      LOGGER.warn(
        `Current asid (${
          this.asid
        }) is set to ${authStrategy} authorization strategy, but is missing profiles that map to these required progress profiles: ${missingConsoleProfiles.join(
          ", "
        )}. Progress will use default authz strategy.`
      );
    };

    switch (subAppInstance.authorizationStrategy) {
      // maps subAppInstance bound artifact asid profiles to console profiles
      case "boundArtifact": {
        const boundArtifactInfo = authorizationData.boundArtifact;

        let params = {};
        if (boundArtifactInfo.boundArtifactId) params.id = boundArtifactInfo.boundArtifactId;
        if (boundArtifactInfo.boundArtifactCode) params.code = boundArtifactInfo.boundArtifactCode;

        const boundArtifactUri = UriBuilder.parse(boundArtifactInfo.uuTerritoryBaseUri)
          .setUseCase("userGate/artifact")
          .setParameters(params)
          .toUri()
          .toString();
        const boundArtifactPermissionMatrix = { ...authorizationData.boundArtifact.boundArtifactProfileMap };
        for (const boundProfile in boundArtifactPermissionMatrix) {
          const profileList = mapAsidProfilesToConsoleProfiles(boundArtifactPermissionMatrix[boundProfile]);
          if (profileList.length === 0) {
            delete boundArtifactPermissionMatrix[boundProfile];
          } else {
            boundArtifactPermissionMatrix[boundProfile] = profileList;
          }
        }

        // check that all required console profiles are present
        const missingConsoleProfiles = getMissingProfiles(Object.values(boundArtifactPermissionMatrix).flat());
        if (missingConsoleProfiles.length > 0) {
          logMissingProfiles(missingConsoleProfiles, "boundArtifact");
          return DEFAULT_AUTHZ_FALLBACK;
        }

        return {
          authorizationStrategy: "boundArtifact",
          boundArtifactUri,
          boundArtifactPermissionMatrix,
        };
      }

      // maps subAppInstance uuIdentity profiles to console profiles
      case "uuIdentityList": {
        const permissionMap = { ...authorizationData.uuIdentityList.permissionMap };
        for (const uuIdentity in permissionMap) {
          const profileList = mapAsidProfilesToConsoleProfiles(permissionMap[uuIdentity]);
          if (profileList.length === 0) {
            delete permissionMap[uuIdentity];
          } else {
            permissionMap[uuIdentity] = profileList;
          }
        }

        // check that all required console profiles are present
        const missingConsoleProfiles = getMissingProfiles(Object.values(permissionMap).flat());
        if (missingConsoleProfiles.length > 0) {
          logMissingProfiles(missingConsoleProfiles, "uuIdentityList");
          return DEFAULT_AUTHZ_FALLBACK;
        }

        return {
          authorizationStrategy: "uuIdentityList",
          permissionMap,
        };
      }

      // maps asid-prefixed roleGroups to console profiles
      case "roleGroupInterface": {
        // gather roleGroup uris for asid roleGroups
        let asidAuthorizationUris = {};
        for (const asidProfileName in AUTHZ_ASID_PROFILE_MAP) {
          const asidProfile = (await Profile.get(this.asid, asidProfileName).catch()) || {};
          if (asidProfile.roleGroupUri) {
            asidAuthorizationUris[asidProfileName] = asidProfile.roleGroupUri;
          }
        }

        // check that all required console profiles are present
        const missingConsoleProfiles = getMissingProfiles(
          Object.keys(asidAuthorizationUris).map((asidProfileName) => AUTHZ_ASID_PROFILE_MAP[asidProfileName])
        );
        if (missingConsoleProfiles.length > 0) {
          logMissingProfiles(missingConsoleProfiles, "roleGroupInterface");
          return DEFAULT_AUTHZ_FALLBACK;
        }

        return {
          authorizationStrategy: "roleGroupInterface",
          authorizationUriMap: Object.fromEntries(
            Object.entries(asidAuthorizationUris)
              .reverse() // last profile in the list has precedence
              .map(([profileName, roleGroupUri]) => [AUTHZ_ASID_PROFILE_MAP[profileName], roleGroupUri])
          ),
        };
      }

      // fallback artifact authorization
      default:
        return DEFAULT_AUTHZ_FALLBACK;
    }
  }

  _getAuthorizationErrorMessage(progressBaseUri, session, msg) {
    return (
      msg +
      " User " +
      session.getIdentity().getUuIdentity() +
      " doesn't have permission to call " +
      progressBaseUri.toString() +
      " with code " +
      this.progressCode +
      ". Please configure permissions properly."
    );
  }

  _getExpirationTime() {
    let date = new Date();
    let expireAt = new Date(date.getTime());
    let progressExpirePeriod = Config.get(APP_QOS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME)
      ? Config.getNumber(APP_QOS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME)
      : APP_QOS_PROGRESS_EXPIRE_PERIOD_DEFAULT_VALUE;
    expireAt.setTime(expireAt.getTime() + progressExpirePeriod);
    return expireAt.toISOString();
  }
}

module.exports = new ProgressBarUpdateManager();
