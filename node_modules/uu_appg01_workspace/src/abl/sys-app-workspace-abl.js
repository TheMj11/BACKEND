"use strict";

const fs = require("fs");
const path = require("path");
const { Config, Finder, LruCache } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ObjectStoreError, ObjectNotFound, Lock } = require("uu_appg01_objectstore");
const { ValidationHelper, MappingsLoader, PackagesHelper } = require("uu_appg01_core-appserver");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");

const SysProfile = require("./sys-profile-abl");
const SysPermission = require("./sys-permission-abl");
const SysAppInstance = require("./sys-app-instance-abl");
const SysAppClientTokenAbl = require("./sys-app-client-token-abl");
const SysDataStoreStats = require("./sys-app-data-store-stats-abl");
const ProfileConfig = require("../helpers/profile-config.js");
const Errors = require("../api/errors/sys-app-workspace-errors.js");
const OidcClientHelper = require("../helpers/oidc-client-helper");
const UuCmdHelper = require("../helpers/uu-cmd-helper");
const AuthorizeHelper = require("../helpers/authorize-helper.js");
const SysAppSecretStoreAbl = require("./sys-app-secret-store-abl");

const LogStoreService = require("../helpers/log-store-service");
const LogStoreUtils = require("../helpers/log-store-helper");
const LogStoreServiceErrors = require("../api/errors/log-store-service-errors");

const WorkspaceLicenseService = require("../workspace-license-service.js");

const ART_AUTHZ_TYPE = "artifact";
const APP_WORKSPACE_CACHE_TTL_CONFIG_NAME = "uu_app_workspace_app_workspace_cache_ttl";
const APP_WORKSPACE_CACHE_TTL_DEFAULT_VALUE = 1000 * 60 * 5;
const SYS_APP_WORKSPACE_VERSION = "3.0";
const DEFAULT_MAX_NOA = 1000;
const ROLE_GROUP_INTERFACE = "roleGroupInterface";
const SECRET_SET = "uuAppOidcClientKey";
const GET_LOG_ACCESS_ATTRIBUTES_DEFAULT_TTL = 30 * 60; // 30 minutes in seconds
const NODE_MODULES = "node_modules"; // name of the node modules directory

const WARNINGS = {

  territoryDataLoad: {
    code: `${Errors.Load.UC_CODE}territoryDataLoadFailed`,
    message: "Failed to load territory data."
  },
};

/**
 * represent sysAppWorkspace collection in the database
 * and store information about workspace
 */
class SysAppWorkspaceAbl {
  constructor() {
    // Initialize cache with TTL 5 minutes if is not configured, configuration is in seconds
    let maxAge =
      Config.get(APP_WORKSPACE_CACHE_TTL_CONFIG_NAME) != null
        ? Config.getNumber(APP_WORKSPACE_CACHE_TTL_CONFIG_NAME) * 1000
        : APP_WORKSPACE_CACHE_TTL_DEFAULT_VALUE;
    this.sysAppCache = new LruCache({ maxAge });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysUuAppWorkspace");
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppWorkspaceAbl");
    this.LOCK_CODE = "sysAppInstanceInitLock";
    this.LOCK_DURATION = 60 * 5;

    const metamodelFilePattern = `metamodel_*_*.zip`;
    const rootDir = Config.get("server_root") || process.cwd();
    const metamodelPath = Finder.findConfigInProject(rootDir, `{app,src,}/config/${metamodelFilePattern}`);
    this.uuAppMetaModelVersion = metamodelPath ? metamodelPath.split("_").pop().replace(".zip", "") : null;

    this.SYS_STATES = {
      REGISTERED: "registered",
      CREATED: "created",
      ASSIGNED: "assigned",
      BEING_INITIALIZED: "beingInitialized",
      ACTIVE: "active",
      RESTRICTED: "restricted",
      READ_ONLY: "readOnly",
      SUSPENDED: "suspended",
      CLOSED: "closed",
    };

    this.asid = Config.get("asid");
  }

  /**
   * create empty collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  /**
   * creates uuAppWorkspace and sets its state to "created".
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async create({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceCreateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Create.UC_CODE}unsupportedKeys`,
      Errors.Create.InvalidDtoInError
    ); // A1, A2

    // HDS 2. Checks whether the awid can be created.
    const asid = Config.get("asid");
    let uuAppWorkspaceList = []; // is used to collect awids of already created workspaces, not used if empty
    if (dtoIn.awidList) {
      let createdWorkspaces = [];
      let oidcClientWarningMap = {};
      for (const awid of dtoIn.awidList) {
        // HDS 2.1. Checks whether the awid can be created.
        // HDS 2.1.1. AWID identificator is the same as ASID.
        if (awid === asid) {
          ValidationHelper.addWarning(
            uuAppErrorMap,
            `${Errors.Create.UC_CODE}awidConflictsWithAsid`,
            `SysUuAppWorkspace cannot be create. Awid must not be the same as asid.`,
            { asid }
          );
          continue;
        }
        // HDS 2.1.2. Checks whether AWID already exists within ASID.
        let appWorkspace = await this.dao.getByAwid(awid);
        if (appWorkspace) {
          createdWorkspaces.push(awid);
          ValidationHelper.addWarning(
            uuAppErrorMap,
            `${Errors.Create.UC_CODE}sysUuAppWorkspaceAlreadyCreated`,
            `SysUuAppWorkspace has already been created.`,
            { awidList: createdWorkspaces }
          );
          continue;
        }
        // HDS 2.2. Creates object SysUuAppWorkspace through the dao method create
        let uuObject = dtoIn;
        delete uuObject.awidList;
        uuObject.awid = awid;
        uuObject.sysState = this.SYS_STATES.CREATED;
        uuObject.version = SYS_APP_WORKSPACE_VERSION;
        let createdWorkspace;
        try {
          createdWorkspace = await this.createUuObject(uuObject);
          uuAppWorkspaceList.push(createdWorkspace);
        } catch (e) {
          throw new Errors.Create.SysUuAppWorkspaceDaoCreateFailedError({ uuAppErrorMap }, e);
        }

        // HDS 2.3. Initializes a new key pair using AppComponent method AppClientToken.initKeys
        await SysAppClientTokenAbl.initKeys(awid);

        // HDS 2.4. If the application is started in production mode, the OIDC client is initialized using the uuCmd oidc/initOidcClient
        let oidcClientUuAppErrorMap = {};
        await OidcClientHelper.initOidcClient(awid, oidcClientUuAppErrorMap, this.logger);
        if (Object.keys(oidcClientUuAppErrorMap).length) {
          oidcClientWarningMap[awid] = oidcClientUuAppErrorMap;
        }
      }

      // HDS 3. Adds any warnings from OIDC client initialization to uuAppErrorMap
      if (Object.keys(oidcClientWarningMap).length) {
        ValidationHelper.addWarning(
          uuAppErrorMap,
          `${Errors.Create.UC_CODE}initializationOfOidcClientFailed`,
          "Implicit initialization of OidcClient failed for some awids.",
          oidcClientWarningMap,
        );
      }

      // HDS 4. Returns properly filled dtoOut.
      return { uuAppWorkspaceList, ...{ uuAppErrorMap } };
    }

    // HDS 4. Processees deprecated logic of assigning awid to awidLicenceOwner if it was entered in dtoIn for backwards compatibility.
    if (dtoIn.awid && dtoIn.awidLicenseOwnerList && dtoIn.awidLicense) {
      // HDS 4.A.1. Creates object SysUuAppWorkspace through the dao method create
      const awid = dtoIn.awid;

      let appWorkspace = await this.dao.getByAwid(awid);
      if (appWorkspace) {
        throw new Errors.Create.SysUuAppWorkspaceAlreadyCreated({ uuAppErrorMap }, { awid });
      }

      let uuObject = dtoIn;
      if (uuObject.adviceNote) {
        uuObject = UuCmdHelper.fillAdviceNote(uuObject, uuIdentity);
      }
      uuObject.sysState = this.SYS_STATES.CREATED;
      uuObject.version = SYS_APP_WORKSPACE_VERSION;
      let createdWorkspace;
      try {
        createdWorkspace = await this.createUuObject(uuObject);
      } catch (e) {
        throw new Errors.Create.SysUuAppWorkspaceDaoCreateFailedError({ uuAppErrorMap }, e);
      }

      // HDS 4.A.2. - Creates the SysProfile uuObject for each profile from the profileList defined in profiles.json.
      let profileCodes = ProfileConfig.getProfiles();
      try {
        await SysProfile.initProfiles(awid, profileCodes);
      } catch (e) {
        if (e instanceof ObjectStoreError) {
          throw new Errors.Create.SysProfileDaoCreateFailedError({ uuAppErrorMap }, e);
        }
        throw e;
      }
      // HDS 4.A.3.A - Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
      try {
        await SysDataStoreStats.create(awid);
      } catch (e) {
        throw new Errors.Create.SysUuAppWorkspaceDataStoreStatsDaoCreateFailedError({ uuAppErrorMap }, e);
      }

      // HDS 4.A.3.B Initializes a new key pair using AppComponent method AppClientToken.initKeys

      await SysAppClientTokenAbl.initKeys(awid); // A16

      // HDS 4.A.4. - If the application is started in production mode, the OIDC client is initialized using the uuCmd oidc/initOidcClient
      await OidcClientHelper.initOidcClient(awid, uuAppErrorMap, this.logger); // A17

      // HDS 4. - Returns properly filled out dtoOut.
      let dtoOut = {
        ...createdWorkspace,
        ...{ uuAppErrorMap },
      };
      return dtoOut;
    }
  }

  /**
   * assigns available uuAppWorkspace with selected licence to awidLicenceOwners and sets it to "assigned" state.
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async assign({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceAssignDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Assign.UC_CODE}unsupportedKeys`,
      Errors.Assign.InvalidDtoInError
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.

    // HDS 2.A - awid is specified in dtoIn
    let awid = dtoIn.awid;

    let appWorkspace;

    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);
    if (awid) {
      appWorkspace = await this.dao.getByAwid(awid);
      if (!appWorkspace) {
        throw new Errors.Assign.sysUuAppWorkspaceNotCreated({ uuAppErrorMap }, { awid });
      }
      if (appWorkspace) {
        if (appWorkspace.sysState !== this.SYS_STATES.CREATED) {
          // A8
          throw new Errors.Assign.sysUuAppWorkspaceAlreadyAssigned({ uuAppErrorMap }, { awid });
        } else if (appWorkspace.awidLicenseOwnerList) {
          throw new Errors.Assign.sysUuAppWorkspaceNotAvailable({ uuAppErrorMap });
        }
        await this.dao.lockOne(awid, lock);
      }
    } else {
      // HDS 2.B. Lists awids in created state through DAO listBySysStateListAndAwidList and loads the first avalable awid and locks it
      this.logger.debug("Awid wasn't set in dtoIn, looking for workspace in 'created' state");
      const appWorkspaceList = await this.dao.listByStateListAndAwidList([this.SYS_STATES.CREATED]);

      appWorkspace = appWorkspaceList.itemList.find((workspace) => !workspace["awidLicenseOwnerList"]);

      if (!appWorkspace) {
        throw new Errors.Assign.sysUuAppWorkspaceNotAvailable({ uuAppErrorMap });
      }
      awid = appWorkspace.awid;
      await this.dao.lockOne(awid, lock);
      this.logger.debug(`Workspace with awid: ${awid} is about to be assigned`);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }
    appWorkspace = {
      ...appWorkspace,
      ...dtoIn,
    };
    appWorkspace.sysState = this.SYS_STATES.ASSIGNED;
    try {
      appWorkspace = await this.dao.update(appWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.Assign.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
      this._updateCache(appWorkspace);
    }

    // HDS 4. - Prepares objects on other uuSchemas for given awid.
    // HDS 4.1 - Creates the SysProfile uuObject for each profile from the profileList defined in profiles.json.
    let profileCodes = ProfileConfig.getProfiles();
    try {
      await SysProfile.initProfiles(awid, profileCodes);
    } catch (e) {
      // A13
      if (e instanceof ObjectStoreError) {
        throw new Errors.Assign.SysProfileDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // 4.2. - Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
    try {
      await SysDataStoreStats.create(awid);
    } catch (e) {
      throw new Errors.Assign.SysUuAppWorkspaceDataStoreStatsDaoCreateFailedError({ uuAppErrorMap }, e);
    }

    // HDS 5. - Returns properly filled out dtoOut.
    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * Sets available uuAppWorkspace to "assigned" state.
   * @param awid workspace identifier
   * @param dtoIn
   * @returns {Promise<*&{uuAppErrorMap: *}>}
   */
  async setAssignedSysState(awid, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetAssignedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAssignedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetAssignedSysState.InvalidDtoIn
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.
    // HDS 2.A - awid is specified in dtoIn
    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);
    if (!appWorkspace) {
      throw new Errors.SetAssignedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }
    if (appWorkspace) {
      if (appWorkspace.sysState === this.SYS_STATES.ASSIGNED) {
        // A8
        throw new Errors.SetAssignedSysState.sysUuAppWorkspaceAlreadyAssigned({ uuAppErrorMap }, { awid });
      } else if (appWorkspace.awidLicenseOwnerList) {
        throw new Errors.SetAssignedSysState.sysUuAppWorkspaceNotAvailable({ uuAppErrorMap });
      }
      await this.dao.lockOne(awid, lock);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.

    let uuAppWorkspace = {
      ...appWorkspace,
      adviceNote: dtoIn.adviceNote && Object.keys(dtoIn.adviceNote).length > 0 ? dtoIn.adviceNote : appWorkspace.adviceNote,
      sysState: this.SYS_STATES.ASSIGNED,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.SetAssignedSysState.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
    }

    this._updateCache(appWorkspace, true);

    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * Sets available uuAppWorkspace to "beingInitialized" state.
   * @param {String} awid workspace identifier
   * @param {Object} dtoIn
   * @returns {Promise<*&{uuAppErrorMap: *}>}
   */
  async setBeingInitializedSysState(awid, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetBeingInitializedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetBeingInitializedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetBeingInitializedSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be initiated.
    // HDS 2.A - awid is specified in dtoIn
    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);
    if (!appWorkspace) {
      throw new Errors.SetBeingInitializedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }
    if (appWorkspace) {
      if (appWorkspace.sysState === this.SYS_STATES.BEING_INITIALIZED) {
        // A8
        throw new Errors.SetBeingInitializedSysState.sysUuAppWorkspaceAlreadyBeingInitialized({ uuAppErrorMap }, { awid });
      }
      await this.dao.lockOne(awid, lock);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.

    let uuAppWorkspace = {
      ...appWorkspace,
      adviceNote: dtoIn.adviceNote && Object.keys(dtoIn.adviceNote).length > 0 ? dtoIn.adviceNote : appWorkspace.adviceNote,
      sysState: this.SYS_STATES.BEING_INITIALIZED,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.SetBeingInitializedSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
    }

    this._updateCache(appWorkspace);

    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * Sets available uuAppWorkspace to "created" state.
   * @param awid workspace identifier
   * @returns {Promise<*&{uuAppErrorMap: *}>}
   */
  async setCreatedSysState(awid) {
    let uuAppErrorMap = {};
    // HDS 1. - Loads uuAppWorkspace to be created.
    // HDS 1.A - awid is specified in dtoIn
    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);
    if (!appWorkspace) {
      throw new Errors.SetCreatedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }
    if (appWorkspace) {
      if (appWorkspace.sysState === this.SYS_STATES.CREATED) {
        // A8
        throw new Errors.SetCreatedSysState.sysUuAppWorkspaceAlreadyCreated({ uuAppErrorMap }, { awid });
      }
      await this.dao.lockOne(awid, lock);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) and Added Attributes and unlocks it.

    let uuAppWorkspace = {
      ...appWorkspace,
      sysState: this.SYS_STATES.CREATED,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.SetCreatedSysState.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
    }

    this._updateCache(appWorkspace);

    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * updates available uuAppWorkspace with awidInitiatorList.
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async reassign({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceReassignDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Reassign.UC_CODE}unsupportedKeys`,
      Errors.Reassign.InvalidDtoInError
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.

    // HDS 2.A - awid is specified in dtoIn
    let awid = dtoIn.awid;

    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);

    if (!appWorkspace) {
      throw new Errors.Reassign.sysUuAppWorkspaceNotCreated({ uuAppErrorMap }, { awid });
    }

    if (![this.SYS_STATES.ASSIGNED, this.SYS_STATES.ACTIVE, this.SYS_STATES.RESTRICTED].includes(appWorkspace.sysState)) {
      // A8
      throw new Errors.Reassign.AwidNotInProperState({ uuAppErrorMap }, { awid });
    }

    await this.dao.lockOne(awid, lock);

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    let uuAppWorkspace = {
      ...appWorkspace,
      ...dtoIn,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.Reassign.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
      this._updateCache(appWorkspace, true);
    }

    // HDS 6. - Returns properly filled out dtoOut.
    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * unassign available uuAppWorkspace with selected licence to awidLicenceOwners and sets it to "assigned" state.
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async unassign({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceUnassignDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Unassign.UC_CODE}unsupportedKeys`,
      Errors.Unassign.InvalidDtoInError
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.
    // HDS 2.A - awid is specified in dtoIn
    let { awid, adviceNote } = dtoIn;

    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);

    if (!appWorkspace) {
      throw new Errors.Unassign.sysUuAppWorkspaceNotCreated({ uuAppErrorMap }, { awid });
    }

    if (appWorkspace.sysState !== this.SYS_STATES.ASSIGNED) {
      // A8
      throw new Errors.Unassign.AwidNotInProperState({ uuAppErrorMap }, { awid });
    }

    await this.dao.lockOne(awid, lock);


    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes
    // specified in dtoIn and Added Attributes and unlocks it.
    if (adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    let uuAppWorkspace = {
      ...appWorkspace,
      ...dtoIn,
      sysState: this.SYS_STATES.CREATED,
      awidInitiatorList: null
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.Unassign.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
      this._updateCache(appWorkspace);
    }

    // HDS 4. - System deletes objects on other uuSchemas for given awid.
    // HDS 4.1 - Deletes the SysProfile uuObject for each profile from the profileList defined in profiles.json.
    // (DAO deleteByAwid method)

    try {
      await SysProfile.deleteAllAppProfiles(awid);
    } catch (e) {
      // A13
      if (e instanceof ObjectStoreError) {
        throw new Errors.Unassign.SysProfileDaoDeleteFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // 4.2. - Deletes the sysUuAppDataStoreStats uuObject in the uuAppObjectStore (through DAO deleteByAwid method).
    try {
      await SysDataStoreStats.delete(awid);
    } catch (e) {
      throw new Errors.Unassign.SysUuAppDataStoreStatsDaoDeleteFailed({ uuAppErrorMap }, e);
    }

    // HDS 4.3. - System deletes sysUuAppSecret uuObject in the uuAppObjectStore (through DAO deleteByAwid method).
    try {
      await SysPermission.deleteByAwid(awid);
    } catch (e) {
      throw new Errors.Unassign.SysPermissionDaoDeleteFailed({ uuAppErrorMap }, e);
    }

    // HDS 5. - System deletes sysUuAppSecret uuObject in the uuAppObjectStore (through DAO deleteByAwid method).
    try {
      await SysAppClientTokenAbl.removeKeys(awid); // A16
    } catch (e) {
      throw new Errors.Unassign.SysPermissionDaoDeleteFailed({ uuAppErrorMap }, e);
    }

    // HDS 6. - Returns properly filled out dtoOut.
    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * return licenseOwner information
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async getLicenseOwner(awid, uuAppErrorMap = {}) {
    // HDS 1. - Loads sysAppWorkspace from cache. (sysAppWorkspace DAO getByAwid) (A1, A2)
    let appWorkspace;
    try {
      appWorkspace = await this.get(awid, uuAppErrorMap);
    } catch (e) {
      // A2
      throw new Errors.SysGetLicenseOwner.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }

    // HDS 2. - Returns properly filled dtoOut.
    let license = {};

    license.awidLicenseOwnerList = appWorkspace["awidLicenseOwnerList"];
    license.uuAppErrorMap = uuAppErrorMap;

    return license;
  }

  /**
   * return workspace information from database
   * @param {uri} uri uri of the application
   * @param {Object} dtoIn
   * @returns {Promise<{}>}
   */

  async delete(uri, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysDeleteAppWorkspaceDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Delete.UC_CODE}unsupportedKeys`,
      Errors.Delete.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - System loads sysAppWorkspace from cache. (A3)
    let awid = dtoIn.awid;
    let sysAppWorkspace;
    try {
      sysAppWorkspace = await this.get(awid); // A3
    } catch (e) {
      if (e instanceof Errors.Get.SysUuAppWorkspaceDoesNotExistError) {
        // A4
        throw new Errors.Delete.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
      throw e;
    }

    // HDS 3. - System checks that sysAppWorkspace is in "closed" state. (A5)
    if (sysAppWorkspace.sysState !== this.SYS_STATES.CLOSED) {
      // A5
      throw new Errors.Delete.SysUuAppWorkspaceNotInProperState(
        { uuAppErrorMap },
        { awid, state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System checks that there is no uuBT artifact connected to the sysAppWorkspace
    // - sysAppWorkspace.uuAWSC is empty. (A6)
    if (sysAppWorkspace.uuAWSC) {
      // A6
      throw new Errors.Delete.UuAwscConnectedToTheSysUuAppWorkspace(
        { uuAppErrorMap },
        {
          awid,
          uuAWSC: sysAppWorkspace.uuAWSC,
        }
      );
    }

    // HDS 5. - Gets a list of all uuAppDataStore schemas
    // HDS 6. - System does these steps for each uuAppDataStore schema
    // HDS 6.1. - Gets DAO method according to the schema name.
    for (let [schema, dao] of DaoFactory._daos.entries()) {
      // HDS 6.2. - Creates query and searches for the records according to awid attribute
      let filter = { awid };
      let isBinary = Object.getPrototypeOf(dao.constructor).name === "UuBinaryDao";

      // HDS 6.3 - Based on DAO ancestor the type of schema is determined.
      if (isBinary) {
        // HDS 6.3.2 - uuBinary: gets a list of all uuBinary using DAO find and deletes
        // every uuBinary form that list using DAO deleteOne (including even the locked ones)
        await this._executeDeleteBinary(dao, schema, filter);
      } else {
        // HDS 6.3.1 - uuObject: deletes all records using DAO deleteMany (including even the locked ones)
        await this._executeDeleteMany(dao, schema, filter);
      }
    }

    // HDS 6.3.2 - Deletes keys of uuAppOidcClientKey in sysUuAppSecret collection using removeSecret() CMD
    const asid = uri.awid;
    await SysAppSecretStoreAbl.removeSecret(asid, SECRET_SET, `oidcg02|${awid}|Public`);
    await SysAppSecretStoreAbl.removeSecret(asid, SECRET_SET, `oidcg02|${awid}|Private`);
    await SysAppSecretStoreAbl.removeSecret(asid, SECRET_SET, `oidcg02|${awid}|Secret`);

    // HDS 7. - Deletes all uuAppWorkspace cache.
    this.deleteFromCache(awid);

    // HDS 8. - Returns properly filled dtoOut.
    return { uuAppErrorMap };
  }

  async setAuthorizationStrategy(uri, dtoIn, session) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetAuthTypeDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAuthorizationStrategy.UC_CODE}unsupportedKeys`,
      Errors.SetAuthorizationStrategy.InvalidDtoInError
    ); // A1, A2
    // HDS 2. - Checks, if the uuIdentity has rights to run use case sys/uuAppWorkspace/setAuthorizationStrategy
    // in given dtoIn.authorizationStrategy and sets auth data. (A3)
    let appWorkspace = await this.dao.getByAwid(uri.awid);
    if (dtoIn.authorizationStrategy === ROLE_GROUP_INTERFACE) {
      appWorkspace = await AuthorizeHelper.setAuthorizationData(
        Errors.SetAuthorizationStrategy,
        uri,
        dtoIn,
        appWorkspace,
        session,
        uuAppErrorMap,
        true
      );
    } else {
      appWorkspace = await AuthorizeHelper.setAuthorizationData(
        Errors.SetAuthorizationStrategy,
        uri,
        dtoIn,
        appWorkspace,
        session,
        uuAppErrorMap
      );
    }
    // HDS 3. - Sets new sysAppWorkspace.authorizationStrategy to dtoIn.authorizationStrategy value.
    // (sysAppWorkspace DAO update) (A4, A5)
    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, { ...appWorkspace });
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        // A4
        throw new Errors.SetAuthorizationStrategy.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid: uri.awid });
      } else if (e.cause instanceof ObjectStoreError) {
        // A5
        throw new Errors.SetAuthorizationStrategy.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(appWorkspace);

    appWorkspace.uuAppErrorMap = uuAppErrorMap;

    // HDS 4. - Returns properly filled dtoOut.
    return appWorkspace;
  }

  async connectArtifact(uri, dtoIn, session) {
    // HDS 1.1, 1.2, 1.3
    let validationResult = this.validator.validate("sysConnectArtifactDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.ConnectArtifact.UC_CODE}unsupportedKeys`,
      Errors.ConnectArtifact.InvalidDtoInError
    );
    // HDS 2
    let appWorkspace = await this.dao.getByAwid(uri.awid);
    if (appWorkspace.sysState === this.SYS_STATES.REGISTERED || appWorkspace.sysState === this.SYS_STATES.CLOSED) {
      throw new Errors.ConnectArtifact.UuAppWorkspaceIsNotInProperStateError(
        { uuAppErrorMap },
        { state: appWorkspace.sysState }
      );
    }
    // HDS 3
    uuAppErrorMap = await AuthorizeHelper.connectArtifact(
      Errors.ConnectArtifact,
      uri,
      dtoIn["artifactUri"],
      session,
      dtoIn.synchronizeArtifactBasicAttributes,
      uuAppErrorMap
    );
    // HDS 4
    let workspace = {
      artifactUri: dtoIn["artifactUri"],
      authorizationStrategy: ART_AUTHZ_TYPE,
    };
    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, workspace);
    } catch (e) {
      throw new Errors.ConnectArtifact.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
    }
    this._updateCache(appWorkspace);
    appWorkspace = { ...appWorkspace, ...{ uuAppErrorMap } };
    // HDS 5
    return appWorkspace;
  }

  /**
   * Provides information about an application workspace.
   *
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async get(awid, uuAppErrorMap = {}) {
    // HDS 1. - System loads uuObject sysAppWorkspace from cache
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 1. A1.1 - If cache doesn't exist, loads uuObject sysAppWorkspace from uuAppObjectStore by sysAppWorkspace DAO getByAwid.
    if (!sysAppWorkspace) {
      sysAppWorkspace = await this.dao.getByAwid(awid);

      if (!sysAppWorkspace) {
        // A2
        throw new Errors.Get.SysUuAppWorkspaceDoesNotExistError({ uuAppErrorMap }, { awid });
      }
      // HDS 1. A1.2 - Adds uuObject to the cache.
      this._updateCache(sysAppWorkspace);
    }

    // HDS 2. - Returns properly filled dtoOut.
    let dtoOut = { ...sysAppWorkspace };
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Set information about an application workspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async set(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Set.UC_CODE}unsupportedKeys`,
      Errors.Set.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    // HDS 3. - Verified dtoIn is saved to the uuAppObjectStore (sysAppWorkspace DAO update)
    // and uuObject is updated in cache. (A3, A4)
    let dtoOut = {};
    try {
      let sysAppWorkspace = dtoIn;
      sysAppWorkspace.awid = awid;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.Set.SysUuAppWorkspaceDoesNotExistError({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.Set.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  async setLicense(dtoIn) {
    // HDS 1. - Validation of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetLicenseDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetLicense.UC_CODE}unsupportedKeys`,
      Errors.SetLicense.InvalidDtoIn,
    ); // A1, A2

    dtoIn.validFromTs ||= new Date();
    dtoIn.validToTs ||= new Date(9999, 11, 31, 23, 59, 59, 999);

    // HDS 2. - Checks sysUuAppWorkspace state.
    let { awid, ...license } = dtoIn;

    let sysUuAppWorkspace = this.sysAppCache.get(awid);
    if (!sysUuAppWorkspace) {
      sysUuAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysUuAppWorkspace) {
        // A3
        throw new Errors.SetLicense.UuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
      this._updateCache(sysUuAppWorkspace);
    }

    let allowedSysStateList = [
      this.SYS_STATES.ASSIGNED,
      this.SYS_STATES.BEING_INITIALIZED,
      this.SYS_STATES.ACTIVE,
      this.SYS_STATES.RESTRICTED,
      this.SYS_STATES.READ_ONLY,
      this.SYS_STATES.SUSPENDED,
    ];
    if (!allowedSysStateList.includes(sysUuAppWorkspace.sysState)) {
      // A4
      throw new Errors.SetLicense.UuAppWorkspaceIsNotInCorrectState(
        { uuAppErrorMap },
        { sysState: sysUuAppWorkspace.sysState, allowedSysStateList },
      );
    }

    // HDS 3. - System updates licence infomation to sysUuAppWorkspace (sysUuAppWorkkspace DAO update).
    sysUuAppWorkspace = await this.dao.update({ awid, license });
    this._updateCache(sysUuAppWorkspace);

    // HDS 4. - Returns properly filled dtoOut.
    return {
      sysUuAppWorkspace,
      uuAppErrorMap,
    };
  }

  /**
   *
   Sets one key of SysAppWorkspace uuObject to given value.
   * @param {string} awid
   * @param {string} key
   * @param {string} value
   * @returns {Promise<*>}
   */

  async setConfigParameter(awid, key, value) {
    const dtoIn = {
      awid,
      key,
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("setConfigWorkspaceParameterDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetConfigParameter.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.SetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - Updates sysAppWorkspace uuObject in uuAppObjectStore (sysAppWorkspace DAO update) (A2, A3)
    let appWorkspace;
    let uuOject = { awid };
    uuOject[key] = value;
    try {
      appWorkspace = await this.dao.update(uuOject);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A2
        throw new Errors.SetConfigParameter.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A3
        throw new Errors.SetConfigParameter.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCache(appWorkspace);

    // HDS 3. - Returns properly filled dtoOut.
    appWorkspace.uuAppErrorMap = uuAppErrorMap;
    return appWorkspace;
  }

  /**
   *
   Gets a value of SysAppWorkspace uuObject for given key.
   * @param {string} awid
   * @param {string} key
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */

  async getConfigParameter(awid, key, uuAppErrorMap = {}) {
    const dtoIn = {
      awid,
      key: key,
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("getConfigWorkspaceParameterDtoInType", dtoIn);
    ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      Errors.GetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - System loads awid from application configuration.
    // HDS 3. - System loads uuObject sysAppInstance from cache. (A2)
    // HDS 4. - System reads value of attribute given in dtoIn.key. (A4)
    let dtoOut = (await this.get(awid))[key]; // A2, A4

    // HDS 5. - Returns properly filled dtoOut.
    return dtoOut === undefined ? null : dtoOut;
  }

  async getUuAppMetaModel(identity) {
    const uuAppErrorMap = {};

    const uuIdentityType = identity.getType();

    // HDS 1. - System checks that caller is systemIdentity
    if (!["uuAsidEe", "uuAwidEe"].includes(uuIdentityType)) {
      // A1
      throw new Errors.GetUuAppMetaModel.InvalidUuIdentityType({ uuAppErrorMap }, { uuIdentity: identity.getUuIdentity(), uuIdentityType });
    }

    // HDS 2. - System gets metamodel zip file from configuration
    const metamodelVersionPostfix = this.uuAppMetaModelVersion ? `_${this.uuAppMetaModelVersion}` : "";
    const filename = `metamodel_${identity.getUuAppKey().getProduct()}${metamodelVersionPostfix}.zip`;
    const root = Config.get("server_root") || process.cwd();
    const metamodelPath = Finder.findConfigInProject(root, `{app,src,}/config/${filename}`) || path.join(root, "app", "config", filename);
    if (!fs.existsSync(metamodelPath)) {
      // A2
      throw new Errors.GetUuAppMetaModel.UuAppMetaModelNotFound({ uuAppErrorMap });
    }

    // HDS 3. - Returns properly filled dtoOut
    const dtoOut = {
      data: fs.createReadStream(metamodelPath),
      filename: filename,
      contentType: "application/zip",
    }
    return dtoOut;
  }

  async getLicense(awid, dtoIn, uuIdentity, authorizedProfiles) {
    let uuAppErrorMap = {};

    let validationResult = this.validator.validate("sysUuAppWorkspaceGetLicenseDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      uuAppErrorMap,
      `${Errors.GetLicense.UC_CODE}unsupportedKeys`,
      Errors.GetLicense.InvalidDtoIn,
    );

    if (
      ((dtoIn.uuIdentity && dtoIn.uuIdentity !== uuIdentity) || dtoIn.productCode || dtoIn.productInstance) &&
      !authorizedProfiles.includes("Authorities")
    ) {
      throw new Errors.GetLicense.UserIsNotAuthorized({ uuAppErrorMap });
    }

    let license;
    try {
      license = await WorkspaceLicenseService.getLicense(awid, dtoIn.productCode, dtoIn.productInstance, dtoIn.uuIdentity);
    } catch (e) {
      throw new Errors.GetLicense.LicenseGetFailed(
        { uuAppErrorMap },
        { awid, productCode: dtoIn.productCode, productInstance: dtoIn.productInstance, uuIdentity: dtoIn.uuIdentity },
        e,
      );
    }

    if (!license) {
      throw new Errors.GetLicense.LicenseDoesNotExist(
        { uuAppErrorMap },
        { awid, productCode: dtoIn.productCode, productInstance: dtoIn.productInstance, uuIdentity: dtoIn.uuIdentity },
      );
    }

    return { license, uuAppErrorMap };
  }

  /**
   * Sets uuAppWorkspace to the closed state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async close(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceCloseDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Close.UC_CODE}unsupportedKeys`,
      Errors.Close.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("closed") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Close.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (sysAppWorkspace.sysState === this.SYS_STATES.CLOSED) {
      // A5
      throw new Errors.Close.SysUuAppWorkspaceAlreadyClosed({ uuAppErrorMap }, { state: sysAppWorkspace.sysState });
    }

    // HDS 4. - System sets the state of uuAppWorkspace to "closed" (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      sysAppWorkspace.sysState = this.SYS_STATES.CLOSED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Close.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.CLOSED,
          },
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 5. - System sets the state of uuAppWorkspace to "closed" in uuBaseRegistry.
    // (using uuBaseRegistry/close interface). (A7)
    // TODO impl. missing uuCMD step

    // HDS 6. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the suspended state.
   * Can be called only if uuAppWorkspace is in the active state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async suspend(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSuspendTypeDtoIn", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Suspend.UC_CODE}unsupportedKeys`,
      Errors.Suspend.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("active", "restricted", "readOnly") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Suspend.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (
      !(
        sysAppWorkspace.sysState === this.SYS_STATES.ACTIVE ||
        sysAppWorkspace.sysState === this.SYS_STATES.RESTRICTED ||
        sysAppWorkspace.sysState === this.SYS_STATES.READ_ONLY
      )
    ) {
      // A5
      throw new Errors.Suspend.SysUuAppWorkspaceNotInProperState(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets sysAppWorkspace.previousSysState to current sysAppWorkspace state.
    sysAppWorkspace.previousSysState = sysAppWorkspace.sysState;

    // HDS 5. - System sets the state of uuAppWorkspace to "suspended" (sysAppWorkspace DAO update). (A5)
    let dtoOut;
    try {
      sysAppWorkspace.sysState = this.SYS_STATES.SUSPENDED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Suspend.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.SUSPENDED,
          }
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 6. - System sets the state of uuAppWorkspace to "suspended" in uuBaseRegistry. (using uuBaseRegistry/suspend interface). (A6)
    // TODO impl. missing uuCMD step

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the active state.
   * Can be called only if uuAppWorkspace is in the suspended state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async resume(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceResumeTypeDtoIn", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Resume.UC_CODE}unsupportedKeys`,
      Errors.Resume.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("suspended") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Resume.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (sysAppWorkspace.sysState !== this.SYS_STATES.SUSPENDED) {
      // A5
      throw new Errors.Resume.sysUuAppWorkspaceNotInSuspendedState(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets the state of uuAppWorkspace to sysAppWorkspace.previousSysState
    // and deletes this attribute from the uuObject. (A6)
    sysAppWorkspace.sysState = sysAppWorkspace.previousSysState;

    if (!sysAppWorkspace.previousSysState) {
      // A6
      sysAppWorkspace.sysState = this.SYS_STATES.ACTIVE;
    }

    delete sysAppWorkspace.previousSysState;

    // HDS 5. - System sets the state of uuAppWorkspace to "active" (sysAppWorkspace DAO update).
    // and updates cache. (TTL set to 5 minutes) (A7)

    let dtoOut;
    try {
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Suspend.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.SUSPENDED,
          },
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 6. - System sets the state of uuAppWorkspace to "active" in uuBaseRegistry. (using uuBaseRegistry/activate interface). (A8)
    // TODO impl. missing uuCMD step

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setActiveSysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetActiveSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetActiveSysState.UC_CODE}unsupportedKeys`,
      Errors.SetActiveSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to active and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.ACTIVE;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetActiveSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetActiveSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setRestrictedSysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetRestrictedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetRestrictedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetRestrictedSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity
    // and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to active
    // and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.RESTRICTED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetRestrictedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetRestrictedSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setReadOnlySysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetReadOnlySysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetReadOnlySysState.UC_CODE}unsupportedKeys`,
      Errors.SetReadOnlySysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to readOnly and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update)
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.READ_ONLY;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetReadOnlySysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetReadOnlySysState.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * List information about uuAppWorkspaces provided in dtoIn. If dtoIn is empty,
   * command returns every uuAppWorkspace stored in uuAppObjectStore.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async list(dtoIn, uuAppErrorMap) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceListDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.List.UC_CODE}unsupportedKeys`,
      Errors.List.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - Loads each sysAppWorkspace uuObject (sysAppWorkspace DAO listByStateAndAwidList) from the uuAppObjectStore
    // that corresponds to dtoIn.awidList. In case dtoIn.awidList is empty, system loads every sysAppWorkspace from uuAppObjectStore.
    let list = await this.dao.listByStateListAndAwidList(dtoIn.sysStateList, dtoIn.awidList, dtoIn.pageInfo);

    // HDS 3. - Returns properly filled out dtoOut.
    list.uuAppErrorMap = uuAppErrorMap;
    return list;
  }

  /**
   * Loads information about system uuAppWorkspace data and data of uuBT which
   * the uuAppWorkspace is connected to (for authenticated users).
   *
   * @param {uri} uri uri of the application
   * @param {Object} session authentication session
   * @param {Object} uuAppErrorMap
   * @returns {Promise<Object>} object containing sysData, uuAppErrorMap and possibly territoryData
   */
  async load(uri, session, uuAppErrorMap) {
    const dtoOut = {};

    // HDS 1-5
    dtoOut.sysData = await this.getSysData(uri, session);
    const awidData = dtoOut.sysData.awidData;

    // HDS 6, 6.A
    if (awidData.sysState !== "created") {
      // HDS 6.A.1
      let artifactUri;
      if (awidData.authorizationStrategy === "artifact") {
        const { uuTerritoryBaseUri, artifactId, artifactCode } = (awidData.authorizationData || {}).artifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: artifactId, code: artifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      } else if (awidData.authorizationStrategy === "boundArtifact") {
        const { uuTerritoryBaseUri, boundArtifactId, boundArtifactCode } =
          (awidData.authorizationData || {}).boundArtifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: boundArtifactId, code: boundArtifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      }

      if (artifactUri) {
        const parsedArtifactUri = UriBuilder.parse(artifactUri);
        const { id, code } = parsedArtifactUri.getParameters();
        const loadUri = parsedArtifactUri.setUseCase("uuArtifactIfc/loadData").clearParameters().toUri();
        const loadDtoIn = { id, code, loadContextNavigation: true, loadVisualIdentification: true };
        let territoryData;
        try {
          territoryData = await AppClient.get(loadUri, loadDtoIn, { session });
        } catch (e) {
          // HDS 6.A.1.1
          throw new Errors.Load.TerritoryDataLoadFailed({ uuAppErrorMap }, { loadUri, loadDtoIn }, e);
        }
        if (territoryData.uuAppErrorMap && Object.keys(territoryData.uuAppErrorMap).length > 1) {
          let warningList = Object.keys(territoryData.uuAppErrorMap);
          ValidationHelper.addWarning(uuAppErrorMap, WARNINGS.territoryDataLoad.code, WARNINGS.territoryDataLoad.message, { warningList });
          delete territoryData.uuAppErrorMap;
        }
        dtoOut.territoryData = territoryData;
      }
    }

    // HDS 7
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Loads information about system uuAppWorkspace data and data of uuBT which
   * the uuAppWorkspace is connected to (for unauthenticated users).
   *
   * @param {uri} uri uri of the application
   * @param {Object} session authentication session
   * @param {Object} uuAppErrorMap
   * @returns {Promise<Object>} object containing sysData, uuAppErrorMap and possibly territoryData
   */
  async loadBasicData(uri, session, uuAppErrorMap) {
    const awid = uri.getAwid();
    const dtoOut = {};

    // HDS 1
    dtoOut.sysData = { relatedObjectsMap: this.getRelatedObjectsMap() };

    // HDS 2, 2.A
    const awidData = await this.get(awid);
    if (awidData.sysState !== "created") {
      // HDS 2.A.1
      let artifactUri;
      if (awidData.authorizationStrategy === "artifact") {
        const { uuTerritoryBaseUri, artifactId, artifactCode } = (awidData.authorizationData || {}).artifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: artifactId, code: artifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      } else if (awidData.authorizationStrategy === "boundArtifact") {
        const { uuTerritoryBaseUri, boundArtifactId, boundArtifactCode } =
          (awidData.authorizationData || {}).boundArtifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: boundArtifactId, code: boundArtifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      }

      if (artifactUri) {
        const parsedArtifactUri = UriBuilder.parse(artifactUri);
        const { id, code } = parsedArtifactUri.getParameters();
        const loadUri = parsedArtifactUri.setUseCase("loadArtifactVisualIdentification").clearParameters().toUri();
        const loadDtoIn = { artifactId: id, artifactCode: code };
        let visualIdentificationDtoOut;
        try {
          visualIdentificationDtoOut = await AppClient.get(loadUri, loadDtoIn);
        } catch (e) {
          // HDS 2.A.1.1
          throw new Errors.LoadBasicData.TerritoryDataLoadFailed({ uuAppErrorMap }, { loadUri, loadDtoIn }, e);
        }
        const uuTerritoryBaseUri = parsedArtifactUri.setUseCase("").clearParameters().toUri();
        dtoOut.territoryData = {
          data: {
            visualIdentification: visualIdentificationDtoOut.value,
            artifact: { id: visualIdentificationDtoOut.artifact },
            context: { territory: { uuTerritoryBaseUri } },
          },
        };
      }
    }

    // HDS 3
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
 * Loads sysData about of the system uuAppWorkspace that are used in the outputs
 * of standard load interfaces (sys/uuAppWorkspace/load and entity/load).
 *
 * @param {uri} uri uri of the application
 * @param {Object} session authentication session
 * @returns {Promise<Object>} object containing sysData
 */
  async getSysData(uri, session) {
    // HDS 1
    const asid = Config.get("asid");
    const asidData = await SysAppInstance.get(asid);
    delete asidData.uuAppErrorMap;

    // HDS 2
    const awid = uri.getAwid();
    const awidData = await this.get(awid);
    delete awidData.uuAppErrorMap;

    // HDS 3
    const relatedObjectsMap = this.getRelatedObjectsMap();

    // HDS 4
    const cmdUri = UriBuilder.parse(uri).setUseCase("sys/uuAppWorkspace/load").clearParameters();
    const WorkspaceAuthorizationService = require("../workspace-authorization-service.js"); // to avoid circular dependency
    const authorizationResult = await WorkspaceAuthorizationService.authorize(session, cmdUri.toUri());

    const profileData = {
      uuIdentityProfileList: authorizationResult.getUuIdentityProfileList(),
      profileList: authorizationResult.getProfileList(),
    };

    if (!this.uuAppLibraryList) {
      this.uuAppLibraryList = await this._prepareUuAppLibraryLibraries();
    }

    // HDS 5
    return { asidData, awidData, relatedObjectsMap, profileData, uuAppLibraryList: this.uuAppLibraryList };
  }

  /**
   * Builds and loads relatedObjectsMap that is used as part of the uuAppWorkspace sysData
   *
   * @returns {Promise<Object>} object containing relatedObjectsMap
   */
  getRelatedObjectsMap() {
    return {
      uuAppUuFlsBaseUri: Config.get("fls_base_uri"),
      uuAppUuSlsBaseUri: Config.get("sls_base_uri"),
      uuAppBusinessModelUri: Config.get("business_model_uri"),
      uuAppApplicationModelUri: Config.get("application_model_uri"),
      uuAppBusinessRequestsUri: Config.get("business_request_uri"),
      uuAppUserGuideUri: Config.get("user_guide_uri"),
      uuAppWebKitUri: Config.get("web_uri"),
      uuAppProductPortalUri: Config.get("product_portal_uri"),
    };
  }

  /**
   * update appWorkspace in the cache.
   *
   * @param {Object} appWorkspace
   * @param {Boolean} force
   */
  _updateCache(appWorkspace, force = false) {
    if (force || ![this.SYS_STATES.REGISTERED, this.SYS_STATES.CREATED, this.SYS_STATES.ASSIGNED, this.SYS_STATES.BEING_INITIALIZED].includes(appWorkspace.sysState)) {
      this.sysAppCache.set(appWorkspace.awid, appWorkspace);
    }
  }

  /**
   * reset whole cache
   */
  clearCache() {
    this.sysAppCache.clear();
  }

  /**
   * deletes item from cache
   */
  deleteFromCache(item) {
    this.sysAppCache.delete(item);
  }

  /**
   * check for NoaLimit and store workspace to the database
   * @param {Object} uuObject
   * @param {Object} lock
   * @returns {Promise<*>}
   */
  async createUuObject(uuObject, lock) {
    await this._checkNoa();
    return await this.dao.create(uuObject, lock);
  }

  /**
   * delete workspace by awid and reset the cache
   * @param {String} awid
   * @returns {Promise<*>}
   */
  async deleteAppWorkspace(awid) {
    this.clearCache();
    return await this.dao.deleteByAwid(awid);
  }

  /**
   * Internal command for retrieving workspaces not in given state but with given awids.
   *
   * @param excludedStateList {Array}
   * @param awidList {Array} - when falsy, list all awids
   * @returns {Array}
   */
  async listByExcludedStateListAndAwidList(excludedStateList, awidList) {
    let appWorkspaces = [];
    let pageIndex = 0;
    let loadedWorkspaces;

    do {
      loadedWorkspaces = await this.dao.listByExcludedStateListAndAwidList(excludedStateList, awidList, {
        pageIndex,
      });
      appWorkspaces = appWorkspaces.concat(loadedWorkspaces.itemList);
      pageIndex += 1;
    } while (loadedWorkspaces && appWorkspaces.length < loadedWorkspaces.pageInfo.total);

    return appWorkspaces;
  }

  /**
   * check for Noa limit
   * @returns {Promise<void>}
   * @private
   */
  async _checkNoa() {
    let maxNoa = DaoFactory.getMaxNoa() || DEFAULT_MAX_NOA;
    let awidsCount = await this.dao.getCount();

    if (awidsCount >= maxNoa) {
      throw new Errors.MaximumNumberAwidsError(maxNoa);
    }
  }

  async _executeDeleteMany(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreAbl = require("./sys-dump-restore-abl");
    let dumbDao = SysDumpRestoreAbl._getDumpDao(dao, schema);
    await dumbDao.deleteMany(filter);
  }

  async _executeDeleteBinary(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreAbl = require("./sys-dump-restore-abl");
    let dumbDao = SysDumpRestoreAbl._getDumpDao(dao, schema);
    await dumbDao.deleteBinary(filter, schema);
  }

  async getLogAccessAttributes(uri, dtoIn) {
    // HDS 1
    let validationResult = this.validator.validate("sysUuAppWorkspaceGetLogAccessAttributesDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.GetLogAccessAttributes.UC_CODE}unsupportedKeys`,
      Errors.GetLogAccessAttributes.InvalidDtoIn,
    );

    // HDS 2
    let dto = {
      asid: this.asid,
      awid: uri.getAwid(),
      ttl: dtoIn.ttl ? dtoIn.ttl : GET_LOG_ACCESS_ATTRIBUTES_DEFAULT_TTL,
      maxUseCaseCallCount: dtoIn.maxUseCaseCallCount,
    };

    let accessKeyAttrs;
    try {
      accessKeyAttrs = await LogStoreService.createAccessKey(dto);
    } catch (e) {
      this.logger.error(`Failed to obtain log access attributes.`, e);
      if (e.code == LogStoreServiceErrors.CreateAccessKey.UuCloudLogStoreBaseUriNotConfigured.code) {
        throw new Errors.GetLogAccessAttributes.CloudLogStoreBaseUriNotConfigured({ uuAppErrorMap }, e);
      }
      throw new Errors.GetLogAccessAttributes.AccessKeyWasNotCreated({ uuAppErrorMap }, e);
    }

    // HDS 3
    let link = LogStoreUtils.createGetRecordListLink(accessKeyAttrs);

    // HDS 4
    let result = {
      uuCloudLogStoreBaseUri: accessKeyAttrs.baseUri,
      accessKey: accessKeyAttrs.accessKey,
      logDataUri: link.toString(),
      uuAppErrorMap,
    };
    return result;
  }

  async _prepareUuAppLibraryLibraries() {
    const uuLibraries = this._getUuLibrariesFromMappings();
    let result = await this._resolveLibraryVersion(uuLibraries);
    result.sort();
    return result;
  }

  _getUuLibrariesFromMappings() {
    const mappings = MappingsLoader.load();

    // collect paths of used mappings.json in the uuApp
    let sourceSet = new Set();
    if (mappings.data) {
      const products = Object.keys(mappings.data);
      products.forEach(item => {
        const ucMap = mappings.data[item].useCaseMap;
        if (ucMap) {
          Object.keys(ucMap).forEach(uc => {
            sourceSet.add(ucMap[uc].source);
          });
        }
      });
    }

    // create library names according to the mappings.json paths
    let result = [];
    sourceSet.forEach(mappingsJsonPath => {
      result.push(this._getLibraryName(mappingsJsonPath));
    });
    result = result.filter(item => item != null); // remove entry for mappings.json for the current uuApp 
    return result;
  }

  _getLibraryName(mappingsJsonPath) {
    const normalizedPath = path.normalize(mappingsJsonPath).replaceAll("\\", "/");
    const pathParts = normalizedPath.split("/");
    const nodeModuleIndex = pathParts.lastIndexOf(NODE_MODULES);

    let result = null;
    if (nodeModuleIndex != -1 && pathParts.length > nodeModuleIndex) {
      result = pathParts[nodeModuleIndex + 1];
    } else if (this.logger.isDebugLoggable()) {
      this.logger.debug(`No module name found for the ${mappingsJsonPath} path.`);
    }
    return result;
  }

  async _resolveLibraryVersion(libraryList) {
    let result = [];
    const packagesMap = await this._getAllUsedPackages();
    libraryList.forEach((name) => {
      result = result.concat(packagesMap.get(name));
    });
    return result;
  }

  async _getAllUsedPackages() {
    let result = new Map();
    const packageList = (await PackagesHelper.getUuAppPackages())[0];
    packageList.forEach(packageId => {
      let lastAtSign = packageId.lastIndexOf("@");
      let name = lastAtSign > -1 ? packageId.substring(0, lastAtSign) : (() => {
        this.logger.warn(`Failed to determine version for the package "${packageId}".`);
        return packageId;
      })();

      let versionList = result.get(name);
      if (!versionList) {
        versionList = [];
        result.set(name, versionList);
      }

      if (!versionList.includes(packageId)) {
        versionList.push(packageId);
      }
    });
    return result;
  }

}

module.exports = new SysAppWorkspaceAbl();
