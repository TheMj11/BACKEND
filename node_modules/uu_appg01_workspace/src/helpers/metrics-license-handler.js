"use strict";

const { BaseError, Config, LruCache } = require("uu_appg01_core-utils");
const { ValidationHelper, UseCaseContext } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { AsidLicenseExceededError } = require("../api/errors/sys-asid-license-error.js");
const { AwidLicenseExceededError } = require("../api/errors/sys-awid-license-error.js");
const {
  LicenseDoesNotExistError,
  UnableToObtainMeterProviderError,
  UnableToObtainMeterError,
  UnableToObtainMetricError,
} = require("../api/errors/workspace-license-error.js");
const WorkspaceError = require("../api/errors/workspace-error.js");
const WorkspaceLicenseService = require("../workspace-license-service.js");
const ProfileConfig = require("./profile-config.js");

const UU_APP_METRICS_ENABLED = Config.getBoolean("uu_app_metrics_enabled");

if (UU_APP_METRICS_ENABLED) {
  var { MeterProviderFactory } = require("uu_app_metricsg01");
}

const LICENSE_POLICY = {
  licensed: "licensed",
  notLicensed: "notLicensed",
};

const warnThresholdUnitMap = {
  PERCENTAGE: "percentage",
  NUMBER: "number",
};

const featureTypeMap = {
  CONSUMPTION: "consumption",
  TIER: "tier",
};

const METRICS_LICENSE_CACHE_TTL_CONFIG_NAME = "uu_app_workspace_metrics_license_cache_ttl"; // TODO find better name
const METRICS_LICENSE_CACHE_TTL_DEFAULT_VALUE = 5 * 60 * 1000;
const DEFAULT_WARN_THRESHOLD_RATIO = 0.8;

class WorkspaceMetricsLicenseHandler {
  constructor() {
    const maxAge =
      Config.get(METRICS_LICENSE_CACHE_TTL_CONFIG_NAME) != null
        ? Config.getNumber(METRICS_LICENSE_CACHE_TTL_CONFIG_NAME) * 1000
        : METRICS_LICENSE_CACHE_TTL_DEFAULT_VALUE;
    this.licenseCache = new LruCache({ maxAge });
    this.asid = Config.get("asid");
    this.logger = LoggerFactory.get();
    this.licensingEnabled = Config.getBoolean("uu_app_workspace_license_verification_enabled") || false;
  }

  async handleCall(awid, ucName) { // TODO find better name
    if (!this.licensingEnabled) {
      return;
    }

    const ucConfig =
      (awid === this.asid ? ProfileConfig.getPrivilegedUseCase(this.asid, ucName) : ProfileConfig.getUseCase(ucName)) ||
      {};
    const ucLicensePolicy = ucConfig.licensePolicy;
    if (ucLicensePolicy === LICENSE_POLICY.notLicensed) {
      this.logger.info(
        `License verification for useCase ${ucName} skipped due to its licensePolicy set to ${ucLicensePolicy}.`,
      );
      return;
    }

    const license = await this._getLicense(awid);
    let uuAppErrorMap = UseCaseContext.getAttribute("uuAppErrorMap");

    if (!license) {
      throw new LicenseDoesNotExistError();
    }

    let licenseExceeded = false;
    let exceededProductFeatures = [];

    license.activeTierMap.forEach((activeTier, productFeatureCode) => {
      if (ucConfig.disabledInTierList?.includes(activeTier)) {
        exceededProductFeatures.push({ productFeatureCode });
        const LicenseExceededError = awid === this.asid ? AsidLicenseExceededError : AwidLicenseExceededError;
        throw new LicenseExceededError(undefined, {
          productFeatures: exceededProductFeatures,
          licenseUri: license.uri,
        });
      }
    });

    const awidKey = awid === this.asid ? "asid" : "awid";
    for (const [meterProviderName, meterLicenseMap] of license.meterProviderLicenseMap) {
      const meterProvider = MeterProviderFactory.get(meterProviderName);
      const metricReader = meterProvider.getMetricReader("licenseMetricsReader"); // TODO load dynamically
      const metrics = await metricReader.collect();
      let metricsToProcess = new Map(); // metrics that are watched in license

      metrics.resourceMetrics.uuAppMetrics.metricSet.forEach((metric) => { // all metrics from metric reader
        if ((metric.attributes || {})[awidKey] !== awid) {
          // skip metrics for different awids
          return;
        }

        if (meterLicenseMap.has(metric.name)) { // if the meter is watched in license add all of its instruments to metricsToProcess
          metric.metricData.map((data) => (data.attributes = { ...metric.attributes, ...data.attributes }));
          if (metricsToProcess.has(metric.name)) {
            metricsToProcess.set(metric.name, metricsToProcess.get(metric.name).push(metric.metricData));
          } else {
            metricsToProcess.set(metric.name, metric.metricData);
          }
        }
      });

      metricsToProcess.forEach((metricData, meterName) => { // metrics to process per meter
        let instrumentLicenseMap = meterLicenseMap.get(meterName);
        metricData.forEach((data, index) => {
          instrumentLicenseMap.forEach((instrumentLicense, instrumentName) => {
            if (index === 0) {
              instrumentLicense.totalConsumptions = 0;
            }

            if (
              data.metric === instrumentName &&
              Object.entries(instrumentLicense.attributes).every(
                ([attrName, attrValue]) => data.attributes[attrName] === attrValue,
              )
            ) {
              instrumentLicense.totalConsumptions += data.value;
            }

            if (index === metricData.length - 1) {
              if (instrumentLicense.totalConsumptions >= instrumentLicense.warnThreshold) {
                exceededProductFeatures.push({
                  productFeatureCode: instrumentLicense.productFeatureCode,
                });
                if (instrumentLicense.totalConsumptions >= instrumentLicense.maxConsumption) {
                  licenseExceeded = true;
                }
              }
            }
          });
        });
      });
    }

    if (exceededProductFeatures.length) {
      if (licenseExceeded) {
        const LicenseExceededError = awid === this.asid ? AsidLicenseExceededError : AwidLicenseExceededError;
        throw new LicenseExceededError(undefined, {
          productFeatures: exceededProductFeatures,
          licenseUri: license.uri,
        });
      } else {
        ValidationHelper.addWarning(
          uuAppErrorMap,
          `${WorkspaceError.APP_WORKSPACE_LIB_ERROR_PREFIX}${awidKey}LicenseExceedsSoon`,
          `The current ${awid === this.asid ? "application" : "uuAppWorkspace"} license will soon be exceeded.`,
          { productFeatures: exceededProductFeatures, licenseUri: license.uri },
        );
        // TODO Use UseCaseContext's native method to add warning when support is added
        // UseCaseContext.addWarning(
        //   `${WorkspaceError.APP_WORKSPACE_LIB_ERROR_PREFIX}${awidKey}LicenseExceedsSoon`,
        //   `The current ${awid === this.asid ? "application" : "uuAppWorkspace"} license will soon be exceeded.`,
        //   { productFeatures: exceededProductFeatures, licenseUri: license.uri },
        // );
      }
    }
  }

  async _getLicense(awid) {
    let license = this.licenseCache.get(awid);

    // TODO needs revision to ensure deterministic behaviour
    if (!license || license.validToTs < Date.now()) {
      license = await this._loadLicense(awid);
      this.licenseCache.set(awid, license);
    }

    return license;
  }

  async _loadLicense(awid) {
    let license = await WorkspaceLicenseService.getLicense(awid);
    return license && this._parseLicense(license);
  }

  _parseLicense(license) {
    let meterProviderLicenseMap = new Map();
    let activeTierMap = new Map();

    Object.entries(license.plan.productFeatureMap).forEach(([productFeatureCode, productFeature]) => {
      const featureData = productFeature.featureData;
      if (productFeature.featureType === featureTypeMap.CONSUMPTION) {
        const codeSegments = featureData.metricCode.split(".");
        if (codeSegments.length !== 3) {
          throw new UnableToObtainMetricError({}, { metricCode: featureData.metricCode });
        }

        const [meterProviderName, meterName, instrumentName] = codeSegments;
        let meterProviderLicense = meterProviderLicenseMap.get(meterProviderName);
        if (!meterProviderLicense) {
          try {
            MeterProviderFactory.get(meterProviderName);
          } catch (e) {
            throw new UnableToObtainMeterProviderError({}, { meterProvider: meterProviderName }, e);
          }
          meterProviderLicense = new Map();
          meterProviderLicenseMap.set(meterProviderName, meterProviderLicense);
        }

        let meterLicense = meterProviderLicense.get(meterName);
        if (!meterLicense) {
          try {
            const meter = MeterProviderFactory.get(meterProviderName).getMeter(meterName);
            if (meter.isDisabled()) {
              throw new BaseError(`Meter with name "${meterName}" is disabled.`);
            }
          } catch (e) {
            throw new UnableToObtainMeterError({}, { meter: meterName }, e);
          }
          meterLicense = new Map();
          meterProviderLicense.set(meterName, meterLicense);
        }

        try {
          const instrument = MeterProviderFactory.get(meterProviderName)
            .getMeter(meterName)
            .getInstrument(instrumentName);
          if (instrument._descriptor.disabled) { // TODO use isDisabled method when it is implemented
            throw new BaseError(`Instrument with name "${instrumentName}" is disabled.`);
          }
        } catch (e) {
          throw new UnableToObtainMetricError({}, { metricCode: featureData.metricCode }, e);
        }

        meterLicense.set(instrumentName, {
          maxConsumption: featureData.maxConsumption,
          warnThreshold: this._resolveWarnThreshold(featureData),
          attributes: featureData.attributes || {},
          productFeatureCode,
        });
      } else if (productFeature.featureType === featureTypeMap.TIER) {
        activeTierMap.set(productFeatureCode, featureData.tier);
      }
    });

    return {
      validFromTs: license.validFromTs,
      validToTs: license.validToTs,
      uri: license.uri,
      meterProviderLicenseMap,
      activeTierMap,
    };
  }

  _resolveWarnThreshold(featureData) {
    const { maxConsumption, warnThreshold, warnThresholdUnit = warnThresholdUnitMap.PERCENTAGE } = featureData;
    const defaultWarnThreshold = maxConsumption * DEFAULT_WARN_THRESHOLD_RATIO;

    if (typeof warnThreshold !== "number") {
      return defaultWarnThreshold;
    }

    switch (warnThresholdUnit) {
      case warnThresholdUnitMap.NUMBER:
        if (warnThreshold < 0 || warnThreshold > maxConsumption) {
          return defaultWarnThreshold;
        }
        return warnThreshold;
      case warnThresholdUnitMap.PERCENTAGE:
        if (warnThreshold < 0 || warnThreshold > 1) {
          return defaultWarnThreshold;
        }
        return maxConsumption * warnThreshold;
      default:
        return defaultWarnThreshold;
    }
  }
}

module.exports = new WorkspaceMetricsLicenseHandler();
