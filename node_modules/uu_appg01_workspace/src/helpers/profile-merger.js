"use strict";

const { ProfilesMergeDuplicateKeyError } = require("../api/errors/startup-errors.js");

const PRIVILEGED_TID_ASID = "{tid}-{asid}";
const PRIVILEGED_ASID = "{asid}";
const NON_PRIVILEGED = "*";
const CONFLICTS = "_@@conflicts";

class ProfileMerger {
  static mergeProfiles(profileConfigList) {
    let privilegedProfileLists = [];
    let privilegedTierLists = [];
    let privilegedUseCaseMaps = [];
    let profileLists = [];
    let tierLists = [];
    let useCaseMaps = [];

    for (const config of profileConfigList) {
      let privilegedConfig = config[PRIVILEGED_TID_ASID] ? config[PRIVILEGED_TID_ASID] : config[PRIVILEGED_ASID];
      privilegedProfileLists.push(privilegedConfig.profileList);
      privilegedConfig.tierList?.length && privilegedTierLists.push(privilegedConfig.tierList);
      privilegedUseCaseMaps.push(privilegedConfig.useCaseMap);
      profileLists.push(config[NON_PRIVILEGED].profileList);
      config[NON_PRIVILEGED].tierList?.length && tierLists.push(config[NON_PRIVILEGED].tierList);
      useCaseMaps.push(config[NON_PRIVILEGED].useCaseMap);
    }

    return {
      [PRIVILEGED_ASID]: {
        profileList: ProfileMerger._mergeListOfArrays(privilegedProfileLists),
        tierList: ProfileMerger._mergeListOfArrays(privilegedTierLists),
        useCaseMap: ProfileMerger._mergeListOfObjects(privilegedUseCaseMaps)
      },
      [NON_PRIVILEGED]: {
        profileList: ProfileMerger._mergeListOfArrays(profileLists),
        tierList: ProfileMerger._mergeListOfArrays(tierLists),
        useCaseMap: ProfileMerger._mergeListOfObjects(useCaseMaps)
      }
    };
  }

  static _mergeListOfArrays(list) {
    let flat = [].concat.apply([], list);
    return [...new Set(flat)];
  }

  static _mergeListOfObjects([app, ...libs]) {
    let merged = libs.reduce(this._mergeObjects, { [CONFLICTS]: new Set() });
    this._throwOnConflict(app, merged[CONFLICTS]);
    delete merged[CONFLICTS];
    return Object.assign(merged, app);
  }

  static _mergeObjects(merged, next) {
    Object.keys(next).forEach(k => {
      if (k in merged) {
        if (JSON.stringify(next[k]) !== JSON.stringify(merged[k])) {
          // not conflict if same value (workaround for {asidOwner} definition)
          merged[CONFLICTS].add(k);
        }
      } else {
        merged[k] = next[k];
      }
    });
    return merged;
  }

  static _throwOnConflict(app, conflicts) {
    let unresolvedConflicts = [];
    conflicts.forEach(c => {
      if (!(c in app)) unresolvedConflicts.push(c);
    });
    if (unresolvedConflicts.length) {
      throw new ProfilesMergeDuplicateKeyError(unresolvedConflicts.join(", "));
    }
  }
}

module.exports = ProfileMerger;
