"use strict";

const { BaseError } = require("uu_appg01_core-utils");

const ATTRIBUTE_COUNT_LIMIT = 10;
const InstrumentTypeMap = {
  GAUGE: "gauge",
  HISTOGRAM: "histogram",
  COUNTER: "counter",
  UP_DOWN_COUNTER: "upDownCounter",
  OBSERVABLE_GAUGE: "observableGauge",
  OBSERVABLE_COUNTER: "observableCounter",
  OBSERVABLE_UP_DOWN_COUNTER: "observableUpDownCounter",
};

/**
 * @class UuApp.Metrics.Meter
 */
class Meter {
  constructor(openTelemetryMeterInstance, meterProviderName, options = {}) {
    this._instance = openTelemetryMeterInstance;
    this._name = openTelemetryMeterInstance._meterSharedState._instrumentationScope.name;
    this._version = openTelemetryMeterInstance._meterSharedState._instrumentationScope.version;
    this._meterProviderName = meterProviderName;
    this._attributeKeys = options?.attributeKeys || [];
    this._disabled = !!options?.disabled;
    this._instrumentMap = new Map();
  }

  /**
   * Creates a {@link UuApp.Metrics.Gauge} instrument.
   *
   * @param {string} name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.Gauge} An instance of the gauge.
   */
  createGauge(name, options) {
    this._verifyInstrumentUniqueness(name);
    let gauge = this._instance.createGauge(name, options);
    this._setUpInstrument(gauge, options);
    this._instrumentMap.set(name, gauge);
    return gauge;
  }

  /**
   * Creates a {@link UuApp.Metrics.Histogram} instrument.
   *
   * @param {string} name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.Histogram} An instance of the histogram.
   */
  createHistogram(name, options) {
    this._verifyInstrumentUniqueness(name);
    let histogram = this._instance.createHistogram(name, options);
    this._setUpInstrument(histogram, options);
    this._instrumentMap.set(name, histogram);
    return histogram;
  }

  /**
   * Creates a {@link UuApp.Metrics.Counter} instrument.
   *
   * @param name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.Counter} An instance of the counter.
   */
  createCounter(name, options) {
    this._verifyInstrumentUniqueness(name);
    let counter = this._instance.createCounter(name, options);
    this._setUpInstrument(counter, options);
    this._instrumentMap.set(name, counter);
    return counter;
  }

  /**
   * Creates a {@link UuApp.Metrics.UpDownCounter} instrument.
   *
   * @param name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.UpDownCounter} An instance of the counter.
   */
  createUpDownCounter(name, options) {
    this._verifyInstrumentUniqueness(name);
    let upDownCounter = this._instance.createUpDownCounter(name, options);
    this._setUpInstrument(upDownCounter, options);
    this._instrumentMap.set(name, upDownCounter);
    return upDownCounter;
  }

  /**
   * Creates a {@link UuApp.Metrics.ObservableGauge} instrument.
   *
   * @param name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.ObservableGauge} An instance of the observable gauge.
   */
  createObservableGauge(name, options) {
    this._verifyInstrumentUniqueness(name);
    let observableGauge = this._instance.createObservableGauge(name, options);
    this._setUpInstrument(observableGauge, options);
    this._instrumentMap.set(name, observableGauge);
    return observableGauge;
  }

  /**
   * Creates a {@link UuApp.Metrics.ObservableCounter} instrument.
   *
   * @param name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.ObservableCounter} An instance of the observable counter.
   */
  createObservableCounter(name, options) {
    this._verifyInstrumentUniqueness(name);
    let observableCounter = this._instance.createObservableCounter(name, options);
    this._setUpInstrument(observableCounter, options);
    this._instrumentMap.set(name, observableCounter);
    return observableCounter;
  }

  /**
   * Creates a {@link UuApp.Metrics.ObservableUpDownCounter} instrument.
   *
   * @param name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns {UuApp.Metrics.ObservableUpDownCounter} An instance of the observable up down counter.
   */
  createObservableUpDownCounter(name, options) {
    this._verifyInstrumentUniqueness(name);
    let observableUpDownCounter = this._instance.createObservableUpDownCounter(name, options);
    this._setUpInstrument(observableUpDownCounter, options);
    this._instrumentMap.set(name, observableUpDownCounter);
    return observableUpDownCounter;
  }

  /**
   * Returns an instance of the existing instrument.
   *
   * @param name Name of the instrument.
   * @param {object} [options] Options for metric creation.
   * @param {string} [options.description=""] The description of the metric.
   * @param {string} [options.unit=""] The type of the recorded value.
   * @param {number} [options.valueType=1] The unit of the metric values.
   * @param {object} [options.advice] The advice influencing aggregation configuration parameters.
   * @param {number[]} [options.advice.explicitBucketBoundaries] The advice influencing aggregation configuration parameters.
   *
   * @returns An instance of the instrument.
   */
  getInstrument(name) {
    if (!this._instrumentMap.has(name)) {
      throw new BaseError(`Instrument with name "${name}" does not exist.`);
    }
    return this._instrumentMap.get(name);
  }

  /**
   * Returns the name of {@link UuApp.Metrics.Meter} instance.
   *
   * @returns {string} The name of {@link UuApp.Metrics.Meter} instance.
   */
  getName() {
    return this._name;
  }

  /**
   * Returns the version of {@link UuApp.Metrics.Meter} instance.
   *
   * @returns {string} The version of {@link UuApp.Metrics.Meter} instance.
   */
  getVersion() {
    return this._version;
  }

  /**
   * Returns the name of {@link UuApp.Metrics.MeterProvider} to which the {@link UuApp.Metrics.Meter} instance belongs.
   *
   * @returns {string} The name of {@link UuApp.Metrics.MeterProvider} to which the {@link UuApp.Metrics.Meter} instance belongs.
   */
  getMeterProviderName() {
    return this._meterProviderName;
  }

  /**
   * Returns a list of attributes of {@link UuApp.Metrics.Meter} instance.
   *
   * @returns {array.<string>} A list of attributes of {@link UuApp.Metrics.Meter} instance.
   */
  getAttributeKeys() {
    return this._attributeKeys;
  }

  /**
   * Determines whether the {@link UuApp.Metrics.Meter} is disabled.
   *
   * @returns {boolean} True if the {@link UuApp.Metrics.Meter} is disabled, false otherwise.
   */
  isDisabled() {
    return this._disabled;
  }

  /**
   * Sets up a function that will be called whenever a metric collection is initiated.
   *
   * If the function is already in the list of callbacks for this Observable, the function is not added a second time.
   *
   * Only the associated observables can be observed in the callback.
   * Measurements of observables that are not associated observed in the callback are dropped.
   *
   * @param {*} callback The batch observable callback.
   * @param {*} observables The observables associated with this batch observable callback.
   */
  addBatchObservableCallback(callback, observables) {
    this._instance.addBatchObservableCallback(callback, observables);
  }

  removeBatchObservableCallback(callback, observables) {
    this._instance.removeBatchObservableCallback(callback, observables);
  }

  _verifyInstrumentUniqueness(name) {
    if (this._instrumentMap.has(name)) {
      throw new BaseError(`Instrument with name "${name}" already exists.`);
    }
  }

  _setUpInstrument(instrument, options) {
    const recordMethodName = instrument._descriptor.type.includes("COUNTER") ? "add" : "record";
    const isObservable = instrument._descriptor.type.includes("OBSERVABLE");
    const isDisabled = options?.disabled;

    if (isDisabled) {
      instrument._descriptor.disabled = true;
      if (isObservable) {
        instrument.addCallback = (callback) => {};
      } else {
        instrument[recordMethodName] = (value, attributes, ctx) => {};
      }
    } else {
      if (!isObservable) {
        const originalMethod = instrument[recordMethodName].bind(instrument);
        instrument[recordMethodName] = (value, attributes, ctx) => {
          this._validateAttributes(attributes);
          originalMethod(value, attributes, ctx);
        };
      }
    }
  }

  _validateAttributes(attributes) {
    const attributeCount = Object.keys(attributes || {}).length;
    if (attributeCount > ATTRIBUTE_COUNT_LIMIT) {
      // TODO
      throw new BaseError(`The maximum number of attributes is ${ATTRIBUTE_COUNT_LIMIT}, obtained ${attributeCount}.`);
    }
  }
}

Meter.InstrumentTypeMap = InstrumentTypeMap;

module.exports = Meter;
