"use strict";

const { BaseError } = require("uu_appg01_core-utils");
const MeterProviderFactory = require("../meter-provider-factory");

function enforcePrometheusNamingConvention(name, type) {
  // Prometheus requires that metrics of the Counter kind have "_total" suffix
  if (!name.endsWith("_total") && type === "COUNTER") {
    name = name + "_total";
  }
  return name;
}

class MetricFormatter {
  format(metrics, meterProviderName, instrumentNameIncludeList = [], instrumentNameExcludeList = []) {
    let meterProvider = MeterProviderFactory.get(meterProviderName);
    let resourceMetrics = metrics.resourceMetrics;
    let metricSet = [];

    for (const scopeMetrics of resourceMetrics.scopeMetrics) {
      let meter = meterProvider.getMeter(
        scopeMetrics.scope.name,
        scopeMetrics.scope.version ? scopeMetrics.scope.version : undefined,
      );

      if (meter.isDisabled()) {
        continue;
      }

      if (!meter.getAttributeKeys().length) {
        metricSet.push({
          name: scopeMetrics.scope.name,
          metricData: this._formatScopeMetrics(scopeMetrics, instrumentNameIncludeList, instrumentNameExcludeList),
        });
        continue;
      }

      let metricData = this._formatScopeMetrics(
        scopeMetrics,
        instrumentNameIncludeList,
        instrumentNameExcludeList,
      ).reduce((metricMap, metric) => {
        let metricAttributes = { ...metric.attributes };
        const sharedAttributes = meter.getAttributeKeys().reduce((sharedAttrs, attributeKey) => {
          if (metricAttributes.hasOwnProperty(attributeKey)) {
            sharedAttrs[attributeKey] = metricAttributes[attributeKey];
            delete metricAttributes[attributeKey];
          }
          return sharedAttrs;
        }, {});
        if (!Object.keys(metricAttributes).length) {
          metricAttributes = undefined;
        }

        const key = JSON.stringify(sharedAttributes);
        metricMap[key]
          ? metricMap[key].push({ ...metric, attributes: metricAttributes })
          : (metricMap[key] = [{ ...metric, attributes: metricAttributes }]);

        return metricMap;
      }, {});

      Object.entries(metricData).forEach((entry) => {
        metricSet.push({
          name: scopeMetrics.scope.name,
          attributes: JSON.parse(entry[0]),
          metricData: entry[1],
        });
      });
    }

    return {
      resourceMetrics: {
        resource: resourceMetrics.resource,
        uuAppMetrics: {
          period: {
            endTime: new Date(),
          },
          attributes: this._formatResourceAttributes(resourceMetrics.resource.attributes),
          metricSet,
        },
      },
      errors: metrics.errors,
    };
  }

  _formatScopeMetrics(scopeMetrics, instrumentNameIncludeList, instrumentNameExcludeList) {
    let result = [];
    for (const metric of scopeMetrics.metrics) {
      if (
        !metric.descriptor.disabled &&
        instrumentNameExcludeList.every((expr) => !`${scopeMetrics.scope.name}.${metric.descriptor.name}`.match(expr)) &&
        instrumentNameIncludeList.some((expr) => `${scopeMetrics.scope.name}.${metric.descriptor.name}`.match(expr))
      ) {
        result = result.concat(this._formatMetricData(metric));
      }
    }
    return result;
  }

  _formatMetricData(metricData) {
    let name = metricData.descriptor.name;
    const dataPointType = metricData.dataPointType;

    let results = [];
    switch (dataPointType) {
      case 3: // DataPointType.SUM
      case 2: {
        // DataPointType.GAUGE
        results = metricData.dataPoints.map((it) => this._formatSingularDataPoint(name, it));
        break;
      }
      case 0: {
        // DataPointType.HISTOGRAM
        results = metricData.dataPoints.flatMap((it) =>
          this._formatHistogramDataPoint(name, metricData.descriptor.type, it),
        );
        break;
      }
      default: {
        throw new BaseError(`Unrecognizable DataPointType: ${dataPointType} for metric "${name}"`);
      }
    }

    return results;
  }

  _formatSingularDataPoint(name, dataPoint) {
    const { value, attributes } = dataPoint;
    return {
      metric: name,
      value,
      attributes: Object.keys(attributes).length ? attributes : undefined,
    };
  }

  _formatHistogramDataPoint(name, type, dataPoint) {
    let results = [];

    name = enforcePrometheusNamingConvention(name, type);
    const attributes = dataPoint.attributes = Object.keys(dataPoint.attributes).length
      ? dataPoint.attributes
      : undefined;
    const histogram = dataPoint.value;
    /** Histogram["bucket"] is not typed with `number` */
    for (const key of ["count", "sum"]) {
      const value = histogram[key];
      if (value != null)
        results.push({
          metrics: name + "_" + key,
          value,
          attributes,
        });
    }

    let cumulativeSum = 0;
    const countEntries = histogram.buckets.counts.entries();
    let infiniteBoundaryDefined = false;
    for (const [idx, val] of countEntries) {
      cumulativeSum += val;
      const upperBound = histogram.buckets.boundaries[idx];
      /** HistogramAggregator is producing different boundary output -
       * in one case not including infinity values, in other -
       * full, e.g. [0, 100] and [0, 100, Infinity]
       * we should consider that in export, if Infinity is defined, use it
       * as boundary
       */
      if (upperBound === undefined && infiniteBoundaryDefined) {
        break;
      }
      if (upperBound === Infinity) {
        infiniteBoundaryDefined = true;
      }
      results.push({
        metric: name + "_bucket",
        value: cumulativeSum,
        attributes: {
          ...attributes,
          le: upperBound === undefined || upperBound === Infinity ? "+Inf" : String(upperBound),
        },
      });
    }

    return results;
  }

  _formatResourceAttributes(attributes) {
    return Object.fromEntries(Object.entries(attributes).filter((entry) => !entry[0].includes(".")));
  }
}

module.exports = new MetricFormatter();
