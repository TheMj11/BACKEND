"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ExpiredLock, ObjectNotFound, Lock } = require("uu_appg01_objectstore");

const { SYNC_PERIOD_MS } = require("../constants/config-constants.js");

const LOGGER = LoggerFactory.get();

const MAX_BATCH_UPDATE_SIZE = 10;

class MetricSynchronisationService {
  constructor() {
    this._accumulators = [];
    this._uuNodeId = null;

    this._dao = DaoFactory.getDao("sysUuAppMetrics");

    this._lock = null;
    this._lockDuration = SYNC_PERIOD_MS / 1000 + 10;

    this._lastPmClear = null;
    this._lastPhClear = null;
    this._lastPdClear = null;
    this._lastPwClear = null;
    this._lastPmoClear = null;

    this._syncEnabled = false;
  }

  register(accumulator, meterName, callback) {
    this._accumulators.push([accumulator, meterName, callback.bind(accumulator)]);
  }

  stopSynchronisation() {
    this._syncEnabled = false;
  }

  resumeSynchronisation() {
    if (this._syncEnabled) {
      return;
    }

    this._syncEnabled = true;

    const runSync = () => {
      this._synchronize()
        .catch(e => LOGGER.error(`Synchronisation of uuAppMetrics failed.`, e))
        .finally(() => {
          if (this._syncEnabled) {
            setTimeout(runSync, SYNC_PERIOD_MS)
          }
        });
    };

    runSync();
  }

  async onInitialized(uuNodeId, lock) {
    this._uuNodeId = uuNodeId;
    this._lock = lock;

    await this._initializeAccumulators();

    this.resumeSynchronisation();
  }

  async _synchronize() {
    LOGGER.debug("Running synchronisation of uuAppMetrics.");
    const periodToClear = this._getPeriodToClear();
    if (periodToClear) {
      await this._clearExpiredMetrics(periodToClear);
    }

    let meterMap = new Map();

    // prepare metrics to be updated
    for (const [accumulator, meterName] of this._accumulators) {
      if (!meterMap.has(meterName)) {
        meterMap.set(meterName, new Map());
      }

      let instrumentMap = meterMap.get(meterName);
      const periodList = accumulator.getRegisteredSyncingPeriodList();
      for (const period of periodList) {
        instrumentMap.set(
          `${accumulator.getInstrumentBaseName()}${period}`,
          accumulator[`getNodeValueMap${period}`]()
        );
      }
    }

    // update metrics in db
    const now = new Date();
    let promises = [];
    let errors = [];
    let batchSize = 0;

    await this._extendLock();

    for (const [meterName, instrumentMap] of meterMap.entries()) {
      batchSize++;

      const uuAppMetricsObject = {
        meter: meterName,
        uuNodeId: this._uuNodeId,
        instrumentMap: instrumentMap,
        lastPmUpdate: now,
        lastPhUpdate: now,
        lastPdUpdate: now,
        lastPwUpdate: now,
        lastPmoUpdate: now,
      };

      promises.push(
        (async () => {
          try {
            await this._dao.updateByMeterAndUuNodeId(uuAppMetricsObject, this._lock);
          } catch (updateError) {
            if (updateError instanceof ObjectNotFound) {
              try {
                await this._dao.create(uuAppMetricsObject, this._lock);
              } catch (createError) {
                errors.push(JSON.stringify({ meter: meterName, uuNodeId: this._uuNodeId, error: createError }));
              }
            } else {
              errors.push(JSON.stringify({ meter: meterName, uuNodeId: this._uuNodeId, error: updateError }));
            }
          }
        })(),
      );

      if (batchSize === MAX_BATCH_UPDATE_SIZE) {
        await Promise.all(promises);
        promises = [];
        batchSize = 0;
        await this._extendLock();
      }
    }

    await Promise.all(promises);

    if (errors.length) {
      LOGGER.error("Synchronisation of some meters ended with an error.", errors.join(", "));
    }

    // load updated metrics from db
    const sharedMetricMap = new Map();
    const sharedMetrics = await this._dao.aggregateMetrics();

    if (!sharedMetrics.length) {
      return;
    }

    sharedMetrics.map(metrics => {
      sharedMetricMap.set(metrics.meter, metrics.instrumentMap);
    });

    // forward updated metrics to registered accumulators
    for (const [_, meterName, callback] of this._accumulators) {
      callback(sharedMetricMap.get(meterName));
    }

    LOGGER.debug("Synchronisation of uuAppMetrics completed.");
  }

  async _clearExpiredMetrics(period) {
    LOGGER.debug("Clearing expired uuAppMetrics.");
    let meterMap = new Map();

    // prepare metrics to be cleared
    for (const [accumulator, meterName] of this._accumulators) {
      if (!meterMap.has(meterName)) {
        meterMap.set(meterName, {});
      }

      let instrumentMap = meterMap.get(meterName);
      const periodList = accumulator.getRegisteredSyncingPeriodList();
      if (periodList.includes(period)) {
        instrumentMap[`instrumentMap.${accumulator.getInstrumentBaseName()}${period}`] = {};
      }
    }

    // update metrics in db
    const now = new Date();
    let promises = [];
    let errors = [];
    let batchSize = 0;

    await this._extendLock();

    for (const [meterName, instrumentMap] of meterMap.entries()) {
      if (!Object.keys(instrumentMap).length) {
        continue;
      }
  
      batchSize++;

      let uuAppMetricsObject = {
        meter: meterName,
        instrumentMap: instrumentMap,
      };
      uuAppMetricsObject[`last${period}Update`] = now;

      promises.push(
        (async () => {
          try {
            await this._dao.clearExpiredMetrics(
              meterName,
              `last${period}Update`,
              this._getExpiredPeriodDate(period, now),
              instrumentMap,
            );
          } catch (e) {
            if (!(e instanceof ObjectNotFound)) {
              errors.push(JSON.stringify({ meter: meterName, error: e }));
            }
          }
        })(),
      );

      if (batchSize === MAX_BATCH_UPDATE_SIZE) {
        await Promise.all(promises);
        promises = [];
        batchSize = 0;
        await this._extendLock();
      }
    }

    await Promise.all(promises);

    if (errors.length) {
      LOGGER.error("Cleanup of some meters ended with an error", errors.join(", "));
    }

    this[`_last${period}Clear`] = now;

    LOGGER.debug("Expired uuAppMetrics cleared.");
  }

  async _initializeAccumulators() {
    const uuNodeMetricMap = new Map();
    let pageInfo = {
      pageIndex: 0,
      pageSize: 1000,
    };
    let total;

    do {
      const uuNodeMetrics = await this._dao.listByUuNodeId(this._uuNodeId, pageInfo);
      for (const metrics of uuNodeMetrics.itemList) {
        uuNodeMetricMap.set(metrics.meter, {
          instrumentMap: metrics.instrumentMap,
          lastPmUpdate: metrics.lastPmUpdate,
          lastPhUpdate: metrics.lastPhUpdate,
          lastPdUpdate: metrics.lastPdUpdate,
          lastPwUpdate: metrics.lastPwUpdate,
          lastPmoUpdate: metrics.lastPmoUpdate,
        });
        try {
          // TODO lockMany
          await this._dao.lockById(metrics.id, this._lock);
        } catch (_) {}
      }
      total = uuNodeMetrics.pageInfo.total;
      pageInfo.pageIndex++;
    } while (total > pageInfo.pageIndex * pageInfo.pageSize)

    for (const [accumulator, meterName] of this._accumulators) {
      accumulator.initialize(uuNodeMetricMap.get(meterName));
    }
  }

  async _extendLock() {
    try {
      await this._lock.setExpiration(this._lockDuration);
    } catch (e) {
      if (e instanceof ExpiredLock || e.message === "UuObject lock expired.") {
        LOGGER.warn(
          "Synchronisation lock has expired. Generating a new lock.",
        );

        this._lock = new Lock(this._lock.lockCode, this._lockDuration * 2);
        let pageInfo = {
          pageIndex: 0,
          pageSize: 1000,
        };
        let total;

        do {
          const uuNodeMetrics = await this._dao.listByUuNodeId(this._uuNodeId, pageInfo);
          for (const metrics of uuNodeMetrics.itemList) {
            // TODO lockMany
            await this._dao.lockById(metrics.id, this._lock);
          }
          total = uuNodeMetrics.pageInfo.total;
          pageInfo.pageIndex++;
        } while (total > pageInfo.pageIndex * pageInfo.pageSize)
      } else {
        throw e;
      }
    }
  }

  _getPeriodToClear() {
    for (const period of ["Pmo", "Pw", "Pd", "Ph", "Pm"]) {
      if (!this[`_last${period}Clear`] || this[`_last${period}Clear`] < this._getExpiredPeriodDate(period)) {
        return period;
      }
    }
    return null;
  }

  _getExpiredPeriodDate(period, currentDate = new Date()) {
    let expiredDate = new Date(currentDate);
    switch (period) {
      case "Pm":
        return new Date(expiredDate.setSeconds(0, 0));
      case "Ph":
        return new Date(expiredDate.setMinutes(0, 0, 0));
      case "Pd":
        return new Date(expiredDate.setHours(0, 0, 0, 0));
      case "Pw":
        expiredDate.setHours(0, 0, 0, 0);
        expiredDate.setDate(currentDate.getDate() - ((currentDate.getDay() - 1 + 7) % 7));
        return new Date(expiredDate);
      case "Pmo":
        expiredDate.setHours(0, 0, 0, 0);
        expiredDate.setDate(1);
        return new Date(expiredDate);
      default:
        return new Date();
    }
  }
}

module.exports = new MetricSynchronisationService();
