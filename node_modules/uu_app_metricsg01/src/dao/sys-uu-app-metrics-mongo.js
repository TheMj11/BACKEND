"use strict";

const { Config } = require("uu_appg01_core-utils");
const { UuObjectDao } = require("uu_appg01_objectstore");
const { DbConnection } = require("uu_appg01_datastore");

const ASID = Config.get("asid");

class SysUuAppMetricsMongo extends UuObjectDao {
  async createSchema() {
    await super.createIndex({ asid: 1, meter: 1, uuNodeId: 1 }, { unique: true });
  }

  async create(uuObject, lock) {
    uuObject.asid = ASID;
    return await super.insertOne(uuObject, lock);
  }

  async listByUuNodeId(uuNodeId, pageInfo = {}) {
    const filter = {
      asid: ASID,
      uuNodeId: uuNodeId,
    };
    return await super.find(filter, pageInfo);
  }

  async aggregateMetrics() {
    const pipeline = [
      { $match: { asid: ASID } },
      {
        $project: {
          asid: 1,
          meter: 1,
          instrumentMap: { $objectToArray: "$instrumentMap" },
        },
      },
      { $unwind: "$instrumentMap" },
      {
        $project: {
          asid: 1,
          meter: 1,
          instrumentName: "$instrumentMap.k",
          instrument: { $objectToArray: "$instrumentMap.v" },
        },
      },
      { $unwind: "$instrument" },
      {
        $group: {
          _id: { asid: "$asid", meter: "$meter", instrumentName: "$instrumentName", key: "$instrument.k" },
          totalValue: { $sum: "$instrument.v" },
        },
      },
      {
        $group: {
          _id: { asid: "$_id.asid", meter: "$_id.meter", instrumentName: "$_id.instrumentName" },
          instrument: { $push: { k: "$_id.key", v: "$totalValue" } },
        },
      },
      {
        $group: {
          _id: { asid: "$_id.asid", meter: "$_id.meter" },
          instrumentMap: { $push: { k: "$_id.instrumentName", v: { $arrayToObject: "$instrument" } } },
        },
      },
      {
        $project: {
          asid: "$_id.asid",
          meter: "$_id.meter",
          _id: 0,
          instrumentMap: { $arrayToObject: "$instrumentMap" },
        },
      },
    ];
    return await super.aggregate(pipeline);
  }

  async updateByMeterAndUuNodeId(uuObject, lock) {
    const filter = {
      asid: ASID,
      meter: uuObject.meter,
      uuNodeId: uuObject.uuNodeId,
    };
    return await super.findOneAndUpdate(filter, uuObject, "NONE", lock);
  }

  async clearExpiredMetrics(meter, expiredPeriodDateKey, expiredPeriodDateValue, instrumentMap) {
    const filter = {
      $and: [{
        asid: ASID,
        meter: meter,
        [expiredPeriodDateKey]: { $lt: expiredPeriodDateValue },
        $or: [
          {
            "sys.lockHash": {
              $exists: false,
            },
          },
          {
            "sys.lockHash": {
              $exists: true,
            },
            "sys.lockExpTs": {
              $lt: new Date(),
            },
          },
        ],
      }]
    };
    const update = this._prepareUpdate({
      $set: {
        ...instrumentMap,
        [expiredPeriodDateKey]: new Date(),
      }
    });
    const db = await DbConnection.get(this.customUri);
    return await db
      .collection(this.collectionName)
      .updateMany(filter, update)
      .then((result) => {
        return result;
      });
  }

  async lockById(id, lock) {
    const filter = {
      asid: ASID,
      id: id,
    };
    return await super.lockOne(filter, lock);
  }

  async listAvailableUuNodes(lastUpdate) {
    const pipeline = [
      {
        $match: {
          $and: [
            { asid: ASID },
            { "sys.mts": { $lt: lastUpdate } },
          ],
        },
      },
      { $sort: { _id: -1 } },
      {
        $group: {
          _id: "$uuNodeId",
          document: { $first: "$$ROOT" },
        },
      },
      { $replaceRoot: { newRoot: "$document" } },
      { $project: { _id: 1, uuNodeId: 1, sys: 1 } },
      { $sort: { "sys.mts": -1 } },
    ];
    return await super.aggregate(pipeline);
  }
}

module.exports = SysUuAppMetricsMongo;
