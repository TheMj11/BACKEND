"use strict";

const Path = require("path");
const Process = require("process");
const { Sys } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config, ConfigFilesLoader, Loader, BaseError } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { Resource } = require("@opentelemetry/resources");
const { View } = require("@opentelemetry/sdk-metrics");
const { SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_VERSION } = require("@opentelemetry/semantic-conventions");
const metrics = require("@opentelemetry/api").metrics;

const MeterProvider = require("./meter-provider.js");
const InstrumentTypeMap = require("./meter.js").InstrumentTypeMap;

const APP_INFO = Sys.getAppInfo();
const ASID = Config.get("asid");
const UU_NODE_SIZE = Config.get("uu_cloud_node_size");
const METRICS_ENABLED = Config.getBoolean("uu_app_metrics_enabled");
const DEFAULT_METER_PROVIDER_NAME = "uuApp";
const METRICS_CONFIG_FILE = "metrics.json";
const LOGGER = LoggerFactory.get();

const meterProviderMap = new Map();
const meterProviderConfigMap = new Map();
const validator = new Validator(Path.join(__dirname, "api", "validation_types", "metrics-types.js"));

/**
 * @class UuApp.Metrics.MeterProviderFactory
 * @classdesc
 * Factory class for getting access to MeterProviders.
 */
class MeterProviderFactory {
  /**
   * Returns an instance of a {@link UuApp.Metrics.Meter}
   * with the configuration of the {@link UuApp.Metrics.MeterProvider}.
   *
   * @param {string} [name] Name of the meter provider.
   * @returns {MeterProvider} Instance of meter provider.
   */
  static get(name) {
    name ??= DEFAULT_METER_PROVIDER_NAME;

    if (meterProviderMap.has(name)) {
      return meterProviderMap.get(name);
    } else {
      LOGGER.debug(`Creating MeterProvider "${name}".`);
      let meterProviderConfig = MeterProviderFactory._loadConfiguration(name);
      const { meterMap, ...options } = MeterProviderFactory._parseConfiguration(meterProviderConfig, name);
      const meterProvider = new MeterProvider(name, options);
      MeterProviderFactory._createInstruments(meterProvider, meterMap);
      meterProviderMap.set(name, meterProvider);
      if (name === DEFAULT_METER_PROVIDER_NAME) {
        metrics.setGlobalMeterProvider(meterProvider);
      }
      LOGGER.debug(`MeterProvider "${name}" successfully created.`);
      return meterProvider;
    }
  }

  static getConfiguration(meterProviderName) {
    meterProviderName ??= DEFAULT_METER_PROVIDER_NAME;
    return meterProviderConfigMap.get(meterProviderName) || {};
  }

  static _loadConfiguration(meterProviderName) {
    if (meterProviderConfigMap.has(meterProviderName)) {
      return meterProviderConfigMap.get(meterProviderName);
    }

    let config;
    let readerMap = new Map();
    let resourceAttributes = {
      [SEMRESATTRS_SERVICE_NAME]: APP_INFO.uuSubApp,
      [SEMRESATTRS_SERVICE_VERSION]: APP_INFO.uuSubAppVersion,
      uuSubApp: APP_INFO.uuSubApp,
      asid: ASID,
      uuNodeSize: UU_NODE_SIZE,
      uuCloudNode:
        Process.env.UU_CLOUD_NODE_NAME ||
        `uuappg01-${APP_INFO.uuSubApp.replace("-server", "")}-${new Date().getTime()}.1.${new Date().getTime()}`,
    };
    let views = [];
    let meterMap = {};

    ConfigFilesLoader.load(METRICS_CONFIG_FILE, {
      partialConfigHandler: (partialConfig, configFile) => {
        let validationResult = validator.validate("metricsPartialType", partialConfig);
        if (!validationResult.isValid()) {
          throw new BaseError(
            `uuAppMetrics configuration file [${configFile}] is not valid:\n` +
              `${JSON.stringify(validationResult.getValidationErrorMap(), null, 2)}`,
          );
        }

        const meterProviderConfig = (partialConfig.meterProviderMap || {})[meterProviderName] || {};

        // Merges resource attributes.
        if (meterProviderConfig.resource) {
          resourceAttributes = {
            ...resourceAttributes,
            ...meterProviderConfig.resource,
          };
        }

        // Adds views.
        if (meterProviderConfig.views?.length) {
          views.push(...meterProviderConfig.views);
        }

        // Merges readers.
        if (METRICS_ENABLED && meterProviderConfig.readers) {
          meterProviderConfig.readers.forEach((readerConfig) => {
            let exportIntervalMillis;
            typeof readerConfig.exportIntervalMillis === "string"
              ? (exportIntervalMillis = Config.getNumber(readerConfig.exportIntervalMillis))
              : (exportIntervalMillis = readerConfig.exportIntervalMillis);

            if (readerMap.has(readerConfig.name)) {
              let existingReaderConfig = readerMap.get(readerConfig.name);
              if (readerConfig.realization) {
                if (existingReaderConfig.realization) {
                  // TODO allow overrides?
                  throw new BaseError(
                    `uuAppMetrics configuration file [${configFile}] is not valid. ` +
                      `Overriding the realization of the existing reader [${readerConfig.name}] is not allowed.`,
                  );
                } else {
                  existingReaderConfig.realization = readerConfig.realization;
                }
              }

              if (readerConfig.exporter) {
                if (existingReaderConfig.exporter) {
                  // TODO allow overrides?
                  throw new BaseError(
                    `uuAppMetrics configuration file [${configFile}] is not valid. ` +
                      `Override of the existing reader's [${readerConfig.name}] exporter is not allowed.`,
                  );
                } else {
                  existingReaderConfig.exporter = {
                    ...readerConfig.exporter,
                  };
                }
              }

              if (exportIntervalMillis != null) {
                // TODO throw error instead?
                existingReaderConfig.exportIntervalMillis = exportIntervalMillis;
              } else if (
                readerConfig.exportIntervalMillisDefault != null &&
                existingReaderConfig.exportIntervalMillis == null
              ) {
                existingReaderConfig.exportIntervalMillis = readerConfig.exportIntervalMillisDefault;
              }

              if (readerConfig.instrumentNameIncludeListOverride) {
                // TODO only if !!length ?
                existingReaderConfig.instrumentNameIncludeList = readerConfig.instrumentNameIncludeListOverride;
              } else if (readerConfig.instrumentNameIncludeList) {
                existingReaderConfig.instrumentNameIncludeList = Array.from(
                  new Set([
                    ...existingReaderConfig.instrumentNameIncludeList,
                    ...readerConfig.instrumentNameIncludeList,
                  ]),
                );
              }

              if (readerConfig.instrumentNameExcludeListOverride) {
                // TODO only if !!length ?
                existingReaderConfig.instrumentNameExcludeList = readerConfig.instrumentNameExcludeListOverride;
              } else if (readerConfig.instrumentNameExcludeList) {
                existingReaderConfig.instrumentNameExcludeList = Array.from(
                  new Set([
                    ...existingReaderConfig.instrumentNameExcludeList,
                    ...readerConfig.instrumentNameExcludeList,
                  ]),
                );
              }
            } else {
              readerMap.set(readerConfig.name, {
                name: readerConfig.name,
                realization: readerConfig.realization,
                exporter: readerConfig.exporter,
                exportIntervalMillis: exportIntervalMillis ?? readerConfig.exportIntervalMillisDefault,
                instrumentNameIncludeList:
                  readerConfig.instrumentNameIncludeListOverride || readerConfig.instrumentNameIncludeList || [],
                instrumentNameExcludeList:
                  readerConfig.instrumentNameExcludeListOverride || readerConfig.instrumentNameExcludeList || [],
              });
            }
          });
        }

        if (partialConfig.meterProviderMap) {
          delete partialConfig.meterProviderMap;
        }

        // Adds configuration of meters associated with meter provider to meterMap.
        if (partialConfig.meterMap) {
          for (const [meterName, meterConfig] of Object.entries(partialConfig.meterMap)) {
            if (
              meterConfig.meterProvider === meterProviderName ||
              (!meterConfig.meterProvider && meterProviderName === DEFAULT_METER_PROVIDER_NAME)
            ) {
              const meterKey = meterConfig.version ? `${meterName}-${meterConfig.version}` : meterName;
              if (!meterMap[meterKey]) {
                meterMap[meterKey] = {
                  version: meterConfig.version,
                  meterProvider: meterProviderName,
                  instrumentList: meterConfig.instrumentList || [],
                  options: meterConfig.options || {},
                };
              } else {
                meterMap[meterKey].options = {
                  // TODO throw error instead?
                  ...meterMap[meterKey].options,
                  ...meterConfig.options,
                };
                meterMap[meterKey].instrumentList.push(...(meterConfig.instrumentList || [])); // TODO throw error when there are multiple instruments with the same name
              }
            }
          }

          delete partialConfig.meterMap;
        }
      },
      finalConfigHandler: () => {
        config = {
          meterProviderMap: {
            [meterProviderName]: {
              resource: resourceAttributes,
              readers: Array.from(readerMap.values()),
              views,
            },
          },
          meterMap,
        };

        let validationResult = validator.validate("metricsType", config);
        if (!validationResult.isValid()) {
          throw new BaseError(
            `Global uuAppMetrics configuration is not valid due to invalid configuration overrides:\n` +
              `${JSON.stringify(validationResult.getValidationErrorMap(), null, 2)}`,
          );
        }
      },
    });

    config = MeterProviderFactory._markDisabledInstruments(config, meterProviderName);

    meterProviderConfigMap.set(meterProviderName, config);

    return config;
  }

  static _parseConfiguration(meterProviderConfig, meterProviderName) {
    let views = [];
    meterProviderConfig.meterProviderMap[meterProviderName].views.forEach((opts) => {
      if (opts.instrumentType) {
        // Converts instrumentType to naming convention supported by openTelemetry.
        opts.instrumentType = opts.instrumentType.replaceAll(/([a-z])([A-Z])/g, "$1_$2").toUpperCase();
      }
      views.push(new View(opts));
    });

    const readerMap = MeterProviderFactory._createReaders(
      meterProviderConfig.meterProviderMap[meterProviderName].readers,
      meterProviderName,
    );

    return {
      resource: Resource.default().merge(
        new Resource(meterProviderConfig.meterProviderMap[meterProviderName].resource),
      ),
      views: views.length ? views : undefined,
      readerMap,
      meterMap: meterProviderConfig.meterMap,
    };
  }

  static _createReaders(readersConfig, meterProviderName) {
    let readerMap = new Map();
    readersConfig.forEach((readerConfig) => {
      if (readerMap.has(readerConfig.name)) {
        throw new BaseError(
          `MeterProvider initialization failed: Configuration contains multiple MetricReaders with the same name "${readerConfig.name}".`,
        );
      }

      const exporterRealizationPath = readerConfig.exporter?.realization;
      const readerRealizationPath = readerConfig.realization;
      const modulePath = Config.get("server_root");

      // Loads Exporter realization.
      let Exporter;
      try {
        Exporter = exporterRealizationPath && Loader.loadRealization(modulePath, exporterRealizationPath, false);
      } catch (e) {
        throw new BaseError("MetricExporter initialization failed: Unable to load realization.", e);
      }

      // Loads Reader realization.
      let Reader;
      try {
        switch (readerRealizationPath) {
          case "defaultMetricReader":
            Reader = require("./metric_readers/metric-reader.js");
            break;
          case "defaultPeriodicExportingMetricReader":
            Reader = require("./metric_readers/periodic-exporting-metric-reader.js");
            break;
          default:
            Reader = Loader.loadRealization(modulePath, readerRealizationPath, false);
        }
      } catch (e) {
        throw new BaseError("MetricReader initialization failed: Unable to load realization.", e);
      }

      let exportIntervalMillis = readerConfig.exportIntervalMillis;
      let aggregationTemporality = readerConfig.exporter?.aggregationTemporality === "delta" ? 0 : 1;
      switch (readerConfig.exporter?.aggregationTemporality) {
        case "delta":
          aggregationTemporality = 0;
          break;
        case "cumulative":
        default:
          aggregationTemporality = 1;
      }

      // Creates instance of the Reader and its Exporter.
      const exporter = Exporter
        ? new Exporter(meterProviderName, { aggregationTemporality, exportIntervalMillis })
        : undefined;
      const reader = new Reader(meterProviderName, {
        instrumentNameIncludeList: readerConfig.instrumentNameIncludeList,
        instrumentNameExcludeList: readerConfig.instrumentNameExcludeList,
        exporter,
        exportIntervalMillis,
      });

      readerMap.set(readerConfig.name, reader);
    });

    return readerMap;
  }

  static _createInstruments(meterProvider, meterMap) {
    for (const [meterKey, meterConfig] of Object.entries(meterMap)) {
      const meter = meterProvider.getMeter(
        meterKey.replace(`-${meterConfig.version}`, ""),
        meterConfig.version,
        meterConfig.options,
      );
      meterConfig.instrumentList.forEach(({ name, type, ...options }) => {
        if (options.valueType) {
          options.valueType = options.valueType === "int" ? 0 : 1;
        }

        switch (type) {
          case InstrumentTypeMap.GAUGE:
            return meter.createGauge(name, options);
          case InstrumentTypeMap.HISTOGRAM:
            return meter.createHistogram(name, options);
          case InstrumentTypeMap.COUNTER:
            return meter.createCounter(name, options);
          case InstrumentTypeMap.UP_DOWN_COUNTER:
            return meter.createUpDownCounter(name, options);
          case InstrumentTypeMap.OBSERVABLE_GAUGE:
            return meter.createObservableGauge(name, options);
          case InstrumentTypeMap.OBSERVABLE_COUNTER:
            return meter.createObservableCounter(name, options);
          case InstrumentTypeMap.OBSERVABLE_UP_DOWN_COUNTER:
            return meter.createObservableUpDownCounter(name, options);
          default:
            throw new BaseError(`Instrument type "${type}" is not supported.`);
        }
      });
    }
  }

  static _markDisabledInstruments(meterProviderConfig, meterProviderName) {
    const readers = meterProviderConfig.meterProviderMap[meterProviderName].readers;
    let instrumentNameIncludeSet = new Set();
    readers.forEach((reader) => {
      for (const instrumentNamePattern of reader.instrumentNameIncludeList) {
        instrumentNameIncludeSet.add(instrumentNamePattern);
      }
    });
    const instrumentNameIncludeList = Array.from(instrumentNameIncludeSet);

    for (const [meterName, meter] of Object.entries(meterProviderConfig.meterMap)) {
      let disableMeter = true;

      meter.instrumentList.forEach((instrument, index) => {
        if (
          !METRICS_ENABLED ||
          !instrumentNameIncludeList.some((expr) => `${meterName}.${instrument.name}`.match(expr)) ||
          readers.every((reader) => {
            reader.instrumentNameExcludeList.some((expr) => `${meterName}.${instrument.name}`.match(expr)) ||
              reader.instrumentNameIncludeList.every((expr) => !`${meterName}.${instrument.name}`.match(expr));
          })
        ) {
          meterProviderConfig.meterMap[meterName].instrumentList[index].disabled = true;
          LOGGER.info(`Disabling instrument "${meterName}.${instrument.name}".`);
        } else {
          disableMeter = false;
        }
      });

      if (disableMeter) {
        meterProviderConfig.meterMap[meterName].options.disabled = true;
      }
    }

    return meterProviderConfig;
  }
}

module.exports = MeterProviderFactory;
