"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { BaseError } = require("uu_appg01_core-utils");

const Meter = require("../meter.js");
const AttributesHelper = require("../utils/attributes-helper.js");

const PERIOD_LIST = ["", "Pm", "Ph", "Pd", "Pw", "Pmo"];
const SUPPORTED_INSTRUMENT_TYPE_LIST = ["observableUpDownCounter"];

const LOGGER = LoggerFactory.get();

class BaseMetricAccumulator {
  constructor(meter, instrumentBaseName) {
    if (!(meter instanceof Meter)) {
      throw new BaseError(`Invalid argument: Expected an instance of Meter, but received ${meter?.constructor?.name}.`);
    }
    if (!instrumentBaseName || typeof instrumentBaseName !== "string") {
      throw new BaseError("Invalid argument: Instrument base name name must be a non-empty string.");
    }

    this._meterCode = `${meter.getMeterProviderName()}.${meter.getName()}`;
    this._instrumentBaseName = instrumentBaseName;

    this._nodeValueMap = new Map();
    this._nodeValueMapPm = new Map();
    this._nodeValueMapPh = new Map();
    this._nodeValueMapPd = new Map();
    this._nodeValueMapPw = new Map();
    this._nodeValueMapPmo = new Map();

    this._registeredPeriodList = this._registerInstrumentCallbacks(
      meter,
      instrumentBaseName,
      (result, period) => {
        for (let [attributesHash, value] of this[`_nodeValueMap${period}`]) {
          result.observe(value, AttributesHelper.decodeAttributes(attributesHash));
        }
      }
    );

    this._lastAddTime = null;
  }

  add(value, attributes = {}, atTime = new Date()) {
    const key = AttributesHelper.encodeAttributes(attributes);

    for (const period of this._registeredPeriodList) {
      if (period) {
        if (this._lastAddTime && !this._doesPeriodMatch(atTime, this._lastAddTime, period)) {
          this[`_nodeValueMap${period}`].clear();
          this[`_nodeValueMap${period}`].set(key, value);
        } else {
          this[`_nodeValueMap${period}`].set(key, (this[`_nodeValueMap${period}`].get(key) || 0) + value);
        }
      } else {
        this._nodeValueMap.set(key, (this._nodeValueMap.get(key) || 0) + value);
      }
    }

    this._lastAddTime = atTime;
  }

  getNodeValueMap() {
    return this._nodeValueMap;
  }

  getNodeValueMapPm() {
    return this._nodeValueMapPm;
  }

  getNodeValueMapPh() {
    return this._nodeValueMapPh;
  }

  getNodeValueMapPd() {
    return this._nodeValueMapPd;
  }

  getNodeValueMapPw() {
    return this._nodeValueMapPw;
  }

  getNodeValueMapPmo() {
    return this._nodeValueMapPmo;
  }

  getInstrumentBaseName() {
    return this._instrumentBaseName;
  }

  getRegisteredPeriodList() {
    return this._registeredPeriodList;
  }

  _doesPeriodMatch(metricDate, lastUpdateDate, period) {
    switch (period) {
      case "Pm":
        return metricDate.getMinutes() === lastUpdateDate.getMinutes();
      case "Ph":
        return metricDate.getUTCHours() === lastUpdateDate.getUTCHours();
      case "Pd":
        return metricDate.getDay() === lastUpdateDate.getDay();
      case "Pw":
        return this._doesWeekMatch(metricDate, lastUpdateDate);
      case "Pmo":
        return metricDate.getMonth() === lastUpdateDate.getMonth();
      default:
        return false;
    }
  }

  _doesWeekMatch(date1, date2) {
    let weekStart1 = new Date(date1);
    weekStart1.setDate(date1.getDate() - ((date1.getDay() - 1 + 7) % 7));

    let weekStart2 = new Date(date2);
    weekStart2.setDate(date2.getDate() - ((date2.getDay() - 1 + 7) % 7));

    return weekStart1.getDate() === weekStart2.getDate();
  }

  _registerInstrumentCallbacks(meter, instrumentBaseName, callback, options = {}) {
    const meterProviderName = meter.getMeterProviderName();
    const meterName = meter.getName();
    const logger = options.logger || LOGGER;
    const instrumentNamePostfix = options.instrumentNamePostfix || "";
    let registeredPeriodList = [];

    for (const period of PERIOD_LIST) {
      const instrumentName = `${instrumentBaseName}${period}${instrumentNamePostfix}`;
      const instrumentFullName = `${meterProviderName}.${meterName}.${instrumentName}`;

      let instrument;
      try {
        instrument = meter.getInstrument(instrumentName);
      } catch (_) {
        logger.warn(`Instrument ${instrumentFullName} does not exist and therefore will not be used in the accumulator.`);
        continue;
      }

      if (instrument._descriptor.disabled) {
        continue;
      }

      const instrumentType = this._convertInstrumentType(instrument._descriptor.type);
      if (!SUPPORTED_INSTRUMENT_TYPE_LIST.includes(instrumentType)) {
        logger.error(
          `Type of ${instrumentFullName} instrument [${instrumentType}] is not supported by accumulator and therefore will not be used. ` +
          `Supported types are [${SUPPORTED_INSTRUMENT_TYPE_LIST.join(", ")}].`
        );
        continue;
      }

      instrument.addCallback((result) => {
        callback(result, period);
      });

      registeredPeriodList.push(period);
    }

    return registeredPeriodList;
  }

  _convertInstrumentType(instrumentType) {
    return instrumentType
      .split("_")
      .map((value, index) => {
        return index === 0
          ? value.toLowerCase()
          : value[0].toUpperCase() + value.slice(1).toLowerCase();
      })
      .join("");
  }
}

module.exports = BaseMetricAccumulator;
