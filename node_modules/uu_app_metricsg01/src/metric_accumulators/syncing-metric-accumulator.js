"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { BaseError } = require("uu_appg01_core-utils");
const { DaoFactory } = require("uu_appg01_objectstore");

const BaseMetricAccumulator = require("./base-metric-accumulator.js");
const AttributesHelper = require("../utils/attributes-helper.js");
const MetricSynchronisationService = require("../utils/metric-synchronisation-service.js");

const LOGGER = LoggerFactory.get();

// TODO asid metrics - aggregation over all awids
class SyncingMetricAccumulator extends BaseMetricAccumulator {
  constructor(meter, instrumentBaseName) {
    super(meter, instrumentBaseName);

    this._dao = DaoFactory.getDao("sysUuAppMetrics");

    this._totalValueMap = new Map();
    this._totalValueMapPm = new Map();
    this._totalValueMapPh = new Map();
    this._totalValueMapPd = new Map();
    this._totalValueMapPw = new Map();
    this._totalValueMapPmo = new Map();

    this._registeredSyncingPeriodList = this._registerInstrumentCallbacks(
      meter,
      instrumentBaseName,
      (result, period) => {
        for (let [attributesHash, value] of this[`_totalValueMap${period}`]) {
          result.observe(value, AttributesHelper.decodeAttributes(attributesHash));
        }
      },
      {
        logger: LOGGER,
        instrumentNamePostfix: "Total",
      },
    );

    this._registeredSyncingPeriodList.forEach((period) => {
      if (!this._registeredPeriodList.includes(period)) {
        this._registeredPeriodList.push(period);
      }
    });

    if (this._registeredSyncingPeriodList.length) {
      MetricSynchronisationService.register(this, this._meterCode, this._syncCallback);
    }
  }

  add(value, attributes = {}, atTime = new Date()) {
    const key = AttributesHelper.encodeAttributes(attributes);

    for (const period of this._registeredSyncingPeriodList) {
      if (period) {
        if (this._lastAddTime && !this._doesPeriodMatch(atTime, this._lastAddTime, period)) {
          this[`_totalValueMap${period}`].clear();
          this[`_totalValueMap${period}`].set(key, value);
        } else {
          // TODO Use heuristic to add value * node count?
          this[`_totalValueMap${period}`].set(key, (this[`_totalValueMap${period}`].get(key) || 0) + value);
        }
      } else {
        // TODO Use heuristic to add value * node count?
        this._totalValueMap.set(key, (this._totalValueMap.get(key) || 0) + value);
      }
    }

    super.add(value, attributes, atTime);
  }

  getTotalValueMap() {
    return this._totalValueMap;
  }

  getTotalValueMapPm() {
    return this._totalValueMapPm;
  }

  getTotalValueMapPh() {
    return this._totalValueMapPh;
  }

  getTotalValueMapPd() {
    return this._totalValueMapPd;
  }

  getTotalValueMapPw() {
    return this._totalValueMapPw;
  }

  getTotalValueMapPmo() {
    return this._totalValueMapPmo;
  }

  getRegisteredSyncingPeriodList() {
    return this._registeredSyncingPeriodList;
  }

  initialize(metrics) {
    if (this._initialized) {
      // TODO
      throw new BaseError("MetricAccumulator has been already initialized.");
    } else {
      this._initialized = true;
    }

    if (!metrics) {
      return;
    }

    const now = new Date();
    for (const period of this._registeredPeriodList) {
      if (period) {
        if (metrics[`last${period}Update`] && this._doesPeriodMatch(now, metrics[`last${period}Update`], period)) {
          this[`_nodeValueMap${period}`] = new Map(
            Object.entries(metrics.instrumentMap[`${this._instrumentBaseName}${period}`] || {}),
          );
        }
      } else {
        this._nodeValueMap = new Map(Object.entries(metrics.instrumentMap[this._instrumentBaseName] || {}));
      }
    }

    this._lastAddTime = now;
  }

  _syncCallback(sharedMetrics, atTime = new Date()) {
    if (!sharedMetrics) {
      return;
    }

    for (const period of this._registeredSyncingPeriodList) {
      if (
        period &&
        this._lastAddTime &&
        this[`_nodeValueMap${period}`].size &&
        !this._doesPeriodMatch(atTime, this._lastAddTime, period)
      ) {
        this[`_nodeValueMap${period}`].clear();
      }

      if (!sharedMetrics[`${this._instrumentBaseName}${period}`]) {
        continue;
      }

      this[`_totalValueMap${period}`] = new Map(Object.entries(sharedMetrics[`${this._instrumentBaseName}${period}`]));
    }
  }
}

module.exports = SyncingMetricAccumulator;
