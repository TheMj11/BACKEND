const path = require("path");
const fs = require("fs-extra");
const stream = require("stream");
const util = require("util");
const child_process = require("child_process");
const ProjectConfig = require("uu_appg01_devkit-common/src/config/project-config.js");

const fs_access = util.promisify(fs.access);
const EXIT_CODE_SUPPRESS_NPM_ERR = 1;

function tryFile(fname) {
  return fs.existsSync(fname) ? fname : null;
}
function resolveByTemplateType(filePath, templateType = null) {
  let filePath0 = path.resolve(filePath);
  let name = path.basename(filePath0);
  let nameNoExt = name.replace(/\.[^.]*$/, "");
  let dotExt = name.substr(nameNoExt.length);
  let prefix = path.join(path.dirname(filePath0), nameNoExt);
  if (templateType == null) templateType = getTemplateInfo().type;
  // devkit type builds as standard backend library...;
  if (templateType != null) templateType = templateType.replace("devkit", "lib");

  return (
    tryFile(prefix + "." + templateType + dotExt) || // xyz.uu5-lib.js, xyz.nodejs-lib.js
    (templateType === "lib" ? tryFile(prefix + "." + "iso-" + templateType + dotExt) : "") || // xyz.iso-lib.js
    tryFile(prefix + "." + templateType.replace(/-.*/, "") + dotExt) || // xyz.uu5.js
    tryFile(prefix + "." + templateType.replace(/^[^-]*-/, "") + dotExt) || // xyz.lib.js
    tryFile(prefix + dotExt) // xyz.js
  );
}

function requireByTemplateType(filePath, templateType = null) {
  let fileByType = resolveByTemplateType(filePath, templateType);
  return require(fileByType || filePath);
}

// TODO Remove, use 'Package.getSingletonSync("package.json").templateInfo' instead.
var templateInfo;
function getTemplateInfo() {
  if (!templateInfo) {
    const Package = require("uu_appg01_devkit-common/src/tools/package.js");
    templateInfo = Package.getSingletonSync("package.json").templateInfo;
  }
  return templateInfo;
}

function npmScriptBinFile(binFileName) {
  let fileName = process.platform === "win32" ? binFileName + ".cmd" : binFileName;
  let partialPath = path.join("node_modules", ".bin", fileName);
  let inDevkitPath = path.resolve(__dirname, "..", "..", partialPath);
  if (fs.existsSync(inDevkitPath)) return inDevkitPath; // when using pnpm
  if (!fs.existsSync(partialPath)) {
    // node_modules/.bin folder might not exist if using npm@7 workspaces (the folder will be in workspace root)
    let inWorkspacePath = path.join("..", partialPath);
    if (!fs.existsSync(inWorkspacePath)) {
      throw new Error(`Unable to find executabe for npm script ${binFileName}. Should have been at: ${partialPath}`);
    }
    partialPath = inWorkspacePath;
  }
  return partialPath; // when using npm
}

function verifyClass(sourceCode, methodNames) {
  if (!Array.isArray(methodNames)) {
    methodNames = [methodNames];
  }
  const { Parser } = require("acorn");
  let parsedSourceCode = Parser.parse(sourceCode, { sourceType: "module", ecmaVersion: 2023 });
  let klass;
  // klass, i.e model, contains only one class
  for (let entity of parsedSourceCode.body) {
    if (entity.type === "ClassDeclaration") {
      klass = entity;
      break;
    }
  }
  if (!klass) {
    console.log(`Source file doesn't contain a class`);
    process.exit(1);
  }
  // find if there is a method for this command already
  for (let entity of klass.body.body) {
    let existingMethod;
    if (
      (existingMethod =
        entity.type === "MethodDefinition" && methodNames.find((methodName) => entity.key.name === methodName))
    ) {
      console.log(`Class ${klass.id.name} already contains method ${existingMethod}`);
      process.exit(1);
    }
  }
}

async function fileExists(path) {
  try {
    await fs_access(path, fs.constants.F_OK);
    return true;
  } catch (err) {
    if (err.code && err.code === "ENOENT") {
      return false;
    }
    throw err;
  }
}

function compareModificationTime(file1, file2) {
  let stats1 = fs.lstatSync(file1, { bigint: true });
  let stats2 = fs.lstatSync(file2, { bigint: true });
  return (stats1.mtimeNs || stats1.mtimeMs) - (stats2.mtimeNs || stats2.mtimeMs);
}

/**
 *
 * @param {*} cmdString
 * @param {*} options
 * @param {options.silent} If true, nothing is output. Resolved Promise will contain { stdout, stderr } containing respective outputs.
 * @param {options.copyToBuffer} (ignored if "silent" is true) If true, output is shown during process execution and will be also in resolved Promise as { stdout, stderr }.
 */
async function exec(cmdString, { silent, copyToBuffer, ...spawnOpts } = {}) {
  return new Promise((resolve, reject) => {
    // spawn the child process and filter "npm ERR! " messages out of it
    let child = child_process.spawn(cmdString, {
      shell: true,
      cwd: process.cwd(),
      stdio: silent || copyToBuffer ? "pipe" : ["inherit", "inherit", "pipe"],
      ...spawnOpts,
    });
    if ("stdio" in spawnOpts) silent = copyToBuffer = false;
    if (silent) copyToBuffer = false;

    let buffer = Buffer.from("");
    let childFilteredStderr = silent || copyToBuffer ? new WritableBufferStream() : process.stderr;

    if (!("stdio" in spawnOpts)) {
      child.stderr.on("data", (chunk) => {
        buffer = Buffer.concat([buffer, Buffer.from(chunk)]);
        let lines = buffer.toString().split("\n");
        buffer = Buffer.from(lines.pop());
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          childFilteredStderr.write(line + "\n");
          if (copyToBuffer) process.stderr.write(line + "\n");
        }
      });
    }

    let stdoutBufferStream = new WritableBufferStream();
    if (silent || copyToBuffer) {
      child.stdout.pipe(stdoutBufferStream);
      if (!silent) child.stdout.pipe(process.stdout, { end: false });
    }

    child.on("exit", async (code) => {
      let result, error;
      try {
        // only output "npm ERR" buffered lines if the status code of the child is unexpected
        if (code !== EXIT_CODE_SUPPRESS_NPM_ERR) childFilteredStderr.write(buffer.toString());
      } catch (e) {
        error = e;
      }
      if (silent || copyToBuffer) {
        await util.promisify(childFilteredStderr.end).call(childFilteredStderr);
        result = {
          stdout: stdoutBufferStream.toBuffer().toString(),
          stderr: childFilteredStderr.toBuffer().toString(),
        };
        if (error || code !== 0) {
          error = Object.assign(error || new Error("Child process ended with code " + code), result);
        }
      }
      if (!error && code === 0) resolve(result);
      else reject(error);
    });
  });
}

class WritableBufferStream extends stream.Writable {
  constructor(...args) {
    super(...args);
    this._chunks = [];
  }

  _write(chunk, encoding, callback) {
    this._chunks.push(Buffer.from(chunk));
    callback(null);
  }

  toBuffer() {
    return Buffer.concat(this._chunks);
  }
}

async function forwardTaskToUu5Devkit(task, ...args) {
  let Uu5DevkitPlugin;
  try {
    Uu5DevkitPlugin = require(require.resolve("uu5devkitg01-plugin", { paths: ["."] }));
  } catch (e) {
    if (e?.code !== "MODULE_NOT_FOUND") throw e;
    console.error(
      require("chalk").red("ERROR") +
        " This and other tasks related to frontend uu5Libraries/uu5Apps are now done by uu5devkitg01-plugin instead of being directly included in uu_appg01_devkit >= 6.0.0. Either reinstall node_modules (if project is already upgraded) or run `npm run uuAppDevKitUpgrade` to do the upgrade. You can also check release notes and recommended update guidelines.",
    );
    process.exit(1);
  }
  if (args[0] instanceof ProjectConfig) args = [args[0].commandLineConfig];
  await Uu5DevkitPlugin.Tasks[task](...args);
}

module.exports = {
  npmScriptBinFile,
  resolveByTemplateType,
  requireByTemplateType,
  getTemplateInfo,
  verifyClass,
  fileExists,
  compareModificationTime,
  exec,
  forwardTaskToUu5Devkit,
  EXIT_CODE_SUPPRESS_NPM_ERR,
};
