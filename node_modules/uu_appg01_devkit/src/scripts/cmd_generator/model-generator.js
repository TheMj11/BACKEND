const util = require("util");
const path = require("path");
const fs = require("fs-extra");
const fs_readFile = util.promisify(fs.readFile);
const fs_writeFile = util.promisify(fs.writeFile);
const { evalTemplate, processFile } = require("uu_appg01_devkit-common/src/tools/template-helpers.js");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const PackageManager = require("uu_appg01_devkit-common/src/tools/package-manager.js");
const { verifyClass, fileExists } = require("../../tools/helpers");
const { uuAppJsonPath } = require("../../config/paths");
const os = require("os");

class ModelGenerator {

  constructor(context, executionQueue) {
    this.context = JSON.parse(JSON.stringify(context));
    this.modelPath = path.normalize(`${context.sourceCodePath}/abl/${context.classFile}-abl.js`);
    this.modelTemplate = path.normalize(`${__dirname}/templates/model.js`);
    this.twoPhaseCmdModelTemplate = path.normalize(`${__dirname}/templates/model-two-phase-cmd.js`);
    this.modelMethodTemplate = path.normalize(`${__dirname}/templates/model-method.js`);
    this.modelMethodBodyTemplate = path.normalize(`${__dirname}/templates/model-method-body.js`);
    this.modelMethodBodyTwoPhaseCmdTemplate = path.normalize(`${__dirname}/templates/model-method-body-two-phase-cmd.js`);
    this.modelMethodBodyFinalizeCmdTemplate = path.normalize(`${__dirname}/templates/model-method-body-finalize-cmd.js`);
    this.modelMethodBodyFinalizeRollbackCmdTemplate = path.normalize(`${__dirname}/templates/model-method-body-rollback-finalize-cmd.js`);
    this.modelWarningTemplate = path.normalize(`${__dirname}/templates/model-warning.js`);
    this.context.daoModifier = context.daoStub ? "" : "// ";
    this.executionQueue = executionQueue;
  }

  async execute() {
    let finalizeCmdName = `_${this.context.cmdName}Finalize`;
    let finalizeRollbackCmdName = `_${this.context.cmdName}FinalizeRollback`;
    let modelMethodBodyContext = {};
    if (this.context.isTwoPhase) {
      let uuAppJson = {};
      if (await fileExists(uuAppJsonPath)) {
        uuAppJson = JSON.parse(await fs_readFile(uuAppJsonPath, "utf-8"));
      }
      modelMethodBodyContext = {
        ...this.context,
        product: uuAppJson.product,
        finalizeCmdName: finalizeCmdName,
        finalizeCmdErrorName: `_${this.context.errorName}Finalize`,
        finalizeCmdValidationType: this.context.validationTypeList[1],
        finalizeRollbackCmdName: finalizeRollbackCmdName,
        finalizeRollbackCmdErrorName: `_${this.context.errorName}FinalizeRollback`,
        finalizeRollbackCmdValidationType: this.context.validationTypeList[2],
      };
    }
    this.context.modelMethodBody = this.context.validations
      ? await evalTemplate(
        this.context.isTwoPhase
          ? this.modelMethodBodyTwoPhaseCmdTemplate
          : this.modelMethodBodyTemplate, { ...this.context, product: modelMethodBodyContext.product, validationType: this.context.validationType || this.context.validationTypeList[0] })
      : "";
    if (await fileExists(this.modelPath)) {
      console.log(`Checking contents of ${this.modelPath}`);
      let currentModel = await fs_readFile(this.modelPath, "utf8");
      verifyClass(currentModel, this.context.isTwoPhase ? [this.context.cmdName, finalizeCmdName, finalizeRollbackCmdName] : this.context.cmdName);

      // 1) add method
      let idx = currentModel.indexOf("constructor"); // this is where constructor is
      if (idx === -1) {
        console.log("The command can be added only to abl classes with constructor");
        process.exit(1);
      }
      idx = currentModel.indexOf("}", idx) + 1; // constructor end
      let cmdMethods = await evalTemplate(this.modelMethodTemplate, this.context);
      if (this.context.isTwoPhase) {
        cmdMethods += os.EOL + await evalTemplate(
          this.modelMethodTemplate,
          {
            ...this.context,
            cmdName: finalizeCmdName,
            modelMethodBody: await evalTemplate(this.modelMethodBodyFinalizeCmdTemplate, modelMethodBodyContext)
          }
        );
        cmdMethods += os.EOL + await evalTemplate(
          this.modelMethodTemplate, 
          {
            ...this.context,
            cmdName: finalizeRollbackCmdName,
            modelMethodBody: await evalTemplate(this.modelMethodBodyFinalizeRollbackCmdTemplate, modelMethodBodyContext)
          }
        );
      }
      let newModel = `${currentModel.substring(0, idx)}${os.EOL}${os.EOL}  ${cmdMethods.trim()}${currentModel.substring(idx)}`;

      // 2) add warning
      if (this.context.warnings.length !== 0 || this.context.isTwoPhase) {
        let warning = await this._getWarnings();
        idx = newModel.indexOf("WARNINGS"); // warnings' start
        idx = newModel.indexOf("{", idx) + 1; // warnings' body start
        newModel = `${newModel.substring(0, idx)}${os.EOL}  ${warning.trim()},${newModel.substring(idx)}`;
      }

      this.executionQueue.addEvent(async () => {
        // modify the code
        console.log(`Modifying ${this.modelPath}`);
        await fs_writeFile(this.modelPath, newModel);
      });
    } else {
      this.context.cmdMethod = await evalTemplate(this.modelMethodTemplate, this.context);
      this.context.cmdWarning = (this.context.warnings.length !== 0 || this.context.isTwoPhase) ? await this._getWarnings() : "";
      if (this.context.isTwoPhase) {
        this.context.finalizeCmdMethod = await evalTemplate(
          this.modelMethodTemplate,
          {
            ...this.context,
            cmdName: finalizeCmdName,
            modelMethodBody: await evalTemplate(this.modelMethodBodyFinalizeCmdTemplate, modelMethodBodyContext)
          }
        );
        this.context.finalizeRollbackCmdMethod = await evalTemplate(
          this.modelMethodTemplate,
          {
            ...this.context,
            cmdName: finalizeRollbackCmdName,
            modelMethodBody: await evalTemplate(this.modelMethodBodyFinalizeRollbackCmdTemplate, modelMethodBodyContext)
          }
        );
      }
      this.executionQueue.addEvent(async () => {
        console.log(`Creating ${this.modelPath}`);
        await processFile(this.context.isTwoPhase ? this.twoPhaseCmdModelTemplate : this.modelTemplate, this.modelPath, this.context);
      });
    }

    if (this.context.isTwoPhase) {
      // ensure all required dependencies are installed
      this.executionQueue.addEvent(async () => {
        this._ensureDependencies(["uu_consoleg02-uulib", "uu_i18ng01"]);
      });
    }
  }

  async _getWarnings() {
    let warnings = [];
    if (this.context.isTwoPhase) {
      let cmdNames = [this.context.cmdName, `_${this.context.cmdName}Finalize`, `_${this.context.cmdName}FinalizeRollback`];
      let errorNames = [this.context.errorName, `_${this.context.errorName}Finalize`, `_${this.context.errorName}FinalizeRollback`];
      for (let i = 0; i < cmdNames.length; i++) {
        warnings.push({
          cmdName: cmdNames[i],
          errorName: errorNames[i],
          code: "unsupportedKeys",
          message: "DtoIn contains unsupported keys.",
        });
      }
    }
    warnings = warnings.concat(this.context.warnings);

    let result = [];
    for (let warning of warnings) {
      let warningContext = {
        cmdName: warning.cmdName || this.context.cmdName,
        errorName: warning.errorName || this.context.errorName,
        code: warning.code,
        message: warning.message,
        pascalCasedCode: warning.code[0].toUpperCase() + warning.code.slice(1),
      }
      result.push(`  ${(await evalTemplate(this.modelWarningTemplate, warningContext)).trim()}`);
    }
    return result.join(`,${os.EOL}`);
  }

  async _ensureDependencies(packages) {
    let pkgSingleton = Package.getSingletonSync("package.json").get();
    let dependencies = { ...(pkgSingleton.dependencies || {}), ...(pkgSingleton.devDependencies || {}) };
    let pkgNames = Object.keys(dependencies);
    let missingDependencies = [];
    for (let pkg of packages) {
      if (!pkgNames.includes(pkg)) {
        missingDependencies.push(pkg);
      }
    }
    if (missingDependencies.length > 0) {
      await PackageManager.install({ packages: missingDependencies });
    }
  }

}

module.exports = ModelGenerator;
