const { Parser } = require("acorn");
const path = require("path");
const util = require("util");
const fs = require("fs-extra");
const fs_readdir = util.promisify(fs.readdir);
const fs_readFile = util.promisify(fs.readFile);
const fs_writeFile = util.promisify(fs.writeFile);
const { evalTemplate, processFile } = require("uu_appg01_devkit-common/src/tools/template-helpers.js");
const { fileExists } = require("../../tools/helpers");
const os = require("os");

const MAIN_ERROR_IDENTIFIER = "extends UseCaseError";

class ErrorGenerator {

  constructor(context, executionQueue) {
    this.context = JSON.parse(JSON.stringify(context));
    this.errorPath = path.normalize(`${context.sourceCodePath}/api/errors/${context.classFile}-error.js`);
    this.errorClassTemplate = path.normalize(`${__dirname}/templates/error-class.js`);
    this.errorConstantTemplate = path.normalize(`${__dirname}/templates/error-constant.js`);
    this.errorTemplate = path.normalize(`${__dirname}/templates/error.js`);
    this.twoPhaseCmdErrorTemplate = path.normalize(`${__dirname}/templates/error-two-phase-cmd.js`);
    this.executionQueue = executionQueue;
  }

  async execute() {
    // Finding Nemo (i.e. the error class every other errors inherits from)
    let mainError = await this._getMainError();
    this.context.mainErrorClass = mainError.class;
    this.context.mainErrorFile = mainError.file;

    let finalizeCmdName = `_${this.context.cmdName}Finalize`;
    let finalizeRollbackCmdName = `_${this.context.cmdName}FinalizeRollback`;
    let finalizeErrorName = `_${this.context.errorName}Finalize`;
    let finalizeRollbackErrorName = `_${this.context.errorName}FinalizeRollback`;

    if (await fileExists(this.errorPath)) {
      console.log(`Checking contents of ${this.errorPath}`);
      // this could be read already in _getMainError :(
      let sourceCode = await fs_readFile(this.errorPath, "utf-8");
      // duplicity check
      let ast = Parser.parse(sourceCode, { sourceType: "module", ecmaVersion: 2023 });
      let errorNames = this.context.isTwoPhase ? [this.context.errorName, finalizeErrorName, finalizeRollbackErrorName] : [this.context.errorName];
      for (let entity of ast.body) {
        let existingConstant;
        if (existingConstant = (entity.type === "VariableDeclaration" && entity.kind === "const" && errorNames.find(errorName => entity.declarations[0].id.name === errorName))) {
          console.log(`${this.errorPath} already contains constant ${existingConstant}`);
          process.exit(1);
        }
      }

      // put the error constant as a last constant in class (easier to find)
      let moduleIdx = sourceCode.indexOf("module.exports");
      let moduleBodyIdx = sourceCode.indexOf("{", moduleIdx) + 1;
      let modulePart = `${sourceCode.substring(moduleIdx, moduleBodyIdx)}${os.EOL}  ${errorNames.join(`,${os.EOL}  `)},${sourceCode.substring(moduleBodyIdx)}`;
      let errorConstants = await this._generateErrorConstant(this.context.cmdName, this.context.errorName, this._getCmdErrors());
      if (this.context.isTwoPhase) {
        errorConstants += os.EOL + await this._generateErrorConstant(finalizeCmdName, finalizeErrorName, this._getFinalizeCmdErrors());
        errorConstants += os.EOL + await this._generateErrorConstant(finalizeRollbackCmdName, finalizeRollbackErrorName, this._getFinalizeRollbackCmdErrors());
      }
      let newError = `${sourceCode.substring(0, moduleIdx)}${errorConstants}${os.EOL}${modulePart}`;
      this.executionQueue.addEvent(async () => {
        console.log(`Modifying ${this.errorPath}`);
        await fs_writeFile(this.errorPath, newError);
      });
    } else {
      this.context.error = await this._generateErrorConstant(this.context.cmdName, this.context.errorName, this._getCmdErrors());
      if (this.context.isTwoPhase) {
        this.context.finalizeErrorName = finalizeErrorName;
        this.context.finalizeRollbackErrorName = finalizeRollbackErrorName;
        this.context.finalizeError = await this._generateErrorConstant(finalizeCmdName, finalizeErrorName, this._getFinalizeCmdErrors());
        this.context.finalizeRollbackError = await this._generateErrorConstant(finalizeRollbackCmdName, finalizeRollbackErrorName, this._getFinalizeRollbackCmdErrors());
      }
      this.executionQueue.addEvent(async () => {
        console.log(`Creating ${this.errorPath}`);
        await processFile(this.context.isTwoPhase ? this.twoPhaseCmdErrorTemplate : this.errorTemplate, this.errorPath, this.context);
      });
    }
  }

  async _generateErrorConstant(cmdName, errorName, errors = []) {
    let errorClasses = [];
    // there is a new local context, bcs it changes per iteration
    // (the instance context could do the same tbh, but I liked it this way)
    let errorClassContext = {
      mainErrorClass: this.context.mainErrorClass,
      errorName: errorName
    };
    errors = errors.concat(this.context.errors);
    for (let error of errors) {
      errorClassContext.errorClassName = error.code.charAt(0).toUpperCase() + error.code.slice(1);
      errorClassContext.errorCode = error.code;
      errorClassContext.errorMessage = error.message;
      errorClasses.push(await evalTemplate(this.errorClassTemplate, errorClassContext));
    }
    // main context has errors and errorConstantTemplate context wants a different errors => another local context
    let errorConstantContext = {
      errors: errorClasses.join(`,${os.EOL}`),
      errorName: errorName,
      constantName: this.context.constantName,
      cmdName: cmdName
    };
    return await evalTemplate(this.errorConstantTemplate, errorConstantContext);
  }

  async _getMainError() {
    let errorFolder = path.dirname(this.errorPath);
    let files = await fs_readdir(errorFolder);
    for (let file of files) {
      let sourceCode = await fs_readFile(path.join(errorFolder, file), "utf-8");
      if (sourceCode.indexOf(MAIN_ERROR_IDENTIFIER) !== -1) {
        let parsedSourceCode = Parser.parse(sourceCode, { sourceType: "module", ecmaVersion: 2023 });
        for (let entity of parsedSourceCode.body) {
          if (entity.type === "ClassDeclaration") {
            return { class: entity.id.name, file };
          }
        }
      }
    }
    console.log(`There is no main error class in ${errorFolder}`);
    process.exit(1);
  }

  _getCmdErrors() {
    if (this.context.errors) return [];

    return this.context.isTwoPhase ? [
      {
        code: "invalidDtoIn",
        message: "DtoIn is not valid.",
      },
      {
        code: `${this.context.cmdName}AlreadyFinished`,
        message: `${this.context.cmdName}AlreadyFinished`,
      },
      {
        code: `${this.context.cmdName}AlreadyInProgress`,
        message: `${this.context.cmdName}AlreadyInProgress`,
      },
      {
        code: "rollbackNotFinished",
        message: "Rollback is not finished.",
      },
      {
        code: `${this.context.cmdName}DidNotStarted`,
        message: `${this.context.cmdName}DidNotStarted`,
      },
      {
        code: "nothingToRollback",
        message: "There is nothing to rollback.",
      },
    ] : [
      {
        code: "invalidDtoIn",
        message: "DtoIn is not valid.",
      }
    ];
  }

  _getFinalizeCmdErrors() {
    return [
      {
        code: "invalidDtoIn",
        message: "DtoIn is not valid.",
      },
      {
        code: "controlObjectDoesNotExist",
        message: "Control object does not exist."
      },
      {
        code: "controlObjectIsNotInProperState",
        message: "Control object is not in proper state."
      }
    ]
  }

  _getFinalizeRollbackCmdErrors() {
    return [
      {
        code: "invalidDtoIn",
        message: "DtoIn is not valid.",
      },
      {
        code: "controlObjectDoesNotExist",
        message: "Control object does not exist."
      },
      {
        code: "controlObjectIsNotInProperState",
        message: "Control object is not in proper state."
      }
    ]
  }

}

module.exports = ErrorGenerator;
