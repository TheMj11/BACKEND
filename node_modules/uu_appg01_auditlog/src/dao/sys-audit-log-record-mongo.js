"use strict";

const { UuObjectDao } = require("uu_appg01_objectstore");
const { DbConnection } = require("uu_appg01_datastore");
const { MongoClient } = require("mongodb");
const READ_PREFERENCE_SECONDARY = "secondaryPreferred";

class SysAuditLogRecordMongo extends UuObjectDao {
  async createSchema() {
    await super.createIndex({ awid: 1, logTime: 1 }, { background: true });
  }

  async create(uuObject) {
    return await super.insertOne(uuObject);
  }

  async listByTime(awid, timeFrom, timeTo, pageInfo) {
    let filter = this._buildAwidLogTimeQuery(awid, timeFrom, timeTo);

    return await super.find(filter, pageInfo, { logTime: 1 }, { sys: 0 });
  }

  async deleteBeforeTime(awid, toTime) {
    let filter = {
      awid,
      $or: [
        {
          logTime: { $lt: toTime },
        },
        {
          logTime: { $lt: toTime.toISOString() },
        },
      ],
    };

    return await super.deleteMany(filter);
  }

  async getCount() {
    return await this._count({});
  }

  async listLogsToTransfer(latestTransferredLogId, appLogStoreUri, pageInfo, projection = {}) {
    let filter;
    if (latestTransferredLogId) {
      filter = {
        $and: [
          {
            _id: { $gt: latestTransferredLogId },
          },
          {
            appLogStoreUri: appLogStoreUri ? { $eq: appLogStoreUri } : { $exists: false },
          },
        ],
      };
    } else {
      filter = {
        appLogStoreUri: appLogStoreUri ? { $eq: appLogStoreUri } : { $exists: false },
      };
    }

    const sort = { _id: 1 };

    filter = super._convertId(filter);

    let pageIndex = pageInfo["pageIndex"] ? pageInfo["pageIndex"] : 0;
    let pageSize = pageInfo["pageSize"] ? pageInfo["pageSize"] : this.defaultPageSize;

    try {
      let totalCount = await this._count(filter);

      return await this._secondaryFindWrapper(filter, { projection }, pageIndex * pageSize, sort, pageSize).then(
        (result) => {
          if (result.code) {
            return result;
          } else {
            return {
              itemList: result,
              pageInfo: {
                pageIndex: pageIndex,
                pageSize: pageSize,
                total: totalCount,
              },
            };
          }
        }
      );
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  async countLogsToTransfer(latestTransferredLogId, appLogStoreUri) {
    let filter;
    if (latestTransferredLogId) {
      filter = {
        $and: [
          {
            _id: { $gt: latestTransferredLogId },
          },
          {
            appLogStoreUri: appLogStoreUri ? { $eq: appLogStoreUri } : { $exists: false },
          },
        ],
      };
    } else {
      filter = {
        appLogStoreUri: appLogStoreUri ? { $eq: appLogStoreUri } : { $exists: false },
      };
    }
    return await super.count(filter);
  }

  async findLatestLogIdToPrune(minCount) {
    let db = await DbConnection.get(this.customUri);
    let collection = await db.collection(this.collectionName);
    let sort = { _id: -1 };
    let cursor = await collection
      .find()
      .sort(sort)
      .limit(1)
      .skip(minCount - 1);
    let lastRecord = null;
    if ((await cursor.hasNext()) && (lastRecord = await cursor.next())) {
      cursor.close();
      return lastRecord._id;
    } else {
      // We were over limit, but no barrier record was returned - no problem, there was
      // probably another pruning initiated from another node
      cursor.close();
      return null;
    }
  }

  async countOlder(id, appLogStoreUri) {
    let filter = {
      $and: [
        {
          _id: { $lt: id },
        },
        {
          appLogStoreUri: appLogStoreUri ? { $eq: appLogStoreUri } : { $exists: false },
        },
      ],
    };
    filter = super._convertId(filter);

    return await super.count(filter);
  }

  async prune(latestLogIdToPrune, appLogStoreUri) {
    let filter = {
      $and: [
        {
          _id: { $lt: latestLogIdToPrune },
        },
        {
          appLogStoreUri: appLogStoreUri ? { $eq: appLogStoreUri } : { $exists: false },
        },
      ],
    };
    filter = super._convertId(filter);
    
    let db = await DbConnection.get(this.customUri);
    let collection = await db.collection(this.collectionName);
    await collection.deleteMany(filter, { writeConcern: { w: 0 } });
  }

  async countRecords(awid, toTime) {
    return await super.count({
      awid,
      $or: [
        {
          logTime: { $lt: toTime },
        },
        {
          logTime: { $lt: toTime.toISOString() },
        },
      ],
    });
  }

  _buildAwidLogTimeQuery(awid, timeFrom, timeTo) {
    let filter = { awid };

    if (timeFrom || timeTo) {
      filter["$and"] = [];
    }

    if (timeFrom) {
      filter["$and"].push({
        $or: [
          {
            // for backward compatibility -> logTime was stored as a String in uuAppAuditLog v1.0.x
            logTime: { $gte: timeFrom },
          },
          {
            logTime: { $gte: timeFrom.toISOString() },
          },
        ],
      });
    }

    if (timeTo) {
      filter["$and"].push({
        $or: [
          {
            logTime: { $lte: timeTo },
          },
          {
            logTime: { $lte: timeTo.toISOString() },
          },
        ],
      });
    }

    return filter;
  }

  async _count(filter) {
    return this._withSecondaryReadPreference(async (mongoClient) => {
      return await mongoClient
        .db()
        .collection(this.collectionName)
        .countDocuments(filter, {})
        .then((result) => {
          return result;
        });
    });
  }

  async _secondaryFindWrapper(filter, options, skip = 0, sort = {}, limit = 0) {
    return this._withSecondaryReadPreference(async (mongoClient) => {
      return await mongoClient
        .db()
        .collection(this.collectionName)
        .find(filter, options)
        .skip(skip)
        .sort(sort)
        .limit(limit)
        .toArray()
        .then((result) => {
          return this._convertToId(result);
        });
    });
  }

  async _withSecondaryReadPreference(cb) {
    let mongoClient;
    try {
      mongoClient = await MongoClient.connect(this.customUri, { readPreference: READ_PREFERENCE_SECONDARY });
      return await cb(mongoClient);
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    } finally {
      mongoClient && (await mongoClient.close());
    }
  }
}

module.exports = SysAuditLogRecordMongo;
