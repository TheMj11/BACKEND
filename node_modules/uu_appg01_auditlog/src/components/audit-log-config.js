"use strict";

const { Config, BaseError } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");

const ENV_NODE_NAME = "UU_CLOUD_NODE_NAME";

const SUPPORTED_SCHEMA_VERSIONS = ["0.9.0", "1.0.0", "1.1.0", "1.2.0"];
const LATEST_SCHEMA_VERSION = SUPPORTED_SCHEMA_VERSIONS[SUPPORTED_SCHEMA_VERSIONS.length - 1];

const LOG_STORE_URI_KEY_PATTERN = new RegExp(/^uu_app_auditlog_app_logstore_([\w-]+)_uri$/i);
const LOG_STORE_PATTERN_KEY_PATTERN = new RegExp(/^uu_app_auditlog_app_logstore_([\w-]+)_log_type_pattern$/i);

const LOGGER = LoggerFactory.get();

class AuditLogConfig {
  constructor() {
    this.maxRecordCount = Config.get("uu_app_auditlog_max_record_count");
    if (this.maxRecordCount == null) {
      this.maxRecordCount = Config.get("uu_app_auditlog_record_count_limit");
    }
    this.recordLimitCheckAfter = Config.get("uu_app_auditlog_record_limit_check_after");
    this.nodeName = process.env[ENV_NODE_NAME];
    this.prunePolicy = Config.get("uu_app_auditlog_prune_policy");
    this.pruneLockTtl = Config.get("uu_app_auditlog_prune_lock_ttl");
    if (!this.pruneLockTtl) {
      this.pruneLockTtl = 5;
    }
    this.recordPruneEnabled =
      this.maxRecordCount != null &&
      this.maxRecordCount > 0 &&
      this.recordLimitCheckAfter != null &&
      this.recordLimitCheckAfter > 0;
    if (this.recordPruneEnabled) {
      this.minRecordCount = Config.get("uu_app_auditlog_min_record_count");
      if (this.minRecordCount == null || this.minRecordCount < 0 || this.minRecordCount > this.maxRecordCount) {
        this.minRecordCount = this.maxRecordCount;
      }
      LOGGER.info(
        `AuditLog Records prune configured. minRecordCount ${this.minRecordCount}, maxRecordCount ${this.maxRecordCount}, recordLimitCheckAfter ${this.recordLimitCheckAfter}, pruneLockTtl ${this.pruneLockTtl}`,
      );
    } else {
      LOGGER.warn(
        "UU.APP.AUDITLOG/CONFIG_EXPECTED: The uuAuditLog storage retency is not configured (maxRecordCount, minRecordCount, recordLimitCheckAfter), beware of database overflow! See documentation for details.",
      );
    }

    this.appLogStoreUri = Config.get("uu_app_auditlog_app_logstore_uri");
    this.selectiveAppLogStoreUri; // alternative logStore uri - special purpose logStore, only selected records are transferred to it
    this.selectiveAppLogStorePattern; // alternative logStore filter condition - selects records for selective logStore
    this.appLogStoreTransferAfterCount = Config.get("uu_app_auditlog_app_logstore_transfer_after_count");
    if (!this.appLogStoreTransferAfterCount || this.appLogStoreTransferAfterCount < 0) {
      this.appLogStoreTransferAfterCount = 1000;
    }
    this.appLogStoreNotTransferedCount = 0;
    this.appLogStoreLastTransferDate = new Date();
    this.appLogStoreTransferAfterTime = Config.get("uu_app_auditlog_app_logstore_transfer_after_time");
    if (!this.appLogStoreTransferAfterTime) {
      this.appLogStoreTransferAfterTime = 60;
    } else if (this.appLogStoreTransferAfterTime < 5) {
      this.appLogStoreTransferAfterTime = 5;
    }

    this.schemaVersion = Config.get("uu_app_auditlog_record_schema_version");
    if (!this.schemaVersion) {
      this.schemaVersion = LATEST_SCHEMA_VERSION;
    } else if (this.schemaVersion.startsWith("^")) {
      this.schemaVersion = this.schemaVersion.substring(1);
    }
    if (this.schemaVersion.startsWith("1")) {
      this.schemaVersion = LATEST_SCHEMA_VERSION;
    }
    if (!SUPPORTED_SCHEMA_VERSIONS.includes(this.schemaVersion)) {
      throw new BaseError(
        `AuditLog record schema version ${this.schemaVersion} is not supported. Supported versions: ${SUPPORTED_SCHEMA_VERSIONS}`,
      );
    }

    let logStoreNameSet = new Set();
    Object.entries(Config.toJSON()).forEach(([key, value]) => {
      const logStorePatternKeyMatch = LOG_STORE_PATTERN_KEY_PATTERN.exec(key);
      if (logStorePatternKeyMatch) {
        logStoreNameSet.add(logStorePatternKeyMatch[1]);
        if (logStoreNameSet.size > 1) {
          throw new BaseError(
            "In the current version of uuAuditLog, multiple configuration of the uu_app_auditlog_app_logstore_<name> parameter is not supported.",
          );
        }
        this.selectiveAppLogStorePattern = value;
      } else {
        const logStoreUriKeyMatch = LOG_STORE_URI_KEY_PATTERN.exec(key);
        if (logStoreUriKeyMatch) {
          let logStoreName = logStoreUriKeyMatch[1];
          logStoreNameSet.add(logStoreName);
          if (logStoreNameSet.size > 1) {
            throw new BaseError(
              "In the current version of uuAuditLog, multiple configuration of the uu_app_auditlog_app_logstore_<name> parameter is not supported.",
            );
          }
          this.selectiveAppLogStoreUri = value;
          this.selectiveAppLogStoreName = logStoreName;
        }
      }
    });
  }
}

AuditLogConfig.SUPPORTED_SCHEMA_VERSIONS = SUPPORTED_SCHEMA_VERSIONS;
AuditLogConfig.LATEST_SCHEMA_VERSION = LATEST_SCHEMA_VERSION;

module.exports = new AuditLogConfig();
