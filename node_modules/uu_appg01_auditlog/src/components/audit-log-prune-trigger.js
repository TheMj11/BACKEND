"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config, Mutex } = require("uu_appg01_core-utils");
const { DaoFactory } = require("uu_appg01_objectstore");
const logStoreConfig = require("./audit-log-log-store-config.js");

const ASID = Config.getString("asid");
const NODE_NAME = Config.getString("UU_CLOUD_NODE_NAME");

const LOGGER = LoggerFactory.get();

const PRUNE_RECORDS_SIG = "pruneAuditLogRecords";
const PRUNE_RECORDS_SYNC_SIG = "pruneRecordsSync";

const PRUNE_POLICY_TRANSFERRED_LOGS_ONLY = "transferredLogsOnly";

/**
 * Service for pruning (removing) audit log records.
 */
class AuditLogPruneTrigger {
  constructor() {
    this._recordDao = DaoFactory.getDao("sysAuditLogRecord");
    this._configDao = DaoFactory.getDao("sysAuditLogConfig");
    this._mutex = new Mutex();
    this._recordsWritten = 0;
  }

  /**
   * Checks if record prune should be run. If so, it is processed asynchronously in a separate thread.
   *
   */
  async checkTriggerPrune() {
    if (logStoreConfig.isRecordPruneEnabled()) {
      this._recordsWritten++;
      if (this._recordsWritten >= logStoreConfig.getRecordLimitCheckAfter()) {
        this._recordsWritten = 0;
        LOGGER.debug("uuAppAuditLog prune started.");
        try {
          const pruneJobStarted = await this._mutex.runOneAtTime(
            PRUNE_RECORDS_SIG,
            this._pruneAuditLogRecords.bind(this),
            logStoreConfig.getMinRecordCount(),
            logStoreConfig.getMaxRecordCount(),
          );
          LOGGER.debug(`uuAppAuditLog prune job executed: ${pruneJobStarted}.`);
        } catch (e) {
          LOGGER.error("Pruning of old uuAuditLog records failed.", e);
        }
      }
    }
  }

  async _pruneAuditLogRecords(minRecordCount, maxRecordCount) {
    const recordCount = await this._recordDao.getCount();
    if (recordCount < maxRecordCount || recordCount - minRecordCount <= 0) {
      return false;
    }

    const pruneLockObtained = await this._configDao.obtainPruneLock(ASID, NODE_NAME, logStoreConfig.getPruneLockTtl());
    if (!pruneLockObtained) {
      if (LOGGER.isWarnLoggable()) {
        const sysAuditLogConfig = await this._configDao.getByAwid(ASID);
        const pruneLock = sysAuditLogConfig.pruneLock;
        LOGGER.warn(
          "Pruning of old uuAuditLog records not triggered because it is locked. It was probably started by another node." +
            ` pruneLockedBy=${pruneLock.lockedBy}, pruneLockedSince=${pruneLock.lockedSince}, pruneLockTtl=${logStoreConfig.getPruneLockTtl()}`,
        );
      }
      return false;
    }

    const latestLogIdToPrune = await this._recordDao.findLatestLogIdToPrune(minRecordCount);
    if (!latestLogIdToPrune) {
      LOGGER.debug(`No uuAuditLog records were found to prune. minRecordCount=${minRecordCount}`);
      return false;
    }

    if (PRUNE_POLICY_TRANSFERRED_LOGS_ONLY === logStoreConfig.getPrunePolicy()) {
      const sysAuditLogConfig = await this._configDao.getByAwid(ASID);
      if (!this._atLeastOneTransferFinished(sysAuditLogConfig)) {
        LOGGER.error(
          `Prune policy set to transferredLogsOnly, but the log transfer never started. uuAuditLog records prune wont be triggered. asid=${ASID}`,
        );
        return false;
      }
    }

    this._mutex.runOneAtTime(
      PRUNE_RECORDS_SYNC_SIG,
      this._pruneRecordsSync.bind(this),
      latestLogIdToPrune,
      recordCount,
    );

    return true;
  }

  async _pruneRecordsSync(latestLogIdToPrune, recordCount) {
    let pruneRecordCount = 0;
    const sysAuditLogConfig = await this._configDao.getByAwid(ASID);

    const activeLogStoreKeyList = logStoreConfig.getActiveLogStoreKeyList();
    if (activeLogStoreKeyList.length) {
      for (const targetAppLogStore of activeLogStoreKeyList) {
        const logStoreItem = logStoreConfig.getLogStoreItemFromConfiguration(sysAuditLogConfig, targetAppLogStore);
        if (!logStoreItem) {
          continue;
        }
        const logStorePruneRecordCount = await this._pruneLogStoreRecordsSync(
          latestLogIdToPrune,
          recordCount,
          pruneRecordCount,
          logStoreItem,
        );
        pruneRecordCount += logStorePruneRecordCount;
      }
    }

    if (!activeLogStoreKeyList.length || !activeLogStoreKeyList.includes("primary")) {
      // prune default records if main logStore is not configured
      const withoutLogStorePruneRecordCount = await this._recordDao.countOlder(latestLogIdToPrune, null);
      await this._prune(recordCount, null, latestLogIdToPrune, pruneRecordCount);
      pruneRecordCount += withoutLogStorePruneRecordCount;
    }

    if (logStoreConfig.getDeprecatedLogStoreList().length) {
      await this._pruneAndCleanDeprecatedLogStoreRecords(
        latestLogIdToPrune,
        recordCount,
        pruneRecordCount,
        sysAuditLogConfig,
      );
    }
  }

  async _pruneAndCleanDeprecatedLogStoreRecords(latestLogIdToPrune, recordCount, pruneRecordCount, sysAuditLogConfig) {
    let deprecatedCleanupList = [];
    for (const targetAppLogStore of logStoreConfig.getDeprecatedLogStoreList()) {
      const logStoreItem = logStoreConfig.getLogStoreItemFromConfiguration(sysAuditLogConfig, targetAppLogStore);
      if (!logStoreItem) {
        continue;
      }
      const logStorePruneRecordCount = await this._pruneLogStoreRecordsSync(
        latestLogIdToPrune,
        recordCount,
        pruneRecordCount,
        logStoreItem,
      );
      pruneRecordCount += logStorePruneRecordCount;
      if (logStoreConfig.hasAllRecordsTransferred(sysAuditLogConfig, targetAppLogStore)) {
        const latestTransferredLogId = logStoreConfig.getLatestLogStoreTransferredLogId(
          sysAuditLogConfig,
          targetAppLogStore,
        );
        if (
          latestTransferredLogId == null ||
          sysAuditLogRecordDao.compareRecordsCreationById(latestTransferredLogId, latestLogIdToPrune) <= 0
        ) {
          deprecatedCleanupList.push(targetAppLogStore);
        }
      }
    }
    if (deprecatedCleanupList.length) {
      const configUpdate = await this._configDao.getByAwid(ASID);
      logStoreConfig.removeDeprecatedLogStoresFromAppLogStoreMap(configUpdate.logStoreMap, deprecatedCleanupList);
      try {
        await this._configDao.update(configUpdate);
      } catch (e) {
        LOGGER.error(
          `Failed to remove deprecated logStores from appLogStoreMap. LogStores: ${deprecatedCleanupList}`,
          e,
        );
      }
    }
  }

  async _pruneLogStoreRecordsSync(latestLogIdToPrune, recordCount, pruneRecordCount, logStoreItem) {
    let logStoreLatestLogIdToPrune = latestLogIdToPrune;
    let logStorePruneRecordCount = 0;

    if (PRUNE_POLICY_TRANSFERRED_LOGS_ONLY === logStoreConfig.getPrunePolicy()) {
      const latestTransferredLogId = logStoreItem.latestTransferredRecordId;

      if (latestTransferredLogId) {
        if (latestLogIdToPrune.toString() > latestTransferredLogId.toString()) {
          logStoreLatestLogIdToPrune = latestTransferredLogId;
          LOGGER.warn(
            "Not all uuAuditLog records found based on prune configuration are ready to prune, because they weren't transferred to the uuAppLogStore yet. " +
              `Removing only uuAuditLogRecords older than latest transferred record. latestTransferredRecordId=${latestTransferredLogId}, pruneRecordCount=${pruneRecordCount}`,
          );
        }
        logStorePruneRecordCount = await this._recordDao.countOlder(
          latestTransferredLogId,
          logStoreItem.logRecordIdentifier,
        );
      }
      if (logStorePruneRecordCount < 1) {
        return 0;
      }
    }

    await this._prune(
      recordCount,
      logStoreItem.logRecordIdentifier,
      logStoreLatestLogIdToPrune,
      logStorePruneRecordCount,
    );
    return logStorePruneRecordCount;
  }

  async _prune(recordCount, logRecordLogStoreIdentifier, logStoreLatestLogIdToPrune, logStorePruneRecordCount) {
    try {
      await this._recordDao.prune(logStoreLatestLogIdToPrune, logRecordLogStoreIdentifier);
      LOGGER.info(
        "Pruning of old uuAuditLog records triggered." +
          ` totalRecordCount=${recordCount},` +
          ` pruneRecordCount=${logStorePruneRecordCount},` +
          ` latestLogIdToPrune=${logStoreLatestLogIdToPrune},` +
          ` minRecordCount=${logStoreConfig.getMinRecordCount()},` +
          ` maxRecordCount=${logStoreConfig.getMaxRecordCount()}`,
      );
    } catch (e) {
      LOGGER.error(
        "Failed to asynchronously purge uuAuditLog records." +
          ` totalRecordCount=${recordCount},` +
          ` pruneRecordCount=${logStorePruneRecordCount},` +
          ` latestLogIdToPrune=${logStoreLatestLogIdToPrune},` +
          ` minRecordCount=${logStoreConfig.getMinRecordCount()},` +
          ` maxRecordCount=${logStoreConfig.getMaxRecordCount()}`,
        e,
      );
    }
  }

  _atLeastOneTransferFinished(sysAuditLogConfig) {
    if (!sysAuditLogConfig) {
      return false;
    }
    for (const activeLogStore of logStoreConfig.getActiveLogStoreKeyList()) {
      if (logStoreConfig.getLatestLogStoreTransferredLogId(sysAuditLogConfig, activeLogStore)) {
        return true;
      }
    }
    return false;
  }
}

module.exports = new AuditLogPruneTrigger();
