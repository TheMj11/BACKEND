"use strict";

const { Config } = require("uu_appg01_core-utils");
const { ErrorConverter } = require("uu_appg01_core-appserver");
const auditLogConfig = require("./audit-log-config.js");

const PRIMARY_LOG_STORE_NAME = "primary";
const DEPRECATED_LOG_STORE_NAME_PREFIX = "depr_";

class AuditLogLogStoreConfig {
  constructor() {
    this._activeLogStoreKeyList = [];
    this._deprecatedLogStoreList = [];

    if (auditLogConfig.appLogStoreUri) {
      this._activeLogStoreKeyList.push(PRIMARY_LOG_STORE_NAME);
    }

    if (auditLogConfig.selectiveAppLogStoreUri && auditLogConfig.selectiveAppLogStorePattern) {
      this._specializedLogStorePattern = new RegExp(auditLogConfig.selectiveAppLogStorePattern);
      this._specializedLogStoreUri = auditLogConfig.selectiveAppLogStoreUri;
      if (auditLogConfig.selectiveAppLogStoreName !== PRIMARY_LOG_STORE_NAME) {
        this._specializedLogStoreName = auditLogConfig.selectiveAppLogStoreName;
      } else {
        this._specializedLogStoreName = "renamed"; // keys need to be unique
      }
      this._activeLogStoreKeyList.push(this._specializedLogStoreName);
    }

    this._uuEe = Config.get("uu_app_auditlog_app_logstore_uuee") || null;
  }

  getActiveLogStoreKeyList() {
    return this._activeLogStoreKeyList;
  }

  isLogStoreEnabled() {
    return !!auditLogConfig.appLogStoreUri || !!this._specializedLogStoreUri;
  }

  isRecordPruneEnabled() {
    return auditLogConfig.recordPruneEnabled;
  }

  getRecordLogStoreUriValue(auditLogRecord) {
    const logTypeCode = auditLogRecord.logTypeCode;
    if (this._specializedLogStorePattern && logTypeCode && this._specializedLogStorePattern.test(logTypeCode)) {
      return this._specializedLogStoreUri;
    }
    return null;
  }

  /**
   * Get logStoreRecordIdentifier based on logStore key.
   * This is a simplified implementation that can be used only for active logStores.
   * @param targetAppLogStoreUri logStoreKey (which always equals to logStoreUri for active logStores)
   * @return logStoreRecordIdentifier (the value of {@link SysAuditLogRecord#getAppLogStoreUri()})
   */
  getLogStoreRecordIdentifier(targetAppLogStoreUri) {
    return targetAppLogStoreUri === auditLogConfig.appLogStoreUri
      ? null // primary logStoreUri records has null value of appLogStoreUri
      : targetAppLogStoreUri;
  }

  getLogStoreItemFromConfiguration(sysAuditLogConfig, targetAppLogStoreKey) {
    if (sysAuditLogConfig.logStoreMap) {
      return sysAuditLogConfig.logStoreMap[targetAppLogStoreKey];
    }
    // compatibility with old config value
    if (PRIMARY_LOG_STORE_NAME === targetAppLogStoreKey) {
      const lastTransferredDate = sysAuditLogConfig.latestTransferDate
        ? new Date(sysAuditLogConfig.latestTransferDate)
        : null;
      return {
        baseUri: auditLogConfig.appLogStoreUri,
        latestTransferredRecordId: sysAuditLogConfig.latestTransferredLogId,
        latestTransferState: sysAuditLogConfig.latestTransferState,
        lastTransferredDate,
      };
    }
    return null;
  }

  hasLogStoreItem(sysAuditLogConfig, targetAppLogStoreKey) {
    if (sysAuditLogConfig.logStoreMap) {
      return Object.keys(sysAuditLogConfig.logStoreMap).includes(targetAppLogStoreKey);
    }
    return PRIMARY_LOG_STORE_NAME === targetAppLogStoreKey; // compatibility with old config - main logStore is considered present without logStoreMap
  }

  /**
   * Gives complete list of configured logStores. The returned value is not taken directly from configuration, but also takes into account previously configured logStores from sysAuditLogConfig.
   *
   * @return key (code) list of all logStores (active and deprecated)
   */
  getDeprecatedLogStoreList() {
    return this._deprecatedLogStoreList;
  }

  /**
   * Checks provided (stored) appLogStoreMap against current logStore configuration and updates the appLogstoreMap accordingly.
   *
   * @param appLogStoreMap appLogStoreMap to check (previously used appLogStoreMap)
   * @return <code>true</code> if any updates were made to appLogStoreMap object
   */
  checkAndUpdateAppLogStoreMap(appLogStoreMap) {
    let logStoreMapUpdated;
    if (this._logStoreMapNeedsUpdate(appLogStoreMap)) {
      this._updateAppLogStoreMap(appLogStoreMap);
      logStoreMapUpdated = true;
    } else {
      logStoreMapUpdated = false;
    }
    this._deprecatedLogStoreList = Array.from(Object.entries(appLogStoreMap)).reduce(
      (acc, [appLogStoreKey, appLogStore]) => {
        if (appLogStore.deprecationDate) {
          acc.push(appLogStoreKey);
        }
        return acc;
      },
      [],
    );
    return logStoreMapUpdated;
  }

  removeDeprecatedLogStoresFromAppLogStoreMap(appLogStoreMap, removeLogStoreList) {
    removeLogStoreList.forEach((logStore) => delete appLogStoreMap[logStore]);
    this._deprecatedLogStoreList = Array.from(Object.entries(appLogStoreMap)).reduce(
      (acc, [appLogStoreKey, appLogStore]) => {
        if (appLogStore.deprecationDate) {
          acc.push(appLogStoreKey);
        }
        return acc;
      },
      [],
    );
  }

  _getPrimaryLogStoreEntry(appLogStoreMap) {
    const primaryItem = appLogStoreMap[PRIMARY_LOG_STORE_NAME];
    if (primaryItem) {
      return [PRIMARY_LOG_STORE_NAME, primaryItem];
    }
    return null;
  }

  _getLogStoreEntryByUri(appLogStoreMap, appLogStoreUri) {
    return Array.from(Object.entries(appLogStoreMap)).find(([_, appLogStore]) => {
      return appLogStoreUri === appLogStore.baseUri;
    });
  }

  _updateAppLogStoreMap(appLogStoreMap) {
    let updatedAppLogStoreMap = {};

    if (auditLogConfig.appLogStoreUri) {
      // add active main logStore
      const primaryLogStoreEntry = this._getPrimaryLogStoreEntry(appLogStoreMap);
      const mainLogStoreItem = this._updateAndRemoveAppLogStoreItem(
        appLogStoreMap,
        primaryLogStoreEntry,
        null,
        auditLogConfig.appLogStoreUri,
        null,
      );
      updatedAppLogStoreMap[PRIMARY_LOG_STORE_NAME] = mainLogStoreItem;
    }

    if (this._specializedLogStoreUri) {
      // add active selective logStore
      const selectiveLogStoreEntry = this._getLogStoreEntryByUri(appLogStoreMap, this._specializedLogStoreUri);
      const selectiveStoreItem = this._updateAndRemoveAppLogStoreItem(
        appLogStoreMap,
        selectiveLogStoreEntry,
        this._specializedLogStorePattern.toString(),
        this._specializedLogStoreUri,
        this._specializedLogStoreUri,
      );
      updatedAppLogStoreMap[this._specializedLogStoreName] = selectiveStoreItem;
    }

    // add already deprecated and deprecate non-active
    const deprecationDate = new Date();
    for (const [appLogStoreKey, appLogStore] of Object.entries(appLogStoreMap)) {
      if (
        (this.getAppLogStoreUri() && !appLogStore.logTypeCodePattern) ||
        (this._specializedLogStoreUri && this._specializedLogStoreUri === appLogStore.logRecordIdentifier)
      ) {
        continue; // do not add logStores as deprecated if they are present as active
      }
      if (!appLogStore.deprecationDate) {
        appLogStore.deprecationDate = deprecationDate;
      }
      let notInserted = true;
      let nonUniqueIndex = 0;
      while (notInserted) {
        const key = this._composeLogStoreMapKey(appLogStoreKey, appLogStore.deprecationDate, nonUniqueIndex);
        if (!updatedAppLogStoreMap[key]) {
          updatedAppLogStoreMap[key] = appLogStore;
          notInserted = false;
        } else {
          nonUniqueIndex++;
        }
      }
    }

    // update the original map instance
    Object.keys(appLogStoreMap).forEach(key => delete appLogStoreMap[key]);
    Object.assign(appLogStoreMap, updatedAppLogStoreMap);
  }

  _updateAndRemoveAppLogStoreItem(
    appLogStoreMap,
    originalLogStoreEntry,
    updatedPattern,
    updatedUri,
    updatedIdentifier,
  ) {
    let mainLogStoreItem = {
      logTypeCodePattern: updatedPattern,
      baseUri: updatedUri,
      logRecordIdentifier: updatedIdentifier,
      latestTransferredRecordId: null,
      latestTransferState: null,
      latestTransferDate: null,
    };

    if (originalLogStoreEntry) {
      // new main logStore continues where the old one finished (so copy its status values and remove deprecated item)
      const prevItem = originalLogStoreEntry[1];
      mainLogStoreItem = {
        ...mainLogStoreItem,
        latestTransferredRecordId: prevItem.latestTransferredRecordId,
        latestTransferState: prevItem.latestTransferState,
        latestTransferDate: prevItem.latestTransferDate,
      };
      delete appLogStoreMap[originalLogStoreEntry[0]];
    }

    return mainLogStoreItem;
  }

  _composeLogStoreMapKey(currentKey, deprecationDate, nonUniqueIndex) {
    let newKey = "";
    if (currentKey.startsWith(DEPRECATED_LOG_STORE_NAME_PREFIX)) {
      newKey += currentKey;
    } else {
      newKey += DEPRECATED_LOG_STORE_NAME_PREFIX + currentKey;
    }
    let deprecationDateString = `_${this._formatDeprecationDate(deprecationDate)}`;
    if (!currentKey.includes(deprecationDateString)) {
      newKey += deprecationDateString;
    }
    if (nonUniqueIndex !== 0) {
      newKey += nonUniqueIndex;
    }
    return newKey;
  }

  _formatDeprecationDate(deprecationDate) {
    const date = new Date(deprecationDate);
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    const seconds = date.getSeconds().toString().padStart(2, "0");
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
  }

  _logStoreMapNeedsUpdate(appLogStoreMap) {
    if (!Object.keys(appLogStoreMap).length) {
      // only create logStoreMap if it is needed (keeping simple form of config if only primary logStore is configured)
      return !!this._specializedLogStoreUri;
    }
    const mainLogStoreEntry = Array.from(Object.entries(appLogStoreMap)).find(([_, appLogStore]) => {
      return !appLogStore.logTypeCodePattern && !appLogStore.deprecationDate;
    });
    if (mainLogStoreEntry) {
      if (mainLogStoreEntry[1].baseUri !== this.getAppLogStoreUri()) {
        return true; // primary logStore uri changed
      }
      if (mainLogStoreEntry[0] !== PRIMARY_LOG_STORE_NAME) {
        return true; // primary logStore name changed (data migration replacing uri used as keys, can be removed in future versions, and the key used to get the entry instead of "scanning values")
      }
    } else {
      if (this.getAppLogStoreUri()) {
        return true; // primary logStore previously not configured
      }
    }

    const selectiveLogStoreEntry = Array.from(Object.entries(appLogStoreMap)).find(([_, appLogStore]) => {
      return appLogStore.logTypeCodePattern && !appLogStore.deprecationDate;
    });
    if (selectiveLogStoreEntry) {
      if (!selectiveLogStoreEntry[1].logTypeCodePattern === auditLogConfig.selectiveAppLogStorePattern) {
        return true; // selective logStore pattern changed (or configuration is removed)
      }
      return selectiveLogStoreEntry[1].baseUri !== this._specializedLogStoreUri; // selective logStore uri changed?
    } else {
      return !!this._specializedLogStoreUri; // new selective logStore configuration?
    }
  }

  _ensureLogStoreValue(logStoreMap, targetAppLogStore) {
    const item = logStoreMap[targetAppLogStore];
    if (!item) {
      // prevent failure if working with outdated configuration
      return {
        baseUri: targetAppLogStore,
        logRecordIdentifier: targetAppLogStore,
      };
    }
    return item;
  }

  getLatestLogStoreTransferredLogId(sysAuditLogConfig, targetAppLogStoreKey) {
    if (sysAuditLogConfig.logStoreMap) {
      return this._ensureLogStoreValue(sysAuditLogConfig.logStoreMap, targetAppLogStoreKey).latestTransferredRecordId;
    }
    // compatibility with old config value
    return sysAuditLogConfig.latestTransferredLogId;
  }

  hasAllRecordsTransferred(sysAuditLogConfig, targetAppLogStoreKey) {
    if (sysAuditLogConfig.logStoreMap) {
      const logStoreInfo = this._ensureLogStoreValue(sysAuditLogConfig.logStoreMap, targetAppLogStoreKey);
      if (!logStoreInfo.latestTransferDate) {
        return false;
      }
      return (
        "completed" === logStoreInfo.latestTransferState &&
        logStoreInfo.deprecationDate < logStoreInfo.latestTransferDate
      );
    }
    // compatibility with old config value
    return false;
  }

  setLatestLogStoreTransferInfo(sysAuditLogConfig, targetAppLogStoreKey, latestTransferredId, lastTransferDate) {
    if (sysAuditLogConfig.logStoreMap) {
      const logStore = sysAuditLogConfig.logStoreMap[targetAppLogStoreKey];
      logStore.latestTransferredRecordId = latestTransferredId;
      logStore.latestTransferDate = lastTransferDate;
      if (!logStore.logTypeCodePattern && !logStore.deprecationDate) {
        // compatibility with old config value - primary logStore values are recorded directly to config
        sysAuditLogConfig.latestTransferredLogId = latestTransferredId;
        sysAuditLogConfig.latestTransferDate = lastTransferDate;
      }
    } else {
      // compatibility with old config value
      sysAuditLogConfig.latestTransferredLogId = latestTransferredId;
      sysAuditLogConfig.latestTransferDate = lastTransferDate;
    }
  }

  setLatestTransferredState(sysAuditLogConfig, targetAppLogStoreKey, latestTransferredState, error) {
    if (sysAuditLogConfig.logStoreMap) {
      const logStore = sysAuditLogConfig.logStoreMap[targetAppLogStoreKey];
      logStore.latestTransferState = latestTransferredState;
      if (!logStore.logTypeCodePattern && !logStore.deprecationDate) {
        // compatibility with old config value - primary logStore values are recorded directly to config
        sysAuditLogConfig.latestTransferState = latestTransferredState;
      }
    } else {
      // compatibility with old config value
      sysAuditLogConfig.latestTransferState = latestTransferredState;
    }

    if (error) {
      const { dtoOut } = ErrorConverter.buildErrorDtoOut(error, true);
      sysAuditLogConfig.uuAppErrorMap = JSON.stringify(dtoOut.uuAppErrorMap);
    } else if (latestTransferredState === "completed") {
      sysAuditLogConfig.uuAppErrorMap = "{}";
    }
  }

  // Config value getters

  getSchemaVersion() {
    return auditLogConfig.schemaVersion;
  }

  getAppLogStoreUri() {
    return auditLogConfig.appLogStoreUri;
  }

  getAppLogStoreTransferAfterCount() {
    return auditLogConfig.appLogStoreTransferAfterCount;
  }

  getAppLogStoreTransferAfterTime() {
    return auditLogConfig.appLogStoreTransferAfterTime;
  }

  getAppLogStoreUuee() {
    return this._uuEe;
  }

  getMaxRecordCount() {
    return auditLogConfig.maxRecordCount;
  }

  getMinRecordCount() {
    return auditLogConfig.minRecordCount;
  }

  getRecordLimitCheckAfter() {
    return auditLogConfig.recordLimitCheckAfter;
  }

  getPrunePolicy() {
    return auditLogConfig.prunePolicy;
  }

  getPruneLockTtl() {
    return auditLogConfig.pruneLockTtl;
  }
}

AuditLogLogStoreConfig.SUPPORTED_SCHEMA_VERSIONS = auditLogConfig.SUPPORTED_SCHEMA_VERSIONS;
AuditLogLogStoreConfig.LATEST_SCHEMA_VERSION = auditLogConfig.LATEST_SCHEMA_VERSION;

module.exports = new AuditLogLogStoreConfig();
