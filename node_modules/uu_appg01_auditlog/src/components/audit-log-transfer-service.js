"use strict";

const { UseCaseContext, ValidationHelper } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { UriBuilder } = require("uu_appg01_core-uri");
const { Config, Mutex } = require("uu_appg01_core-utils");
const { DaoFactory, Lock, ObjectLocked } = require("uu_appg01_objectstore");
const logStoreConfig = require("./audit-log-log-store-config.js");
const appLogStoreClient = require("../log-store-client");

const Errors = require("../api/errors/sys-auditlog-error.js");
const WARNINGS = require("../api/warnings/sys-auditlog-warning.js");

const ASID = Config.getString("asid");
const LOGGER = LoggerFactory.get();

const AUDIT_LOG_CONFIG_LOCK_CODE = "logStoreTransfer";
const AUDIT_LOG_CONFIG_LOCK_EXPIRATION_TIME = 300; // lock expiration time in seconds
const AUDIT_LOG_CONFIG_LOCK_PROLONGING_LIMIT = 60; // minimum remaining time in seconds when lock should be extended
const AUDIT_LOG_RECORD_LIST_PAGE_INFO = { pageIndex: 0, pageSize: 1000, total: -1 };

const TRANSFER_STATES = {
  running: "running",
  completed: "completed",
  completedWithError: "completedWithError",
};

/**
 * Class for handling the request from audit log commands.
 */
class AuditLogTransferService {
  constructor() {
    this._recordDao = DaoFactory.getDao("sysAuditLogRecord");
    this._configDao = DaoFactory.getDao("sysAuditLogConfig");
    this._mutex = new Mutex();
  }

  /**
   *  Transfers all non-transferred logs from the application to the uuAppLogStore.
   *
   * @param {Object} uuAppErrorMap
   * @param getLogsToTransferCount
   * @param preserveActor
   * @return {object} filled dtoOut object
   */
  async transfer(uuAppErrorMap = {}, getLogsToTransferCount = false, preserveActor = true) {
    let dtoOut = {};
    // HDS 1 Checks if log transfer to the uuAppLogStore is enabled by checking the appLogStore uri in deploy configuration
    if (!logStoreConfig.getAppLogStoreUri()) {
      throw new Errors.LogRecordTransfer.AppLogStoreUriIsNotSet(
        { uuAppErrorMap },
        { appLogStoreUri: logStoreConfig.getAppLogStoreUri() },
      );
    }

    // HDS 2 System loads sysAuditLogConfig uuObject using sysAuditLogConfig DAO getByAwid and reads sysAuditLogConfig.latestTransferredLogId
    let sysAuditLogConfig = (await this._configDao.getByAwid(ASID)) || null;
    if (!sysAuditLogConfig) {
      throw new Errors.LogRecordTransfer.SysAuditLogConfigDoesNotExist({ uuAppErrorMap }, { asid: ASID }, {});
    }

    const appLogStoreKeyList = [
      ...logStoreConfig.getActiveLogStoreKeyList(),
      ...logStoreConfig.getDeprecatedLogStoreList(),
    ];

    // HDS 3 System counts number of logs to transfer
    if (getLogsToTransferCount) {
      dtoOut.logsToTransferCount = await this._countLogsToTransfer(appLogStoreKeyList, sysAuditLogConfig);
    }

    // HDS 4 System executes a task to transfers records to configured appLogStores
    this._mutex.runOneAtTime(
      this._transferLogsToAppLogStoresSync.bind(this),
      appLogStoreKeyList,
      preserveActor,
      uuAppErrorMap,
    );

    // HDS 5 Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *  Returns the information about the last log transfer. It returns date, state and number of records to be transferred.
   *
   * @return {object} filled dtoOut object
   */
  async getTransferStatus() {
    // HDS 1 System loads sysAuditLogConfig uuObject
    let sysAuditLogConfig = await this._configDao.getByAwid(ASID);
    if (!sysAuditLogConfig) {
      throw new Errors.LogRecordGetTransferStatus.SysAuditLogConfigDoesNotExist({}, { asid: ASID }, {});
    }

    // HDS 2 System list all non transferred records
    const activeLogStoreUriList = logStoreConfig.getActiveLogStoreKeyList();
    const notTransferredLogCount = await this._countLogsToTransfer(activeLogStoreUriList, sysAuditLogConfig);

    // transform uuAppErrorMap to object if present. It is serialized to string to prevent mongodb issues with error map structure
    let uuAppErrorMap = sysAuditLogConfig.uuAppErrorMap || {};
    if (typeof sysAuditLogConfig.uuAppErrorMap === "string") {
      uuAppErrorMap = JSON.parse(uuAppErrorMap);
    }

    //HDS 3. System returns properly filled dtoOut.
    return {
      latestTransferState: sysAuditLogConfig.latestTransferState || null,
      latestTransferDate: sysAuditLogConfig.latestTransferDate || null,
      notTransferredLogCount,
      uuAppErrorMap,
    };
  }

  async _countLogsToTransfer(logStoreKeyList, auditLogConfig) {
    let transferCount = 0;
    for (const targetAppLogStoreKey of logStoreKeyList) {
      const logStoreItem = logStoreConfig.getLogStoreItemFromConfiguration(auditLogConfig, targetAppLogStoreKey);
      if (!logStoreItem) {
        continue;
      }
      const latestTransferredLogId = logStoreItem.latestTransferredRecordId;
      const logStoreDaoRecordId = logStoreItem.logRecordIdentifier;
      transferCount += await this._recordDao.countLogsToTransfer(latestTransferredLogId, logStoreDaoRecordId);
    }
    return transferCount;
  }

  async _transferLogsToAppLogStoresSync(logStoreKeyList, preserveActor, uuAppErrorMap = {}) {
    let failedLogStoreKeyList = [];
    let lastEncounteredException;
    for (const targetLogStoreKey of logStoreKeyList) {
      try {
        await this._transferLogsToAppLogStoreAndUpdateConfig(
          targetLogStoreKey,
          preserveActor,
          uuAppErrorMap,
        );
      } catch (e) {
        lastEncounteredException = e;
        failedLogStoreKeyList.push(targetLogStoreKey);
      }
    }
    if (lastEncounteredException) {
      throw new Errors.LogRecordTransfer.TransferRecordsToAppLogStoreFailed(
        { uuAppErrorMap },
        { logSourceUri: this._getLogSourceUri(), appLogStoreUriList: failedLogStoreKeyList },
        lastEncounteredException,
      );
    }
  }

  async _transferLogsToAppLogStoreAndUpdateConfig(targetLogStoreKey, preserveActor, uuAppErrorMap = {}) {
    const lock = new Lock(AUDIT_LOG_CONFIG_LOCK_CODE, AUDIT_LOG_CONFIG_LOCK_EXPIRATION_TIME);
    let sysAuditLogConfig;

    try {
      // HDS X.1 Lock auditLogConfig
      sysAuditLogConfig = await this._acquireSysAuditLogConfig(lock);

      if (!sysAuditLogConfig) {
        ValidationHelper.addWarning(
          uuAppErrorMap,
          WARNINGS.transfer.transferHasAlreadyStarted.code,
          WARNINGS.transfer.transferHasAlreadyStarted.message,
        );
        LOGGER.warn("The transfer has already started.");
        return; // auditLogConfig not acquired, do nothing
      }

      // HDS X.2 Update auditLogConfig state
      if (!logStoreConfig.hasLogStoreItem(sysAuditLogConfig, targetLogStoreKey)) {
        LOGGER.warn(`LogStore information not present within LogStoreMap for key: ${targetLogStoreKey}.`);
        return; // logStore information not acquired, do nothing
      }

      logStoreConfig.setLatestTransferredState(sysAuditLogConfig, targetLogStoreKey, TRANSFER_STATES.running);
      await this._updateAuditLogConfigStatus(sysAuditLogConfig, lock, uuAppErrorMap);

      // HDS X.3 Transfer iteration
      const latestTransferredLogId = await this._transferLogRecordsToLogStore(
        targetLogStoreKey,
        preserveActor,
        lock,
        sysAuditLogConfig,
        uuAppErrorMap,
      );

      // HDS X.4 Update auditLogConfig state
      logStoreConfig.setLatestTransferredState(sysAuditLogConfig, targetLogStoreKey, TRANSFER_STATES.completed);
      logStoreConfig.setLatestLogStoreTransferInfo(
        sysAuditLogConfig,
        targetLogStoreKey,
        latestTransferredLogId,
        new Date(),
      );
      await this._updateAuditLogConfigStatus(sysAuditLogConfig, lock, uuAppErrorMap);
    } catch (e) {
      const error = new Errors.LogRecordTransfer.TransferRecordsToAppLogStoreFailed(
        { uuAppErrorMap },
        { asid: ASID, appLogStoreUri: targetLogStoreKey },
        e,
      );
      LOGGER.error("Failed to transfer auditLog records to uuAppLogStore.", error);

      if (sysAuditLogConfig) {
        logStoreConfig.setLatestTransferredState(sysAuditLogConfig, targetLogStoreKey, TRANSFER_STATES.completedWithError, error);
        try {
          await this._configDao.updateById(sysAuditLogConfig.id, sysAuditLogConfig, lock);
        } catch (ex) {
          LOGGER.warn("Failed to update auditLogConfig with error state.", ex);
        }
      }
    } finally {
      if (sysAuditLogConfig) {
        await this._configDao.unlockById(sysAuditLogConfig.id, lock);
      }
    }
  }

  async _transferLogRecordsToLogStore(
    targetLogStoreKey,
    preserveActor,
    lock,
    sysAuditLogConfig,
    uuAppErrorMap = {},
  ) {
    // HDS X.3 Transfer iteration
    const logStoreItem = logStoreConfig.getLogStoreItemFromConfiguration(sysAuditLogConfig, targetLogStoreKey);
    if (!logStoreItem) {
      LOGGER.warn(`LogStoreItem not found for logStore with key: ${targetLogStoreKey}.`);
      return null;
    }
    const logStoreRecordIdentifier = logStoreItem.logRecordIdentifier;
    const targetLogStoreUri = logStoreItem.baseUri;
    LOGGER.debug(`Transferring Logs to logStore with key: ${targetLogStoreKey} will be sent to ${targetLogStoreUri}.`);

    let allRecordsProcessed = false;
    let latestTransferredLogId = logStoreItem.latestTransferredRecordId;
    let iteration = 0;

    while (!allRecordsProcessed) {
      // HDS X.3.1 List records for transfer
      const sysAuditLogRecordList = await this._recordDao.listLogsToTransfer(
        latestTransferredLogId,
        logStoreRecordIdentifier,
        AUDIT_LOG_RECORD_LIST_PAGE_INFO,
      );

      if (!sysAuditLogRecordList.itemList.length) {
        LOGGER.debug(`No records to transfer for logStore with key: ${targetLogStoreKey}.`);
        break;
      }

      if (iteration++ % 50 == 0 && LOGGER.isInfoLoggable()) {
        LOGGER.info(`Processing logStore transfer iteration: ${iteration}`);
      }

      // HDS X.3.2 Transfer records, update status, extend lock
      latestTransferredLogId = await this._transferLogRecordsPageToLogStore(
        targetLogStoreKey,
        targetLogStoreUri,
        preserveActor,
        lock,
        sysAuditLogConfig,
        sysAuditLogRecordList,
        uuAppErrorMap,
      );

      if (sysAuditLogRecordList.itemList.length < AUDIT_LOG_RECORD_LIST_PAGE_INFO.pageSize) {
        allRecordsProcessed = true;
      }
    }
    return latestTransferredLogId;
  }

  async _transferLogRecordsPageToLogStore(
    appLogStoreKey,
    appLogStoreUri,
    preserveActor,
    lock,
    sysAuditLogConfig,
    sysAuditLogRecordList,
    uuAppErrorMap = {},
  ) {
    try {
      const recordUriSet = Array.from(
        new Set(
          sysAuditLogRecordList.itemList.map((sysAuditLogRecord) => {
            sysAuditLogRecord.appLogStoreUri;
          }),
        ),
      ).filter((uri) => uri);
      LOGGER.info(
        "transfer! targetUri: " +
          appLogStoreUri +
          ", count: " +
          sysAuditLogRecordList.itemList.length +
          ", recordUri: " +
          recordUriSet.join(", "),
      );
      const logRecordImportDtoOut = await appLogStoreClient.importLogRecords(
        appLogStoreUri,
        sysAuditLogRecordList.itemList,
        preserveActor,
      );
      LOGGER.debug(`LogRecords transferred successfully. Count ${logRecordImportDtoOut.logRecordCount}`);
    } catch (e) {
      throw new Errors.LogRecordTransfer.TransferRecordsToAppLogStoreFailed(
        { uuAppErrorMap },
        { logSourceUri: this._getLogSourceUri(), appLogStoreUri },
        e,
      );
    }

    await this._extendLock(lock);

    const latestTransferredLogId = sysAuditLogRecordList.itemList[sysAuditLogRecordList.itemList.length - 1].id;

    logStoreConfig.setLatestLogStoreTransferInfo(sysAuditLogConfig, appLogStoreKey, latestTransferredLogId, new Date());
    await this._updateAuditLogConfigStatus(sysAuditLogConfig, lock, uuAppErrorMap);

    return latestTransferredLogId;
  }

  async _updateAuditLogConfigStatus(sysAuditLogConfig, lock, uuAppErrorMap = {}) {
    try {
      const updatedSysAuditLogConfig = await this._configDao.updateById(sysAuditLogConfig.id, sysAuditLogConfig, lock);
      Object.keys(sysAuditLogConfig).forEach(key => delete sysAuditLogConfig[key]);
      Object.assign(sysAuditLogConfig, updatedSysAuditLogConfig);
    } catch (e) {
      throw new Errors.LogRecordTransfer.SysAuditLogConfigDaoUpdateFailed(
        { uuAppErrorMap },
        { asid: ASID, id: sysAuditLogConfig.id },
        e,
      );
    }
  }

  async _extendLock(lock) {
    const t = new Date();
    t.setSeconds(t.getSeconds() + AUDIT_LOG_CONFIG_LOCK_PROLONGING_LIMIT);

    if (lock.expiration < t) {
      await lock.extendExpiration(AUDIT_LOG_CONFIG_LOCK_EXPIRATION_TIME);
    }
  }

  async _acquireSysAuditLogConfig(lock) {
    try {
      return await this._configDao.lockByAwid(ASID, lock);
    } catch (e) {
      if (e instanceof ObjectLocked) {
        return null;
      }
      throw e;
    }
  }

  _getLogSourceUri() {
    let logSourceUri;
    let uri = UseCaseContext.getUri();

    if (uri) {
      logSourceUri = UriBuilder.parse(uri).setAwid(ASID).toUri();
    }

    return logSourceUri;
  }
}

module.exports = new AuditLogTransferService();
