"use strict";

const jsonpath = require("jsonpath");
const { UseCaseContext, ValidationHelper } = require("uu_appg01_core-appserver");
const { Validator } = require("uu_appg01_core-validation");
const { DaoFactory } = require("uu_appg01_objectstore");
const { Config, Mutex } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const LogStoreConfig = require("../components/audit-log-log-store-config.js");
const auditLogTransferTrigger = require("../components/audit-log-transfer-trigger.js");
const auditLogTransferService = require("../components/audit-log-transfer-service.js");
const auditLogPruneTrigger = require("../components/audit-log-prune-trigger.js");

const Errors = require("../api/errors/sys-auditlog-error.js");
const WARNINGS = require("../api/warnings/sys-auditlog-warning.js");

const DEFAULT_PAGE_INFO = {
  pageIndex: 0,
  pageSize: 1000,
};

const SCHEMA_0_9_0 = "0.9.0";

class SysAuditLogAbl {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.auditlog.SysAuditLogAbl");
    this.validator = Validator.load();
    this.mutex = new Mutex();
    this.asid = Config.get("asid");
    this.dao = DaoFactory.getDao("sysAuditLogRecord");
    this.configDao = DaoFactory.getDao("sysAuditLogConfig");
    this.recordsWritten = 0;
    this.schemaVersion = LogStoreConfig.getSchemaVersion();
  }

  getSchemaVersion() {
    return this.schemaVersion;
  }

  async createAuditLogRecord(dtoIn) {
    // HDS 1 Performs a logical check of dtoIn
    // HDS 1.1
    let validationResult = this.validator.validate("createDtoInSchemaType", dtoIn);
    // HDS 1.2, A1, A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.createAuditLogRecord.unsupportedKeys.code,
      Errors.CreateAuditLogRecord.InvalidDtoIn
    );

    let uri = UseCaseContext.getUri();
    let awid = uri.getAwid();
    let customSession = UseCaseContext.getSession();
    let requestId = UseCaseContext.getRequestId();
    let date = new Date();

    // HDS 2 Creates sysAuditLogRecord uuObject containing dtoIn parameters and other necessary attributes according to its uuSchema
    let auditLogRecord = {
      logRecordSchemaVersion: this.schemaVersion,
      awid,
      spp: uri.getSpp() || "",
      useCase: uri.getUseCase(),
      requestId,
      sid: customSession.getAuthenticationId(),
      logTime: date,
      severity: dtoIn.severity,
      message: dtoIn.message,
      useCaseContextAttributesAuditMap: this._parseUseCaseContextAttributes(),
    };


    const identity = customSession.getIdentity();
      switch(this.schemaVersion){
        case SCHEMA_0_9_0:
          auditLogRecord.eventTypeCode = dtoIn.logTypeCode;
          auditLogRecord.parameters = dtoIn.logData;
          if (identity) {
            auditLogRecord.identity = identity.getUuIdentity();
            auditLogRecord.identityName = identity.getName();
            auditLogRecord.identityType = identity.getType();
          }
          break;
        default:
          const actorIdentity = customSession.getActorIdentity();
          auditLogRecord.logTypeCode = dtoIn.logTypeCode;
          auditLogRecord.logData = dtoIn.logData;
          auditLogRecord.logUuAppKey = `${uri.getVendor()}-${uri.getApp()}-${uri.getSubApp()}/${this.asid}-${awid}`;
          auditLogRecord.uuNodeId = this.nodeName;
          auditLogRecord.logger = "uuAppAuditLog";
          auditLogRecord.acr = customSession.getAttribute("acr");
          auditLogRecord.amr = customSession.getAttribute("amr");
          if (identity) {
            auditLogRecord.uuIdentity = identity.getUuIdentity();
            auditLogRecord.uuIdentityName = identity.getName();
            auditLogRecord.uuIdentityType = identity.getType();
            auditLogRecord.uuIdentityAccountType = identity.getAccountType() || "standard";
            if (actorIdentity) {
              auditLogRecord.actUuIdentity = actorIdentity.getUuIdentity();
              auditLogRecord.actUuIdentityName = actorIdentity.getName();
              auditLogRecord.actUuIdentityType = actorIdentity.getType();
              auditLogRecord.actUuIdentityAccountType = actorIdentity.getAccountType() || "standard";
            } else {
              auditLogRecord.actUuIdentity = auditLogRecord.uuIdentity;
              auditLogRecord.actUuIdentityName = auditLogRecord.uuIdentityName;
              auditLogRecord.actUuIdentityType = auditLogRecord.uuIdentityType;
              auditLogRecord.actUuIdentityAccountType = auditLogRecord.uuIdentityAccountType;
            }
        }
      }

    const appLogStoreUri = LogStoreConfig.getRecordLogStoreUriValue(auditLogRecord);
    if (appLogStoreUri) {
      auditLogRecord.appLogStoreUri = appLogStoreUri;
    }

    let dtoOut = await this.dao.create(auditLogRecord);

    // HDS 3 Checks if log transfer to the uuAppLogStore is enabled
    await auditLogTransferTrigger.checkTriggerTransfer();

    // HDS 7 Checks that recordLimit and recordLimitCheckAfter are set in the configuration
    await auditLogPruneTrigger.checkTriggerPrune();

    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }


  /**
   *  Returns the information about the last log transfer. It returns date, state and number of records to be transferred.
   *
   * @return {object} filled dtoOut object
   */
  async getTransferStatus() {
    return await auditLogTransferService.getTransferStatus();
  }

  async deleteAuditLogRecordsBeforeTime(awid, dtoIn) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("deleteBeforeTimeDtoInSchemaType", dtoIn);

    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.deleteBeforeTime.unsupportedKeys.code,
      Errors.DeleteBeforeTime.InvalidDtoIn
    );

    // HDS 2
    const toTime = new Date(dtoIn.toTime);

    let deleteCounter = await this.dao.count({
      // TODO, replace this with result of deleteMany operation (after uuAppObjectStore gets fixed)
      awid,
      $or: [
        {
          logTime: { $lt: toTime },
        },
        {
          logTime: { $lt: toTime.toISOString() },
        },
      ],
    });
    await this.dao.deleteBeforeTime(awid, toTime);

    let dtoOut = {};

    // HDS 3
    dtoOut.deletedCount = deleteCounter;
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    // HDS 4
    return dtoOut;
  }

  /**
   *  Returns log records from given time interval.
   *  The result set is paginated in order to avoid big memory footprints.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @returns {Promise<*>}
   */
  async logRecordList(awid, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysLogRecordListDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.logRecordList.unsupportedKeys.code,
      Errors.LogRecordList.InvalidDtoIn
    ); // A1, A2

    // converting time to object
    if (dtoIn.timeFrom) {
      dtoIn.timeFrom = new Date(dtoIn.timeFrom);
    }
    if (dtoIn.timeTo) {
      dtoIn.timeTo = new Date(dtoIn.timeTo);
    }

    // HDS 1.4. - Keys that are missing from dtoIn and are provided with a respective default value.
    if (!dtoIn.timeTo) dtoIn.timeTo = new Date();

    let pageInfo = dtoIn.pageInfo || {};
    if (!pageInfo.pageIndex) {
      pageInfo.pageIndex = DEFAULT_PAGE_INFO.pageIndex;
    }
    if (!pageInfo.pageSize) {
      pageInfo.pageSize = DEFAULT_PAGE_INFO.pageSize;
    }

    // HDS 2. - Checks that dtoIn.timeFrom is before dtoIn.timeTo. (A3)
    if (dtoIn.timeFrom >= dtoIn.timeTo) {
      throw new Errors.LogRecordList.InvalidIntervalDefinition(
        { uuAppErrorMap },
        { timeFrom: dtoIn.timeFrom, timeTo: dtoIn.timeTo }
      );
    }

    // HDS 3. - Evaluates the search condition according to the dtoIn parameters

    // HDS 3.1 - If the dtoIn.timeFrom is given, its value is included in the search condition
    // - dtoIn.timeFrom <= sysAuditLogRecord.logTime.

    // HDS 3.2 - If the dtoIn.timeTo is given, its value is included in the search condition
    // - dtoIn.timeTo > sysAuditLogRecord.logTime.

    // HDS 4. - System loads elements matching the search condition, but only on given page. (sysAuditLogRecord DAO listByTime)
    let dtoOut = await this.dao.listByTime(awid, dtoIn.timeFrom, dtoIn.timeTo, pageInfo);

    // HDS 5. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *  Transfers all non-transferred logs from the application to the uuAppLogStore.
   *
   * @param {Object} uuAppErrorMap
   * @param getLogsToTransferCount
   * @param preserveActor
   * @return {object} filled dtoOut object
   */
  async transfer(uuAppErrorMap = {}, getLogsToTransferCount = true, preserveActor = true) {
    let dtoOut = {};

    const { logsToTransferCount } = await auditLogTransferService.transfer(
      uuAppErrorMap,
      getLogsToTransferCount,
      preserveActor,
    );

    dtoOut.logsToTransferCount = logsToTransferCount;
    dtoOut.uuAppErrorMap = uuAppErrorMap;

    return dtoOut;
  }

  async logRecordPrivilegedList(dtoIn, asid = this.asid) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysLogRecordPrivilegedListDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.logRecordPrivilegedList.unsupportedKeys.code,
      Errors.LogRecordPrivilegedList.InvalidDtoIn
    );

    // converting time to object
    if (dtoIn.timeFrom) {
      dtoIn.timeFrom = new Date(dtoIn.timeFrom);
    }
    if (dtoIn.timeTo) {
      dtoIn.timeTo = new Date(dtoIn.timeTo);
    }

    // HDS 1.4. - Keys that are missing from dtoIn and are provided with a respective default value.
    if (!dtoIn.timeTo) dtoIn.timeTo = new Date();

    let pageInfo = dtoIn.pageInfo || {};
    if (!pageInfo.pageIndex) {
      pageInfo.pageIndex = DEFAULT_PAGE_INFO.pageIndex;
    }
    if (!pageInfo.pageSize) {
      pageInfo.pageSize = DEFAULT_PAGE_INFO.pageSize;
    }

    // HDS 2. - Checks that dtoIn.timeFrom is before dtoIn.timeTo. (A3)
    if (dtoIn.timeFrom >= dtoIn.timeTo) {
      throw new Errors.LogRecordPrivilegedList.InvalidIntervalDefinition(
        { uuAppErrorMap },
        { timeFrom: dtoIn.timeFrom, timeTo: dtoIn.timeTo }
      );
    }

    // HDS 3. - Evaluates the search condition according to the dtoIn parameters

    // HDS 3.1 - If the dtoIn.timeFrom is given, its value is included in the search condition
    // - dtoIn.timeFrom <= sysAuditLogRecord.logTime.

    // HDS 3.2 - If the dtoIn.timeTo is given, its value is included in the search condition
    // - dtoIn.timeTo > sysAuditLogRecord.logTime.

    // HDS 4. - System loads elements matching the search condition, but only on given page. (sysAuditLogRecord DAO listByTime)
    let dtoOut = await this.dao.listByTime(asid, dtoIn.timeFrom, dtoIn.timeTo, pageInfo);

    // HDS 5. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  async privilegedDelete(dtoIn, asid = this.asid) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("privilegedDeleteDtoInSchemaType", dtoIn);

    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.privilegedDelete.unsupportedKeys.code,
      Errors.PrivilegedDelete.InvalidDtoIn
    );

    // HDS 2
    const toTime = new Date(dtoIn.toTime);
    let deleteCounter;

    deleteCounter = await this.dao.countRecords(asid, toTime);
    try {
      await this.dao.deleteBeforeTime(asid, toTime);
    } catch (error) {
      throw new Errors.PrivilegedDelete.DaoFailed({ uuAppErrorMap }, { cause: { ...error } });
    }

    let dtoOut = {};

    // HDS 3
    dtoOut.deletedCount = deleteCounter;
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    // HDS 4
    return dtoOut;
  }

  _parseUseCaseContextAttributes() {
    if (!UseCaseContext.isAvailable()) {
      return null;
    }
    let ctxUseCaseProperties = UseCaseContext.getUseCaseProperties();
    if (!ctxUseCaseProperties) {
      return null;
    }
    let ctxAuditMap = ctxUseCaseProperties.getAttribute("useCaseContextAttributesAuditMap");
    let ctxAttributeNames = UseCaseContext.getAttributeNames();
    if (!ctxAuditMap || !ctxAttributeNames || ctxAttributeNames.length === 0) {
      return null;
    }
    let result = {};
    for (let [key, path] of Object.entries(ctxAuditMap)) {
      let jsonPathElements = path.split(".");
      if (jsonPathElements.length === 1) {
        let ctxAttributes = {};
        for (let attributeName of ctxAttributeNames) {
          ctxAttributes[attributeName] = UseCaseContext.getAttribute(attributeName);
        }
        result[key] = ctxAttributes;
      } else {
        let rootValue = UseCaseContext.getAttribute(jsonPathElements[1]);
        if (typeof rootValue === "undefined") {
          continue;
        } else if (jsonPathElements.length === 2) {
          result[key] = rootValue;
        } else {
          let subPath = `$.${jsonPathElements.slice(2).join(".")}`;
          try {
            let value = jsonpath.query(rootValue, subPath);
            if (value.length === 0) {
              // the expected value is not in dtoIn
              continue;
            }
            result[key] = value[0];
          } catch (e) {
            this.logger.warn(`The expected JSONPath string ${path} is invalid`, e);
          }
        }
      }
    }
    return result;
  }

}

module.exports = new SysAuditLogAbl();
