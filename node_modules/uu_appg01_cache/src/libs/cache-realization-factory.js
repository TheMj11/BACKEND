// @ts-check
"use strict";

const merge = require("deepmerge");
/**
 * Overwrites arrays instead of catenating them.
 * @template T
 * @param {(T|Partial<T>)[]} objects
 * @returns {T}
 */
const mergeWithOverwrite = (objects) => merge.all(objects, { arrayMerge: (_destination, source) => source });

const { LoggerFactory } = require("uu_appg01_core-logging");

const CacheRealizationLoader = require("./cache-realization-loader");
const CacheConfigLoader = require("./cache-config-loader");
const DisabledCacheRealization = require("../modules/cache/disabled-cache-realization");
const CacheChain = require("./cache-chain");

const logger = LoggerFactory.get("UuApp.Cache.RealizationFactory", true);

/**
 * Cache realization factory. Creates cache realization by its name using available cache realizations {@link CacheRealizationLoader}.
 * Uses configuration {@link CacheConfigLoader} to get cache realizations configuration.
 */
class CacheRealizationFactory {
  /**
   * Builds a cache realization.
   * @param {string} code
   * @param {Partial<CacheConfigLoader.CacheConfig>} config
   * @returns {CacheChain} cache realization
   */
  create(code, config = {}) {
    /**
     * @type {import("./cache-config-loader").CacheConfig}
     */
    let loadedConfig;
    try {
      const cacheConfig = CacheConfigLoader.getCacheConfig(code);
      loadedConfig = mergeWithOverwrite([cacheConfig, config]);
    } catch (e) {
      // if cache config is not found, warn the user
      logger.warn(
        `Cache config for cache "${code}" not found. Only global defaults and the config passed to the method will be used.`
      );

      // merge with defaults
      loadedConfig = CacheConfigLoader.addHardwiredHandlers(
        mergeWithOverwrite([CacheConfigLoader.getDefaultCacheConfig(), config])
      );
    }
    if (config.disabled) {
      return this._instantiateCache(code, DisabledCacheRealization, [], config.config ?? {});
    }
    const cacheRealization = CacheRealizationLoader.getCacheRealization(loadedConfig.realization, loadedConfig.policy);
    const hardwiredHandlers = cacheRealization.REALIZATION_HARDWIRED_HANDLERS || [];
    const externalHandlers = loadedConfig.handlers.filter((handlerName) => !hardwiredHandlers.includes(handlerName));
    const handlers = hardwiredHandlers
      .concat(externalHandlers)
      .map((/** @type {string} */ handlerName) => CacheRealizationLoader.getCacheHandler(handlerName));
    return this._instantiateCache(code, cacheRealization, handlers, loadedConfig.config);
  }

  /**
   * Reloads config used to build cache realizations.
   */
  reload() {
    CacheRealizationLoader.reloadRealizations();
    CacheConfigLoader.loadConfig();
  }

  /**
   * Creates a new instance of cache chain.
   * @param {string} code
   * @param {{}} CacheRealization - cache realization class
   * @param {{}[]} handlers - cache handlers
   * @param {Record<string, unknown>} config - cache options
   * @returns {CacheChain}
   */
  _instantiateCache(code, CacheRealization, handlers, config = {}) {
    return new CacheChain(code, CacheRealization, handlers, config);
  }
}

module.exports = new CacheRealizationFactory();
